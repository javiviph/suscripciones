import Ct from "react";
var Rp = /* @__PURE__ */ ((e) => (e.RENDER_FINISHED = "render-finished", e.RESIZE = "chart-resize", e.MOUSEOVER = "chart-mouseover", e.MOUSEOUT = "chart-mouseout", e))(Rp || {}), Ip = /* @__PURE__ */ ((e) => (e.SHOW = "show-modal", e.HIDE = "hide-modal", e))(Ip || {}), Np = /* @__PURE__ */ ((e) => (e.UPDATE = "model-update", e))(Np || {}), Pp = /* @__PURE__ */ ((e) => (e.SHOW_OVERFLOW_MENU = "show-toolbar-overflow-menu", e.HIDE_OVERFLOW_MENU = "hide-toolbar-overflow-menu", e.BUTTON_CLICK = "toolbar-button-click", e.SHOW_TOOLTIP = "toolbar-show-tooltip", e.HIDE_TOOLTIP = "toolbar-hide-tooltip", e))(Pp || {}), Up = /* @__PURE__ */ ((e) => (e.UPDATE = "zoom-bar-update", e.SELECTION_START = "zoom-bar-selection-start", e.SELECTION_IN_PROGRESS = "zoom-bar-selection-in-progress", e.SELECTION_END = "zoom-bar-selection-end", e))(Up || {}), Bp = /* @__PURE__ */ ((e) => (e.CHANGE = "zoom-domain-change", e))(Bp || {}), Hp = /* @__PURE__ */ ((e) => (e.CANVAS_ZOOM_IN = "canvas-zoom-in", e.CANVAS_ZOOM_OUT = "canvas-zoom-out", e))(Hp || {}), Vp = /* @__PURE__ */ ((e) => (e.LABEL_MOUSEOVER = "axis-label-mouseover", e.LABEL_MOUSEMOVE = "axis-label-mousemove", e.LABEL_CLICK = "axis-label-click", e.LABEL_MOUSEOUT = "axis-label-mouseout", e.LABEL_FOCUS = "axis-label-focus", e.LABEL_BLUR = "axis-label-blur", e.RENDER_COMPLETE = "axis-render-complete", e))(Vp || {}), Gp = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Gp || {}), zp = /* @__PURE__ */ ((e) => (e.WORD_MOUSEOVER = "wordcloud-word-mouseover", e.WORD_MOUSEMOVE = "wordcloud-word-mousemove", e.WORD_CLICK = "wordcloud-word-click", e.WORD_MOUSEOUT = "wordcloud-word-mouseout", e))(zp || {}), Fp = /* @__PURE__ */ ((e) => (e.SLICE_MOUSEOVER = "pie-slice-mouseover", e.SLICE_MOUSEMOVE = "pie-slice-mousemove", e.SLICE_CLICK = "pie-slice-click", e.SLICE_MOUSEOUT = "pie-slice-mouseout", e))(Fp || {}), jp = /* @__PURE__ */ ((e) => (e.ARC_MOUSEOVER = "gauge-arc-mouseover", e.ARC_MOUSEMOVE = "gauge-arc-mousemove", e.ARC_CLICK = "gauge-arc-click", e.ARC_MOUSEOUT = "gauge-arc-mouseout", e))(jp || {}), Wp = /* @__PURE__ */ ((e) => (e.BAR_MOUSEOVER = "bar-mouseover", e.BAR_MOUSEMOVE = "bar-mousemove", e.BAR_CLICK = "bar-click", e.BAR_MOUSEOUT = "bar-mouseout", e))(Wp || {}), qp = /* @__PURE__ */ ((e) => (e.BOX_MOUSEOVER = "box-mouseover", e.BOX_MOUSEMOVE = "box-mousemove", e.BOX_CLICK = "box-click", e.BOX_MOUSEOUT = "box-mouseout", e.OUTLIER_MOUSEOVER = "outlier-mouseover", e.OUTLIER_MOUSEMOVE = "outlier-mousemove", e.OUTLIER_CLICK = "outlier-click", e.OUTLIER_MOUSEOUT = "outlier-mouseout", e))(qp || {}), Yp = /* @__PURE__ */ ((e) => (e.SCATTER_MOUSEOVER = "scatter-mouseover", e.SCATTER_MOUSEMOVE = "scatter-mousemove", e.SCATTER_CLICK = "scatter-click", e.SCATTER_MOUSEOUT = "scatter-mouseout", e))(Yp || {}), Xp = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Xp || {}), Zp = /* @__PURE__ */ ((e) => (e.X_AXIS_MOUSEOVER = "radar-x-axis-mouseover", e.X_AXIS_MOUSEMOVE = "radar-x-axis-mousemove", e.X_AXIS_CLICK = "radar-x-axis-click", e.X_AXIS_MOUSEOUT = "radar-x-axis-mouseout", e))(Zp || {}), Kp = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "tree-node-mouseover", e.NODE_CLICK = "tree-node-click", e.NODE_MOUSEOUT = "tree-node-mouseout", e))(Kp || {}), Qp = /* @__PURE__ */ ((e) => (e.LEAF_MOUSEOVER = "leaf-mouseover", e.LEAF_MOUSEMOVE = "leaf-mousemove", e.LEAF_CLICK = "leaf-click", e.LEAF_MOUSEOUT = "leaf-mouseout", e))(Qp || {}), Pi = /* @__PURE__ */ ((e) => (e.SHOW = "show-tooltip", e.MOVE = "move-tooltip", e.HIDE = "hide-tooltip", e))(Pi || {}), Jp = /* @__PURE__ */ ((e) => (e.SHOW = "show-threshold", e.HIDE = "hide-threshold", e))(Jp || {}), tf = /* @__PURE__ */ ((e) => (e.ITEM_HOVER = "legend-item-onhover", e.ITEM_CLICK = "legend-item-onclick", e.ITEM_MOUSEOUT = "legend-item-onmouseout", e.ITEMS_UPDATE = "legend-items-update", e))(tf || {}), ef = /* @__PURE__ */ ((e) => (e.CIRCLE_MOUSEOVER = "circle-leaf-mouseover", e.CIRCLE_CLICK = "circle-leaf-click", e.CIRCLE_MOUSEOUT = "circle-leaf-mouseout", e.CIRCLE_MOUSEMOVE = "circle-leaf-mousemove", e))(ef || {}), nf = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "alluvial-node-mouseover", e.NODE_CLICK = "alluvial-node-click", e.NODE_MOUSEOUT = "alluvial-node-mouseout", e.NODE_MOUSEMOVE = "alluvial-node-mousemove", e.LINE_MOUSEOVER = "alluvial-line-mouseover", e.LINE_CLICK = "alluvial-line-click", e.LINE_MOUSEOUT = "alluvial-line-mouseout", e.LINE_MOUSEMOVE = "alluvial-line-mousemove", e))(nf || {}), rf = /* @__PURE__ */ ((e) => (e.METER_MOUSEOVER = "meter-mouseover", e.METER_CLICK = "meter-click", e.METER_MOUSEOUT = "meter-mouseout", e.METER_MOUSEMOVE = "meter-mousemove", e))(rf || {}), sf = /* @__PURE__ */ ((e) => (e.HEATMAP_MOUSEOVER = "heatmap-mouseover", e.HEATMAP_CLICK = "heatmap-click", e.HEATMAP_MOUSEOUT = "heatmap-mouseout", e.HEATMAP_MOUSEMOVE = "hetmap-mousemove", e))(sf || {}), Rr = /* @__PURE__ */ ((e) => (e.CHOROPLETH_MOUSEOVER = "choropleth-mouseover", e.CHOROPLETH_CLICK = "choropleth-click", e.CHOROPLETH_MOUSEOUT = "choropleth-mouseout", e.CHOROPLETH_MOUSEMOVE = "choropleth-mousemove", e))(Rr || {});
const h1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alluvial: nf,
  Area: Gp,
  Axis: Vp,
  Bar: Wp,
  Boxplot: qp,
  CanvasZoom: Hp,
  Chart: Rp,
  Choropleth: Rr,
  CirclePack: ef,
  Gauge: jp,
  Heatmap: sf,
  Legend: tf,
  Line: Xp,
  Meter: rf,
  Modal: Ip,
  Model: Np,
  Pie: Fp,
  Radar: Zp,
  Scatter: Yp,
  Threshold: Jp,
  Toolbar: Pp,
  Tooltip: Pi,
  Tree: Kp,
  Treemap: Qp,
  WordCloud: zp,
  ZoomBar: Up,
  ZoomDomain: Bp
}, Symbol.toStringTag, { value: "Module" })), T = h1;
var rt = /* @__PURE__ */ ((e) => (e.HTML = "html", e.SVG = "svg", e))(rt || {}), af = /* @__PURE__ */ ((e) => (e.WHITE = "white", e.G100 = "g100", e.G90 = "g90", e.G10 = "g10", e))(af || {}), it = /* @__PURE__ */ ((e) => (e.BACKGROUND = "background", e.FILL = "fill", e.STROKE = "stroke", e.TOOLTIP = "tooltip", e))(it || {}), G = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom", e))(G || {}), Ke = /* @__PURE__ */ ((e) => (e.GRAPH_VIEW = "graph_view", e.SLIDER_VIEW = "slider_view", e))(Ke || {}), Ve = /* @__PURE__ */ ((e) => (e.END_LINE = "end_line", e.MID_LINE = "mid_line", e.FRONT_LINE = "front_line", e.NONE = "none", e))(Ve || {}), Ft = /* @__PURE__ */ ((e) => (e.VERTICAL = "vertical", e.HORIZONTAL = "horizontal", e))(Ft || {}), et = /* @__PURE__ */ ((e) => (e.TIME = "time", e.LINEAR = "linear", e.LOG = "log", e.LABELS = "labels", e.LABELS_RATIO = "labels-ratio", e))(et || {}), Ui = /* @__PURE__ */ ((e) => (e.RIGHT = "right", e.LEFT = "left", e.TOP = "top", e.BOTTOM = "bottom", e))(Ui || {}), jt = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.CENTER = "center", e.RIGHT = "right", e))(jt || {}), qi = /* @__PURE__ */ ((e) => (e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e))(qi || {}), dc = /* @__PURE__ */ ((e) => (e.TREE = "tree", e.DENDROGRAM = "dendrogram", e))(dc || {}), At = /* @__PURE__ */ ((e) => (e.ROW = "row", e.COLUMN = "column", e.ROW_REVERSE = "row-reverse", e.COLUMN_REVERSE = "column-reverse", e))(At || {}), ct = /* @__PURE__ */ ((e) => (e.FIXED = "fixed", e.PREFERRED = "preferred", e.STRETCH = "stretch", e))(ct || {}), ii = /* @__PURE__ */ ((e) => (e.CENTER = "center", e))(ii || {}), Fs = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(Fs || {}), zt = /* @__PURE__ */ ((e) => (e.GRID = "grid", e.VERT_OR_HORIZ = "vertOrHoriz", e.PIE = "pie", e.DONUT = "donut", e))(zt || {}), dn = /* @__PURE__ */ ((e) => (e.START = "start", e.MIDDLE = "middle", e.END = "end", e))(dn || {}), pn = /* @__PURE__ */ ((e) => (e.BASELINE = "baseline", e.MIDDLE = "middle", e.HANGING = "hanging", e))(pn || {}), Ir = /* @__PURE__ */ ((e) => (e.SEMI = "semi", e.FULL = "full", e))(Ir || {}), dl = /* @__PURE__ */ ((e) => (e.UP = "up", e.DOWN = "down", e))(dl || {}), js = /* @__PURE__ */ ((e) => (e.SUCCESS = "success", e.WARNING = "warning", e.DANGER = "danger", e))(js || {}), Ws = /* @__PURE__ */ ((e) => (e.ALWAYS = "always", e.AUTO = "auto", e.NEVER = "never", e))(Ws || {}), we = /* @__PURE__ */ ((e) => (e.SCATTER = "scatter", e.LINE = "line", e.SIMPLE_BAR = "simple-bar", e.STACKED_BAR = "stacked-bar", e.GROUPED_BAR = "grouped-bar", e.AREA = "area", e.STACKED_AREA = "stacked-area", e))(we || {}), _t = /* @__PURE__ */ ((e) => (e.EXPORT_CSV = "Export as CSV", e.EXPORT_PNG = "Export as PNG", e.EXPORT_JPG = "Export as JPG", e.ZOOM_IN = "Zoom in", e.ZOOM_OUT = "Zoom out", e.RESET_ZOOM = "Reset zoom", e.MAKE_FULLSCREEN = "Make fullscreen", e.EXIT_FULLSCREEN = "Exit fullscreen", e.SHOW_AS_DATATABLE = "Show as data-table", e.CUSTOM = "Custom", e))(_t || {}), pl = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(pl || {}), Gt = /* @__PURE__ */ ((e) => (e.CHECKBOX = "checkbox", e.RADIUS = "radius", e.AREA = "area", e.SIZE = "size", e.LINE = "line", e.QUARTILE = "quartile", e.ZOOM = "zoom", e))(Gt || {}), qs = /* @__PURE__ */ ((e) => (e.LINEAR = "linear", e.QUANTIZE = "quantize", e))(qs || {}), Bi = /* @__PURE__ */ ((e) => (e.ON = "on", e.AUTO = "auto", e.OFF = "off", e))(Bi || {}), Ga = /* @__PURE__ */ ((e) => (e.DEFAULT = "default", e.HOVERABLE = "hoverable", e))(Ga || {}), gn = /* @__PURE__ */ ((e) => (e.geoEqualEarth = "geoEqualEarth", e.geoAlbers = "geoAlbers", e.geoConicEqualArea = "geoConicEqualArea", e.geoConicEquidistant = "geoConicEquidistant", e.geoEquirectangular = "geoEquirectangular", e.geoMercator = "geoMercator", e.geoNaturalEarth1 = "geoNaturalEarth1", e))(gn || {}), of = /* @__PURE__ */ ((e) => (e["15seconds"] = "15seconds", e.minute = "minute", e["30minutes"] = "30minutes", e.hourly = "hourly", e.daily = "daily", e.weekly = "weekly", e.monthly = "monthly", e.quarterly = "quarterly", e.yearly = "yearly", e))(of || {});
function So(e) {
  return (t = {}) => {
    const n = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[n] || e.formats[e.defaultWidth];
  };
}
function di(e) {
  return (t, n) => {
    const r = n?.context ? String(n.context) : "standalone";
    let i;
    if (r === "formatting" && e.formattingValues) {
      const a = e.defaultFormattingWidth || e.defaultWidth, o = n?.width ? String(n.width) : a;
      i = e.formattingValues[o] || e.formattingValues[a];
    } else {
      const a = e.defaultWidth, o = n?.width ? String(n.width) : e.defaultWidth;
      i = e.values[o] || e.values[a];
    }
    const s = e.argumentCallback ? e.argumentCallback(t) : t;
    return i[s];
  };
}
function pi(e) {
  return (t, n = {}) => {
    const r = n.width, i = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = t.match(i);
    if (!s)
      return null;
    const a = s[0], o = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(o) ? p1(o, (d) => d.test(a)) : (
      // [TODO] -- I challenge you to fix the type
      d1(o, (d) => d.test(a))
    );
    let c;
    c = e.valueCallback ? e.valueCallback(l) : l, c = n.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      n.valueCallback(c)
    ) : c;
    const u = t.slice(a.length);
    return { value: c, rest: u };
  };
}
function d1(e, t) {
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))
      return n;
}
function p1(e, t) {
  for (let n = 0; n < e.length; n++)
    if (t(e[n]))
      return n;
}
function f1(e) {
  return (t, n = {}) => {
    const r = t.match(e.matchPattern);
    if (!r) return null;
    const i = r[0], s = t.match(e.parsePattern);
    if (!s) return null;
    let a = e.valueCallback ? e.valueCallback(s[0]) : s[0];
    a = n.valueCallback ? n.valueCallback(a) : a;
    const o = t.slice(i.length);
    return { value: a, rest: o };
  };
}
const lf = 6048e5, m1 = 864e5, cf = 6e4, uf = 36e5, ku = Symbol.for("constructDateFrom");
function Le(e, t) {
  return typeof e == "function" ? e(t) : e && typeof e == "object" && ku in e ? e[ku](t) : e instanceof Date ? new e.constructor(t) : new Date(t);
}
function ur(e, ...t) {
  const n = Le.bind(
    null,
    t.find((r) => typeof r == "object")
  );
  return t.map(n);
}
let g1 = {};
function za() {
  return g1;
}
function Ht(e, t) {
  return Le(t || e, e);
}
function Yi(e, t) {
  const n = za(), r = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? n.weekStartsOn ?? n.locale?.options?.weekStartsOn ?? 0, i = Ht(e, t?.in), s = i.getDay(), a = (s < r ? 7 : 0) + s - r;
  return i.setDate(i.getDate() - a), i.setHours(0, 0, 0, 0), i;
}
const v1 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, y1 = (e, t, n) => {
  let r;
  const i = v1[e];
  return typeof i == "string" ? r = i : t === 1 ? r = i.one : r = i.other.replace("{{count}}", t.toString()), n?.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r;
}, x1 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, b1 = (e, t, n, r) => x1[e], _1 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, E1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, O1 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, S1 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, T1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, w1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, $1 = (e, t) => {
  const n = Number(e), r = n % 100;
  if (r > 20 || r < 10)
    switch (r % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, M1 = {
  ordinalNumber: $1,
  era: di({
    values: _1,
    defaultWidth: "wide"
  }),
  quarter: di({
    values: E1,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: di({
    values: O1,
    defaultWidth: "wide"
  }),
  day: di({
    values: S1,
    defaultWidth: "wide"
  }),
  dayPeriod: di({
    values: T1,
    defaultWidth: "wide",
    formattingValues: w1,
    defaultFormattingWidth: "wide"
  })
}, C1 = /^(\d+)(th|st|nd|rd)?/i, A1 = /\d+/i, L1 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, D1 = {
  any: [/^b/i, /^(a|c)/i]
}, k1 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, R1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, I1 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, N1 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, P1 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, U1 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, B1 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, H1 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, V1 = {
  ordinalNumber: f1({
    matchPattern: C1,
    parsePattern: A1,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: pi({
    matchPatterns: L1,
    defaultMatchWidth: "wide",
    parsePatterns: D1,
    defaultParseWidth: "any"
  }),
  quarter: pi({
    matchPatterns: k1,
    defaultMatchWidth: "wide",
    parsePatterns: R1,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: pi({
    matchPatterns: I1,
    defaultMatchWidth: "wide",
    parsePatterns: N1,
    defaultParseWidth: "any"
  }),
  day: pi({
    matchPatterns: P1,
    defaultMatchWidth: "wide",
    parsePatterns: U1,
    defaultParseWidth: "any"
  }),
  dayPeriod: pi({
    matchPatterns: B1,
    defaultMatchWidth: "any",
    parsePatterns: H1,
    defaultParseWidth: "any"
  })
}, G1 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, z1 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, F1 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, j1 = {
  date: So({
    formats: G1,
    defaultWidth: "full"
  }),
  time: So({
    formats: z1,
    defaultWidth: "full"
  }),
  dateTime: So({
    formats: F1,
    defaultWidth: "full"
  })
}, hf = {
  code: "en-US",
  formatDistance: y1,
  formatLong: j1,
  formatRelative: b1,
  localize: M1,
  match: V1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var df = typeof global == "object" && global && global.Object === Object && global, W1 = typeof self == "object" && self && self.Object === Object && self, We = df || W1 || Function("return this")(), De = We.Symbol, pf = Object.prototype, q1 = pf.hasOwnProperty, Y1 = pf.toString, fi = De ? De.toStringTag : void 0;
function X1(e) {
  var t = q1.call(e, fi), n = e[fi];
  try {
    e[fi] = void 0;
    var r = !0;
  } catch {
  }
  var i = Y1.call(e);
  return r && (t ? e[fi] = n : delete e[fi]), i;
}
var Z1 = Object.prototype, K1 = Z1.toString;
function Q1(e) {
  return K1.call(e);
}
var J1 = "[object Null]", t0 = "[object Undefined]", Ru = De ? De.toStringTag : void 0;
function hr(e) {
  return e == null ? e === void 0 ? t0 : J1 : Ru && Ru in Object(e) ? X1(e) : Q1(e);
}
function rn(e) {
  return e != null && typeof e == "object";
}
var e0 = "[object Symbol]";
function Fa(e) {
  return typeof e == "symbol" || rn(e) && hr(e) == e0;
}
function pc(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var Kt = Array.isArray, Iu = De ? De.prototype : void 0, Nu = Iu ? Iu.toString : void 0;
function ff(e) {
  if (typeof e == "string")
    return e;
  if (Kt(e))
    return pc(e, ff) + "";
  if (Fa(e))
    return Nu ? Nu.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function ke(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function fc(e) {
  return e;
}
var n0 = "[object AsyncFunction]", r0 = "[object Function]", i0 = "[object GeneratorFunction]", s0 = "[object Proxy]";
function mc(e) {
  if (!ke(e))
    return !1;
  var t = hr(e);
  return t == r0 || t == i0 || t == n0 || t == s0;
}
var To = We["__core-js_shared__"], Pu = function() {
  var e = /[^.]+$/.exec(To && To.keys && To.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function a0(e) {
  return !!Pu && Pu in e;
}
var o0 = Function.prototype, l0 = o0.toString;
function dr(e) {
  if (e != null) {
    try {
      return l0.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var c0 = /[\\^$.*+?()[\]{}|]/g, u0 = /^\[object .+?Constructor\]$/, h0 = Function.prototype, d0 = Object.prototype, p0 = h0.toString, f0 = d0.hasOwnProperty, m0 = RegExp(
  "^" + p0.call(f0).replace(c0, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function g0(e) {
  if (!ke(e) || a0(e))
    return !1;
  var t = mc(e) ? m0 : u0;
  return t.test(dr(e));
}
function v0(e, t) {
  return e?.[t];
}
function pr(e, t) {
  var n = v0(e, t);
  return g0(n) ? n : void 0;
}
var fl = pr(We, "WeakMap"), Uu = Object.create, y0 = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!ke(t))
      return {};
    if (Uu)
      return Uu(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function x0(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function b0() {
}
function mf(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var _0 = 800, E0 = 16, O0 = Date.now;
function S0(e) {
  var t = 0, n = 0;
  return function() {
    var r = O0(), i = E0 - (r - n);
    if (n = r, i > 0) {
      if (++t >= _0)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function T0(e) {
  return function() {
    return e;
  };
}
var aa = function() {
  try {
    var e = pr(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), w0 = aa ? function(e, t) {
  return aa(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: T0(t),
    writable: !0
  });
} : fc, gf = S0(w0);
function $0(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function M0(e, t, n, r) {
  for (var i = e.length, s = n + -1; ++s < i; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function C0(e) {
  return e !== e;
}
function A0(e, t, n) {
  for (var r = n - 1, i = e.length; ++r < i; )
    if (e[r] === t)
      return r;
  return -1;
}
function L0(e, t, n) {
  return t === t ? A0(e, t, n) : M0(e, C0, n);
}
function D0(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && L0(e, t, 0) > -1;
}
var k0 = 9007199254740991, R0 = /^(?:0|[1-9]\d*)$/;
function gc(e, t) {
  var n = typeof e;
  return t = t ?? k0, !!t && (n == "number" || n != "symbol" && R0.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function ja(e, t, n) {
  t == "__proto__" && aa ? aa(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function cs(e, t) {
  return e === t || e !== e && t !== t;
}
var I0 = Object.prototype, N0 = I0.hasOwnProperty;
function vf(e, t, n) {
  var r = e[t];
  (!(N0.call(e, t) && cs(r, n)) || n === void 0 && !(t in e)) && ja(e, t, n);
}
function si(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, a = t.length; ++s < a; ) {
    var o = t[s], l = void 0;
    l === void 0 && (l = e[o]), i ? ja(n, o, l) : vf(n, o, l);
  }
  return n;
}
var Bu = Math.max;
function yf(e, t, n) {
  return t = Bu(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, s = Bu(r.length - t, 0), a = Array(s); ++i < s; )
      a[i] = r[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = r[i];
    return o[t] = n(a), x0(e, this, o);
  };
}
function vc(e, t) {
  return gf(yf(e, t, fc), e + "");
}
var P0 = 9007199254740991;
function yc(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= P0;
}
function fr(e) {
  return e != null && yc(e.length) && !mc(e);
}
function U0(e, t, n) {
  if (!ke(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? fr(n) && gc(t, n.length) : r == "string" && t in n) ? cs(n[t], e) : !1;
}
function B0(e) {
  return vc(function(t, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && U0(n[0], n[1], a) && (s = i < 3 ? void 0 : s, i = 1), t = Object(t); ++r < i; ) {
      var o = n[r];
      o && e(t, o, r, s);
    }
    return t;
  });
}
var H0 = Object.prototype;
function Wa(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || H0;
  return e === n;
}
function V0(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var G0 = "[object Arguments]";
function Hu(e) {
  return rn(e) && hr(e) == G0;
}
var xf = Object.prototype, z0 = xf.hasOwnProperty, F0 = xf.propertyIsEnumerable, Wr = Hu(/* @__PURE__ */ function() {
  return arguments;
}()) ? Hu : function(e) {
  return rn(e) && z0.call(e, "callee") && !F0.call(e, "callee");
};
function j0() {
  return !1;
}
var bf = typeof exports == "object" && exports && !exports.nodeType && exports, Vu = bf && typeof module == "object" && module && !module.nodeType && module, W0 = Vu && Vu.exports === bf, Gu = W0 ? We.Buffer : void 0, q0 = Gu ? Gu.isBuffer : void 0, qr = q0 || j0, Y0 = "[object Arguments]", X0 = "[object Array]", Z0 = "[object Boolean]", K0 = "[object Date]", Q0 = "[object Error]", J0 = "[object Function]", ty = "[object Map]", ey = "[object Number]", ny = "[object Object]", ry = "[object RegExp]", iy = "[object Set]", sy = "[object String]", ay = "[object WeakMap]", oy = "[object ArrayBuffer]", ly = "[object DataView]", cy = "[object Float32Array]", uy = "[object Float64Array]", hy = "[object Int8Array]", dy = "[object Int16Array]", py = "[object Int32Array]", fy = "[object Uint8Array]", my = "[object Uint8ClampedArray]", gy = "[object Uint16Array]", vy = "[object Uint32Array]", Lt = {};
Lt[cy] = Lt[uy] = Lt[hy] = Lt[dy] = Lt[py] = Lt[fy] = Lt[my] = Lt[gy] = Lt[vy] = !0;
Lt[Y0] = Lt[X0] = Lt[oy] = Lt[Z0] = Lt[ly] = Lt[K0] = Lt[Q0] = Lt[J0] = Lt[ty] = Lt[ey] = Lt[ny] = Lt[ry] = Lt[iy] = Lt[sy] = Lt[ay] = !1;
function yy(e) {
  return rn(e) && yc(e.length) && !!Lt[hr(e)];
}
function xc(e) {
  return function(t) {
    return e(t);
  };
}
var _f = typeof exports == "object" && exports && !exports.nodeType && exports, Hi = _f && typeof module == "object" && module && !module.nodeType && module, xy = Hi && Hi.exports === _f, wo = xy && df.process, Yr = function() {
  try {
    var e = Hi && Hi.require && Hi.require("util").types;
    return e || wo && wo.binding && wo.binding("util");
  } catch {
  }
}(), zu = Yr && Yr.isTypedArray, qa = zu ? xc(zu) : yy, by = Object.prototype, _y = by.hasOwnProperty;
function Ef(e, t) {
  var n = Kt(e), r = !n && Wr(e), i = !n && !r && qr(e), s = !n && !r && !i && qa(e), a = n || r || i || s, o = a ? V0(e.length, String) : [], l = o.length;
  for (var c in e)
    (t || _y.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    gc(c, l))) && o.push(c);
  return o;
}
function Of(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var Ey = Of(Object.keys, Object), Oy = Object.prototype, Sy = Oy.hasOwnProperty;
function Sf(e) {
  if (!Wa(e))
    return Ey(e);
  var t = [];
  for (var n in Object(e))
    Sy.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function us(e) {
  return fr(e) ? Ef(e) : Sf(e);
}
function Ty(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var wy = Object.prototype, $y = wy.hasOwnProperty;
function My(e) {
  if (!ke(e))
    return Ty(e);
  var t = Wa(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !$y.call(e, r)) || n.push(r);
  return n;
}
function hs(e) {
  return fr(e) ? Ef(e, !0) : My(e);
}
var Cy = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ay = /^\w*$/;
function bc(e, t) {
  if (Kt(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Fa(e) ? !0 : Ay.test(e) || !Cy.test(e) || t != null && e in Object(t);
}
var Xi = pr(Object, "create");
function Ly() {
  this.__data__ = Xi ? Xi(null) : {}, this.size = 0;
}
function Dy(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var ky = "__lodash_hash_undefined__", Ry = Object.prototype, Iy = Ry.hasOwnProperty;
function Ny(e) {
  var t = this.__data__;
  if (Xi) {
    var n = t[e];
    return n === ky ? void 0 : n;
  }
  return Iy.call(t, e) ? t[e] : void 0;
}
var Py = Object.prototype, Uy = Py.hasOwnProperty;
function By(e) {
  var t = this.__data__;
  return Xi ? t[e] !== void 0 : Uy.call(t, e);
}
var Hy = "__lodash_hash_undefined__";
function Vy(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Xi && t === void 0 ? Hy : t, this;
}
function er(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
er.prototype.clear = Ly;
er.prototype.delete = Dy;
er.prototype.get = Ny;
er.prototype.has = By;
er.prototype.set = Vy;
function Gy() {
  this.__data__ = [], this.size = 0;
}
function Ya(e, t) {
  for (var n = e.length; n--; )
    if (cs(e[n][0], t))
      return n;
  return -1;
}
var zy = Array.prototype, Fy = zy.splice;
function jy(e) {
  var t = this.__data__, n = Ya(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : Fy.call(t, n, 1), --this.size, !0;
}
function Wy(e) {
  var t = this.__data__, n = Ya(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function qy(e) {
  return Ya(this.__data__, e) > -1;
}
function Yy(e, t) {
  var n = this.__data__, r = Ya(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Ln(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Ln.prototype.clear = Gy;
Ln.prototype.delete = jy;
Ln.prototype.get = Wy;
Ln.prototype.has = qy;
Ln.prototype.set = Yy;
var Zi = pr(We, "Map");
function Xy() {
  this.size = 0, this.__data__ = {
    hash: new er(),
    map: new (Zi || Ln)(),
    string: new er()
  };
}
function Zy(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Xa(e, t) {
  var n = e.__data__;
  return Zy(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function Ky(e) {
  var t = Xa(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function Qy(e) {
  return Xa(this, e).get(e);
}
function Jy(e) {
  return Xa(this, e).has(e);
}
function tx(e, t) {
  var n = Xa(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function Dn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Dn.prototype.clear = Xy;
Dn.prototype.delete = Ky;
Dn.prototype.get = Qy;
Dn.prototype.has = Jy;
Dn.prototype.set = tx;
var ex = "Expected a function";
function _c(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(ex);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var a = e.apply(this, r);
    return n.cache = s.set(i, a) || s, a;
  };
  return n.cache = new (_c.Cache || Dn)(), n;
}
_c.Cache = Dn;
var nx = 500;
function rx(e) {
  var t = _c(e, function(r) {
    return n.size === nx && n.clear(), r;
  }), n = t.cache;
  return t;
}
var ix = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, sx = /\\(\\)?/g, ax = rx(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(ix, function(n, r, i, s) {
    t.push(i ? s.replace(sx, "$1") : r || n);
  }), t;
});
function ds(e) {
  return e == null ? "" : ff(e);
}
function Za(e, t) {
  return Kt(e) ? e : bc(e, t) ? [e] : ax(ds(e));
}
function ps(e) {
  if (typeof e == "string" || Fa(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function Ec(e, t) {
  t = Za(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[ps(t[n++])];
  return n && n == r ? e : void 0;
}
function gt(e, t, n) {
  var r = e == null ? void 0 : Ec(e, t);
  return r === void 0 ? n : r;
}
function Oc(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var Fu = De ? De.isConcatSpreadable : void 0;
function ox(e) {
  return Kt(e) || Wr(e) || !!(Fu && e && e[Fu]);
}
function Ka(e, t, n, r, i) {
  var s = -1, a = e.length;
  for (n || (n = ox), i || (i = []); ++s < a; ) {
    var o = e[s];
    t > 0 && n(o) ? t > 1 ? Ka(o, t - 1, n, r, i) : Oc(i, o) : r || (i[i.length] = o);
  }
  return i;
}
var Sc = Of(Object.getPrototypeOf, Object), lx = "[object Object]", cx = Function.prototype, ux = Object.prototype, Tf = cx.toString, hx = ux.hasOwnProperty, dx = Tf.call(Object);
function wf(e) {
  if (!rn(e) || hr(e) != lx)
    return !1;
  var t = Sc(e);
  if (t === null)
    return !0;
  var n = hx.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && Tf.call(n) == dx;
}
function px() {
  this.__data__ = new Ln(), this.size = 0;
}
function fx(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function mx(e) {
  return this.__data__.get(e);
}
function gx(e) {
  return this.__data__.has(e);
}
var vx = 200;
function yx(e, t) {
  var n = this.__data__;
  if (n instanceof Ln) {
    var r = n.__data__;
    if (!Zi || r.length < vx - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Dn(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Ge(e) {
  var t = this.__data__ = new Ln(e);
  this.size = t.size;
}
Ge.prototype.clear = px;
Ge.prototype.delete = fx;
Ge.prototype.get = mx;
Ge.prototype.has = gx;
Ge.prototype.set = yx;
function xx(e, t) {
  return e && si(t, us(t), e);
}
function bx(e, t) {
  return e && si(t, hs(t), e);
}
var $f = typeof exports == "object" && exports && !exports.nodeType && exports, ju = $f && typeof module == "object" && module && !module.nodeType && module, _x = ju && ju.exports === $f, Wu = _x ? We.Buffer : void 0, qu = Wu ? Wu.allocUnsafe : void 0;
function Mf(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = qu ? qu(n) : new e.constructor(n);
  return e.copy(r), r;
}
function Ex(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var a = e[n];
    t(a, n, e) && (s[i++] = a);
  }
  return s;
}
function Cf() {
  return [];
}
var Ox = Object.prototype, Sx = Ox.propertyIsEnumerable, Yu = Object.getOwnPropertySymbols, Tc = Yu ? function(e) {
  return e == null ? [] : (e = Object(e), Ex(Yu(e), function(t) {
    return Sx.call(e, t);
  }));
} : Cf;
function Tx(e, t) {
  return si(e, Tc(e), t);
}
var wx = Object.getOwnPropertySymbols, Af = wx ? function(e) {
  for (var t = []; e; )
    Oc(t, Tc(e)), e = Sc(e);
  return t;
} : Cf;
function $x(e, t) {
  return si(e, Af(e), t);
}
function Lf(e, t, n) {
  var r = t(e);
  return Kt(e) ? r : Oc(r, n(e));
}
function ml(e) {
  return Lf(e, us, Tc);
}
function Df(e) {
  return Lf(e, hs, Af);
}
var gl = pr(We, "DataView"), vl = pr(We, "Promise"), Gr = pr(We, "Set"), Xu = "[object Map]", Mx = "[object Object]", Zu = "[object Promise]", Ku = "[object Set]", Qu = "[object WeakMap]", Ju = "[object DataView]", Cx = dr(gl), Ax = dr(Zi), Lx = dr(vl), Dx = dr(Gr), kx = dr(fl), $e = hr;
(gl && $e(new gl(new ArrayBuffer(1))) != Ju || Zi && $e(new Zi()) != Xu || vl && $e(vl.resolve()) != Zu || Gr && $e(new Gr()) != Ku || fl && $e(new fl()) != Qu) && ($e = function(e) {
  var t = hr(e), n = t == Mx ? e.constructor : void 0, r = n ? dr(n) : "";
  if (r)
    switch (r) {
      case Cx:
        return Ju;
      case Ax:
        return Xu;
      case Lx:
        return Zu;
      case Dx:
        return Ku;
      case kx:
        return Qu;
    }
  return t;
});
var Rx = Object.prototype, Ix = Rx.hasOwnProperty;
function Nx(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && Ix.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var oa = We.Uint8Array;
function wc(e) {
  var t = new e.constructor(e.byteLength);
  return new oa(t).set(new oa(e)), t;
}
function Px(e, t) {
  var n = t ? wc(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var Ux = /\w*$/;
function Bx(e) {
  var t = new e.constructor(e.source, Ux.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var th = De ? De.prototype : void 0, eh = th ? th.valueOf : void 0;
function Hx(e) {
  return eh ? Object(eh.call(e)) : {};
}
function kf(e, t) {
  var n = t ? wc(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var Vx = "[object Boolean]", Gx = "[object Date]", zx = "[object Map]", Fx = "[object Number]", jx = "[object RegExp]", Wx = "[object Set]", qx = "[object String]", Yx = "[object Symbol]", Xx = "[object ArrayBuffer]", Zx = "[object DataView]", Kx = "[object Float32Array]", Qx = "[object Float64Array]", Jx = "[object Int8Array]", tb = "[object Int16Array]", eb = "[object Int32Array]", nb = "[object Uint8Array]", rb = "[object Uint8ClampedArray]", ib = "[object Uint16Array]", sb = "[object Uint32Array]";
function ab(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case Xx:
      return wc(e);
    case Vx:
    case Gx:
      return new r(+e);
    case Zx:
      return Px(e, n);
    case Kx:
    case Qx:
    case Jx:
    case tb:
    case eb:
    case nb:
    case rb:
    case ib:
    case sb:
      return kf(e, n);
    case zx:
      return new r();
    case Fx:
    case qx:
      return new r(e);
    case jx:
      return Bx(e);
    case Wx:
      return new r();
    case Yx:
      return Hx(e);
  }
}
function Rf(e) {
  return typeof e.constructor == "function" && !Wa(e) ? y0(Sc(e)) : {};
}
var ob = "[object Map]";
function lb(e) {
  return rn(e) && $e(e) == ob;
}
var nh = Yr && Yr.isMap, cb = nh ? xc(nh) : lb, ub = "[object Set]";
function hb(e) {
  return rn(e) && $e(e) == ub;
}
var rh = Yr && Yr.isSet, db = rh ? xc(rh) : hb, pb = 1, fb = 2, mb = 4, If = "[object Arguments]", gb = "[object Array]", vb = "[object Boolean]", yb = "[object Date]", xb = "[object Error]", Nf = "[object Function]", bb = "[object GeneratorFunction]", _b = "[object Map]", Eb = "[object Number]", Pf = "[object Object]", Ob = "[object RegExp]", Sb = "[object Set]", Tb = "[object String]", wb = "[object Symbol]", $b = "[object WeakMap]", Mb = "[object ArrayBuffer]", Cb = "[object DataView]", Ab = "[object Float32Array]", Lb = "[object Float64Array]", Db = "[object Int8Array]", kb = "[object Int16Array]", Rb = "[object Int32Array]", Ib = "[object Uint8Array]", Nb = "[object Uint8ClampedArray]", Pb = "[object Uint16Array]", Ub = "[object Uint32Array]", $t = {};
$t[If] = $t[gb] = $t[Mb] = $t[Cb] = $t[vb] = $t[yb] = $t[Ab] = $t[Lb] = $t[Db] = $t[kb] = $t[Rb] = $t[_b] = $t[Eb] = $t[Pf] = $t[Ob] = $t[Sb] = $t[Tb] = $t[wb] = $t[Ib] = $t[Nb] = $t[Pb] = $t[Ub] = !0;
$t[xb] = $t[Nf] = $t[$b] = !1;
function Vi(e, t, n, r, i, s) {
  var a, o = t & pb, l = t & fb, c = t & mb;
  if (n && (a = i ? n(e, r, i, s) : n(e)), a !== void 0)
    return a;
  if (!ke(e))
    return e;
  var u = Kt(e);
  if (u) {
    if (a = Nx(e), !o)
      return mf(e, a);
  } else {
    var d = $e(e), h = d == Nf || d == bb;
    if (qr(e))
      return Mf(e, o);
    if (d == Pf || d == If || h && !i) {
      if (a = l || h ? {} : Rf(e), !o)
        return l ? $x(e, bx(a, e)) : Tx(e, xx(a, e));
    } else {
      if (!$t[d])
        return i ? e : {};
      a = ab(e, d, o);
    }
  }
  s || (s = new Ge());
  var p = s.get(e);
  if (p)
    return p;
  s.set(e, a), db(e) ? e.forEach(function(m) {
    a.add(Vi(m, t, n, m, e, s));
  }) : cb(e) && e.forEach(function(m, v) {
    a.set(v, Vi(m, t, n, v, e, s));
  });
  var f = c ? l ? Df : ml : l ? hs : us, g = u ? void 0 : f(e);
  return $0(g || e, function(m, v) {
    g && (v = m, m = e[v]), vf(a, v, Vi(m, t, n, v, e, s));
  }), a;
}
var Bb = 1, Hb = 4;
function Sn(e) {
  return Vi(e, Bb | Hb);
}
var Vb = "__lodash_hash_undefined__";
function Gb(e) {
  return this.__data__.set(e, Vb), this;
}
function zb(e) {
  return this.__data__.has(e);
}
function Ki(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Dn(); ++t < n; )
    this.add(e[t]);
}
Ki.prototype.add = Ki.prototype.push = Gb;
Ki.prototype.has = zb;
function Uf(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function Bf(e, t) {
  return e.has(t);
}
var Fb = 1, jb = 2;
function Hf(e, t, n, r, i, s) {
  var a = n & Fb, o = e.length, l = t.length;
  if (o != l && !(a && l > o))
    return !1;
  var c = s.get(e), u = s.get(t);
  if (c && u)
    return c == t && u == e;
  var d = -1, h = !0, p = n & jb ? new Ki() : void 0;
  for (s.set(e, t), s.set(t, e); ++d < o; ) {
    var f = e[d], g = t[d];
    if (r)
      var m = a ? r(g, f, d, t, e, s) : r(f, g, d, e, t, s);
    if (m !== void 0) {
      if (m)
        continue;
      h = !1;
      break;
    }
    if (p) {
      if (!Uf(t, function(v, b) {
        if (!Bf(p, b) && (f === v || i(f, v, n, r, s)))
          return p.push(b);
      })) {
        h = !1;
        break;
      }
    } else if (!(f === g || i(f, g, n, r, s))) {
      h = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), h;
}
function Wb(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
function $c(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var qb = 1, Yb = 2, Xb = "[object Boolean]", Zb = "[object Date]", Kb = "[object Error]", Qb = "[object Map]", Jb = "[object Number]", t_ = "[object RegExp]", e_ = "[object Set]", n_ = "[object String]", r_ = "[object Symbol]", i_ = "[object ArrayBuffer]", s_ = "[object DataView]", ih = De ? De.prototype : void 0, $o = ih ? ih.valueOf : void 0;
function a_(e, t, n, r, i, s, a) {
  switch (n) {
    case s_:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case i_:
      return !(e.byteLength != t.byteLength || !s(new oa(e), new oa(t)));
    case Xb:
    case Zb:
    case Jb:
      return cs(+e, +t);
    case Kb:
      return e.name == t.name && e.message == t.message;
    case t_:
    case n_:
      return e == t + "";
    case Qb:
      var o = Wb;
    case e_:
      var l = r & qb;
      if (o || (o = $c), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      r |= Yb, a.set(e, t);
      var u = Hf(o(e), o(t), r, i, s, a);
      return a.delete(e), u;
    case r_:
      if ($o)
        return $o.call(e) == $o.call(t);
  }
  return !1;
}
var o_ = 1, l_ = Object.prototype, c_ = l_.hasOwnProperty;
function u_(e, t, n, r, i, s) {
  var a = n & o_, o = ml(e), l = o.length, c = ml(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var d = l; d--; ) {
    var h = o[d];
    if (!(a ? h in t : c_.call(t, h)))
      return !1;
  }
  var p = s.get(e), f = s.get(t);
  if (p && f)
    return p == t && f == e;
  var g = !0;
  s.set(e, t), s.set(t, e);
  for (var m = a; ++d < l; ) {
    h = o[d];
    var v = e[h], b = t[h];
    if (r)
      var _ = a ? r(b, v, h, t, e, s) : r(v, b, h, e, t, s);
    if (!(_ === void 0 ? v === b || i(v, b, n, r, s) : _)) {
      g = !1;
      break;
    }
    m || (m = h == "constructor");
  }
  if (g && !m) {
    var E = e.constructor, x = t.constructor;
    E != x && "constructor" in e && "constructor" in t && !(typeof E == "function" && E instanceof E && typeof x == "function" && x instanceof x) && (g = !1);
  }
  return s.delete(e), s.delete(t), g;
}
var h_ = 1, sh = "[object Arguments]", ah = "[object Array]", ws = "[object Object]", d_ = Object.prototype, oh = d_.hasOwnProperty;
function p_(e, t, n, r, i, s) {
  var a = Kt(e), o = Kt(t), l = a ? ah : $e(e), c = o ? ah : $e(t);
  l = l == sh ? ws : l, c = c == sh ? ws : c;
  var u = l == ws, d = c == ws, h = l == c;
  if (h && qr(e)) {
    if (!qr(t))
      return !1;
    a = !0, u = !1;
  }
  if (h && !u)
    return s || (s = new Ge()), a || qa(e) ? Hf(e, t, n, r, i, s) : a_(e, t, l, n, r, i, s);
  if (!(n & h_)) {
    var p = u && oh.call(e, "__wrapped__"), f = d && oh.call(t, "__wrapped__");
    if (p || f) {
      var g = p ? e.value() : e, m = f ? t.value() : t;
      return s || (s = new Ge()), i(g, m, n, r, s);
    }
  }
  return h ? (s || (s = new Ge()), u_(e, t, n, r, i, s)) : !1;
}
function Qa(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !rn(e) && !rn(t) ? e !== e && t !== t : p_(e, t, n, r, Qa, i);
}
var f_ = 1, m_ = 2;
function g_(e, t, n, r) {
  var i = n.length, s = i;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var a = n[i];
    if (a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    a = n[i];
    var o = a[0], l = e[o], c = a[1];
    if (a[2]) {
      if (l === void 0 && !(o in e))
        return !1;
    } else {
      var u = new Ge(), d;
      if (!(d === void 0 ? Qa(c, l, f_ | m_, r, u) : d))
        return !1;
    }
  }
  return !0;
}
function Vf(e) {
  return e === e && !ke(e);
}
function v_(e) {
  for (var t = us(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, Vf(i)];
  }
  return t;
}
function Gf(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function y_(e) {
  var t = v_(e);
  return t.length == 1 && t[0][2] ? Gf(t[0][0], t[0][1]) : function(n) {
    return n === e || g_(n, e, t);
  };
}
function x_(e, t) {
  return e != null && t in Object(e);
}
function b_(e, t, n) {
  t = Za(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var a = ps(t[r]);
    if (!(s = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && yc(i) && gc(a, i) && (Kt(e) || Wr(e)));
}
function __(e, t) {
  return e != null && b_(e, t, x_);
}
var E_ = 1, O_ = 2;
function S_(e, t) {
  return bc(e) && Vf(t) ? Gf(ps(e), t) : function(n) {
    var r = gt(n, e);
    return r === void 0 && r === t ? __(n, e) : Qa(t, r, E_ | O_);
  };
}
function T_(e) {
  return function(t) {
    return t?.[e];
  };
}
function w_(e) {
  return function(t) {
    return Ec(t, e);
  };
}
function $_(e) {
  return bc(e) ? T_(ps(e)) : w_(e);
}
function Ja(e) {
  return typeof e == "function" ? e : e == null ? fc : typeof e == "object" ? Kt(e) ? S_(e[0], e[1]) : y_(e) : $_(e);
}
function M_(e) {
  return function(t, n, r) {
    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--; ) {
      var l = a[++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return t;
  };
}
var zf = M_();
function yl(e, t, n) {
  (n !== void 0 && !cs(e[t], n) || n === void 0 && !(t in e)) && ja(e, t, n);
}
function xl(e) {
  return rn(e) && fr(e);
}
function bl(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function C_(e) {
  return si(e, hs(e));
}
function A_(e, t, n, r, i, s, a) {
  var o = bl(e, n), l = bl(t, n), c = a.get(l);
  if (c) {
    yl(e, n, c);
    return;
  }
  var u = s ? s(o, l, n + "", e, t, a) : void 0, d = u === void 0;
  if (d) {
    var h = Kt(l), p = !h && qr(l), f = !h && !p && qa(l);
    u = l, h || p || f ? Kt(o) ? u = o : xl(o) ? u = mf(o) : p ? (d = !1, u = Mf(l, !0)) : f ? (d = !1, u = kf(l, !0)) : u = [] : wf(l) || Wr(l) ? (u = o, Wr(o) ? u = C_(o) : (!ke(o) || mc(o)) && (u = Rf(l))) : d = !1;
  }
  d && (a.set(l, u), i(u, l, r, s, a), a.delete(l)), yl(e, n, u);
}
function Ff(e, t, n, r, i) {
  e !== t && zf(t, function(s, a) {
    if (i || (i = new Ge()), ke(s))
      A_(e, t, a, n, Ff, r, i);
    else {
      var o = r ? r(bl(e, a), s, a + "", e, t, i) : void 0;
      o === void 0 && (o = s), yl(e, a, o);
    }
  }, hs);
}
function jf(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var L_ = "[object Map]", D_ = "[object Set]", k_ = Object.prototype, R_ = k_.hasOwnProperty;
function Be(e) {
  if (e == null)
    return !0;
  if (fr(e) && (Kt(e) || typeof e == "string" || typeof e.splice == "function" || qr(e) || qa(e) || Wr(e)))
    return !e.length;
  var t = $e(e);
  if (t == L_ || t == D_)
    return !e.size;
  if (Wa(e))
    return !Sf(e).length;
  for (var n in e)
    if (R_.call(e, n))
      return !1;
  return !0;
}
var at = B0(function(e, t, n) {
  Ff(e, t, n);
}), I_ = 1 / 0, N_ = Gr && 1 / $c(new Gr([, -0]))[1] == I_ ? function(e) {
  return new Gr(e);
} : b0, P_ = 200;
function Wf(e, t, n) {
  var r = -1, i = D0, s = e.length, a = !0, o = [], l = o;
  if (s >= P_) {
    var c = t ? null : N_(e);
    if (c)
      return $c(c);
    a = !1, i = Bf, l = new Ki();
  } else
    l = t ? [] : o;
  t:
    for (; ++r < s; ) {
      var u = e[r], d = t ? t(u) : u;
      if (u = u !== 0 ? u : 0, a && d === d) {
        for (var h = l.length; h--; )
          if (l[h] === d)
            continue t;
        t && l.push(d), o.push(u);
      } else i(l, d, n) || (l !== o && l.push(d), o.push(u));
    }
  return o;
}
var U_ = vc(function(e) {
  var t = jf(e);
  return xl(t) && (t = void 0), Wf(Ka(e, 1, xl, !0), Ja(t));
});
function Qi(e) {
  return e && e.length ? Wf(e) : [];
}
function Jn(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function B_(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Mc(e) {
  let t, n, r;
  e.length !== 2 ? (t = Jn, n = (o, l) => Jn(e(o), l), r = (o, l) => e(o) - l) : (t = e === Jn || e === B_ ? e : H_, n = e, r = e);
  function i(o, l, c = 0, u = o.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = c + u >>> 1;
        n(o[d], l) < 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function s(o, l, c = 0, u = o.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = c + u >>> 1;
        n(o[d], l) <= 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function a(o, l, c = 0, u = o.length) {
    const d = i(o, l, c, u - 1);
    return d > c && r(o[d - 1], l) > -r(o[d], l) ? d - 1 : d;
  }
  return { left: i, center: a, right: s };
}
function H_() {
  return 0;
}
function V_(e) {
  return e === null ? NaN : +e;
}
function* G_(e, t) {
  for (let n of e)
    n != null && (n = +n) >= n && (yield n);
}
const z_ = Mc(Jn), Cc = z_.right;
Mc(V_).center;
function ze(e, t) {
  let n, r;
  if (t === void 0)
    for (const i of e)
      i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));
  else {
    let i = -1;
    for (let s of e)
      (s = t(s, ++i, e)) != null && (n === void 0 ? s >= s && (n = r = s) : (n > s && (n = s), r < s && (r = s)));
  }
  return [n, r];
}
let lh = class extends Map {
  constructor(t, n = W_) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [r, i] of t) this.set(r, i);
  }
  get(t) {
    return super.get(ch(this, t));
  }
  has(t) {
    return super.has(ch(this, t));
  }
  set(t, n) {
    return super.set(F_(this, t), n);
  }
  delete(t) {
    return super.delete(j_(this, t));
  }
};
function ch({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function F_({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function j_({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function W_(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const q_ = Math.sqrt(50), Y_ = Math.sqrt(10), X_ = Math.sqrt(2);
function la(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), s = r / Math.pow(10, i), a = s >= q_ ? 10 : s >= Y_ ? 5 : s >= X_ ? 2 : 1;
  let o, l, c;
  return i < 0 ? (c = Math.pow(10, -i) / a, o = Math.round(e * c), l = Math.round(t * c), o / c < e && ++o, l / c > t && --l, c = -c) : (c = Math.pow(10, i) * a, o = Math.round(e / c), l = Math.round(t / c), o * c < e && ++o, l * c > t && --l), l < o && 0.5 <= n && n < 2 ? la(e, t, n * 2) : [o, l, c];
}
function ca(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const r = t < e, [i, s, a] = r ? la(t, e, n) : la(e, t, n);
  if (!(s >= i)) return [];
  const o = s - i + 1, l = new Array(o);
  if (r)
    if (a < 0) for (let c = 0; c < o; ++c) l[c] = (s - c) / -a;
    else for (let c = 0; c < o; ++c) l[c] = (s - c) * a;
  else if (a < 0) for (let c = 0; c < o; ++c) l[c] = (i + c) / -a;
  else for (let c = 0; c < o; ++c) l[c] = (i + c) * a;
  return l;
}
function Xr(e, t, n) {
  return t = +t, e = +e, n = +n, la(e, t, n)[2];
}
function _l(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? Xr(t, e, n) : Xr(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function nr(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Bn(e, t) {
  let n;
  for (const r of e)
    r != null && (n > r || n === void 0 && r >= r) && (n = r);
  return n;
}
var Z_ = { value: () => {
} };
function Ac() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Ys(n);
}
function Ys(e) {
  this._ = e;
}
function K_(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Ys.prototype = Ac.prototype = {
  constructor: Ys,
  on: function(e, t) {
    var n = this._, r = K_(e + "", n), i, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; ) if ((i = (e = r[s]).type) && (i = Q_(n[i], e.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (i = (e = r[s]).type) n[i] = uh(n[i], e.name, t);
      else if (t == null) for (i in n) n[i] = uh(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new Ys(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, s; r < i; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r) s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i) r[i].value.apply(t, n);
  }
};
function Q_(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function uh(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = Z_, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var El = "http://www.w3.org/1999/xhtml";
const hh = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: El,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function to(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), hh.hasOwnProperty(t) ? { space: hh[t], local: e } : e;
}
function J_(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === El && t.documentElement.namespaceURI === El ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function tE(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function qf(e) {
  var t = to(e);
  return (t.local ? tE : J_)(t);
}
function eE() {
}
function Lc(e) {
  return e == null ? eE : function() {
    return this.querySelector(e);
  };
}
function nE(e) {
  typeof e != "function" && (e = Lc(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = new Array(a), l, c, u = 0; u < a; ++u)
      (l = s[u]) && (c = e.call(l, l.__data__, u, s)) && ("__data__" in l && (c.__data__ = l.__data__), o[u] = c);
  return new _e(r, this._parents);
}
function rE(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function iE() {
  return [];
}
function Yf(e) {
  return e == null ? iE : function() {
    return this.querySelectorAll(e);
  };
}
function sE(e) {
  return function() {
    return rE(e.apply(this, arguments));
  };
}
function aE(e) {
  typeof e == "function" ? e = sE(e) : e = Yf(e);
  for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)
    for (var a = t[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && (r.push(e.call(l, l.__data__, c, a)), i.push(l));
  return new _e(r, i);
}
function Xf(e) {
  return function() {
    return this.matches(e);
  };
}
function Zf(e) {
  return function(t) {
    return t.matches(e);
  };
}
var oE = Array.prototype.find;
function lE(e) {
  return function() {
    return oE.call(this.children, e);
  };
}
function cE() {
  return this.firstElementChild;
}
function uE(e) {
  return this.select(e == null ? cE : lE(typeof e == "function" ? e : Zf(e)));
}
var hE = Array.prototype.filter;
function dE() {
  return Array.from(this.children);
}
function pE(e) {
  return function() {
    return hE.call(this.children, e);
  };
}
function fE(e) {
  return this.selectAll(e == null ? dE : pE(typeof e == "function" ? e : Zf(e)));
}
function mE(e) {
  typeof e != "function" && (e = Xf(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);
  return new _e(r, this._parents);
}
function Kf(e) {
  return new Array(e.length);
}
function gE() {
  return new _e(this._enter || this._groups.map(Kf), this._parents);
}
function ua(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
ua.prototype = {
  constructor: ua,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function vE(e) {
  return function() {
    return e;
  };
}
function yE(e, t, n, r, i, s) {
  for (var a = 0, o, l = t.length, c = s.length; a < c; ++a)
    (o = t[a]) ? (o.__data__ = s[a], r[a] = o) : n[a] = new ua(e, s[a]);
  for (; a < l; ++a)
    (o = t[a]) && (i[a] = o);
}
function xE(e, t, n, r, i, s, a) {
  var o, l, c = /* @__PURE__ */ new Map(), u = t.length, d = s.length, h = new Array(u), p;
  for (o = 0; o < u; ++o)
    (l = t[o]) && (h[o] = p = a.call(l, l.__data__, o, t) + "", c.has(p) ? i[o] = l : c.set(p, l));
  for (o = 0; o < d; ++o)
    p = a.call(e, s[o], o, s) + "", (l = c.get(p)) ? (r[o] = l, l.__data__ = s[o], c.delete(p)) : n[o] = new ua(e, s[o]);
  for (o = 0; o < u; ++o)
    (l = t[o]) && c.get(h[o]) === l && (i[o] = l);
}
function bE(e) {
  return e.__data__;
}
function _E(e, t) {
  if (!arguments.length) return Array.from(this, bE);
  var n = t ? xE : yE, r = this._parents, i = this._groups;
  typeof e != "function" && (e = vE(e));
  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var u = r[c], d = i[c], h = d.length, p = EE(e.call(u, u && u.__data__, c, r)), f = p.length, g = o[c] = new Array(f), m = a[c] = new Array(f), v = l[c] = new Array(h);
    n(u, d, g, m, v, p, t);
    for (var b = 0, _ = 0, E, x; b < f; ++b)
      if (E = g[b]) {
        for (b >= _ && (_ = b + 1); !(x = m[_]) && ++_ < f; ) ;
        E._next = x || null;
      }
  }
  return a = new _e(a, r), a._enter = o, a._exit = l, a;
}
function EE(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function OE() {
  return new _e(this._exit || this._groups.map(Kf), this._parents);
}
function SE(e, t, n) {
  var r = this.enter(), i = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;
}
function TE(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, s = r.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)
    for (var c = n[l], u = r[l], d = c.length, h = o[l] = new Array(d), p, f = 0; f < d; ++f)
      (p = c[f] || u[f]) && (h[f] = p);
  for (; l < i; ++l)
    o[l] = n[l];
  return new _e(o, this._parents);
}
function wE() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, s = r[i], a; --i >= 0; )
      (a = r[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function $E(e) {
  e || (e = ME);
  function t(d, h) {
    return d && h ? e(d.__data__, h.__data__) : !d - !h;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {
    for (var a = n[s], o = a.length, l = i[s] = new Array(o), c, u = 0; u < o; ++u)
      (c = a[u]) && (l[u] = c);
    l.sort(t);
  }
  return new _e(i, this._parents).order();
}
function ME(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function CE() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function AE() {
  return Array.from(this);
}
function LE() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length; i < s; ++i) {
      var a = r[i];
      if (a) return a;
    }
  return null;
}
function DE() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function kE() {
  return !this.node();
}
function RE(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], s = 0, a = i.length, o; s < a; ++s)
      (o = i[s]) && e.call(o, o.__data__, s, i);
  return this;
}
function IE(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function NE(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function PE(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function UE(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function BE(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function HE(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function VE(e, t) {
  var n = to(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? NE : IE : typeof t == "function" ? n.local ? HE : BE : n.local ? UE : PE)(n, t));
}
function Qf(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function GE(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function zE(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function FE(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function jE(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? GE : typeof t == "function" ? FE : zE)(e, t, n ?? "")) : Zr(this.node(), e);
}
function Zr(e, t) {
  return e.style.getPropertyValue(t) || Qf(e).getComputedStyle(e, null).getPropertyValue(t);
}
function WE(e) {
  return function() {
    delete this[e];
  };
}
function qE(e, t) {
  return function() {
    this[e] = t;
  };
}
function YE(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function XE(e, t) {
  return arguments.length > 1 ? this.each((t == null ? WE : typeof t == "function" ? YE : qE)(e, t)) : this.node()[e];
}
function Jf(e) {
  return e.trim().split(/^|\s+/);
}
function Dc(e) {
  return e.classList || new tm(e);
}
function tm(e) {
  this._node = e, this._names = Jf(e.getAttribute("class") || "");
}
tm.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function em(e, t) {
  for (var n = Dc(e), r = -1, i = t.length; ++r < i; ) n.add(t[r]);
}
function nm(e, t) {
  for (var n = Dc(e), r = -1, i = t.length; ++r < i; ) n.remove(t[r]);
}
function ZE(e) {
  return function() {
    em(this, e);
  };
}
function KE(e) {
  return function() {
    nm(this, e);
  };
}
function QE(e, t) {
  return function() {
    (t.apply(this, arguments) ? em : nm)(this, e);
  };
}
function JE(e, t) {
  var n = Jf(e + "");
  if (arguments.length < 2) {
    for (var r = Dc(this.node()), i = -1, s = n.length; ++i < s; ) if (!r.contains(n[i])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? QE : t ? ZE : KE)(n, t));
}
function tO() {
  this.textContent = "";
}
function eO(e) {
  return function() {
    this.textContent = e;
  };
}
function nO(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function rO(e) {
  return arguments.length ? this.each(e == null ? tO : (typeof e == "function" ? nO : eO)(e)) : this.node().textContent;
}
function iO() {
  this.innerHTML = "";
}
function sO(e) {
  return function() {
    this.innerHTML = e;
  };
}
function aO(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function oO(e) {
  return arguments.length ? this.each(e == null ? iO : (typeof e == "function" ? aO : sO)(e)) : this.node().innerHTML;
}
function lO() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function cO() {
  return this.each(lO);
}
function uO() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function hO() {
  return this.each(uO);
}
function dO(e) {
  var t = typeof e == "function" ? e : qf(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function pO() {
  return null;
}
function fO(e, t) {
  var n = typeof e == "function" ? e : qf(e), r = t == null ? pO : typeof t == "function" ? t : Lc(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function mO() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function gO() {
  return this.each(mO);
}
function vO() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function yO() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function xO(e) {
  return this.select(e ? yO : vO);
}
function bO(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function _O(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function EO(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function OO(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, s; n < i; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function SO(e, t, n) {
  return function() {
    var r = this.__on, i, s = _O(t);
    if (r) {
      for (var a = 0, o = r.length; a < o; ++a)
        if ((i = r[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), i = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function TO(e, t, n) {
  var r = EO(e + ""), i, s = r.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, c = o.length, u; l < c; ++l)
        for (i = 0, u = o[l]; i < s; ++i)
          if ((a = r[i]).type === u.type && a.name === u.name)
            return u.value;
    }
    return;
  }
  for (o = t ? SO : OO, i = 0; i < s; ++i) this.each(o(r[i], t, n));
  return this;
}
function rm(e, t, n) {
  var r = Qf(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function wO(e, t) {
  return function() {
    return rm(this, e, t);
  };
}
function $O(e, t) {
  return function() {
    return rm(this, e, t.apply(this, arguments));
  };
}
function MO(e, t) {
  return this.each((typeof t == "function" ? $O : wO)(e, t));
}
function* CO() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length, a; i < s; ++i)
      (a = r[i]) && (yield a);
}
var im = [null];
function _e(e, t) {
  this._groups = e, this._parents = t;
}
function fs() {
  return new _e([[document.documentElement]], im);
}
function AO() {
  return this;
}
_e.prototype = fs.prototype = {
  constructor: _e,
  select: nE,
  selectAll: aE,
  selectChild: uE,
  selectChildren: fE,
  filter: mE,
  data: _E,
  enter: gE,
  exit: OE,
  join: SE,
  merge: TE,
  selection: AO,
  order: wE,
  sort: $E,
  call: CE,
  nodes: AE,
  node: LE,
  size: DE,
  empty: kE,
  each: RE,
  attr: VE,
  style: jE,
  property: XE,
  classed: JE,
  text: rO,
  html: oO,
  raise: cO,
  lower: hO,
  append: dO,
  insert: fO,
  remove: gO,
  clone: xO,
  datum: bO,
  on: TO,
  dispatch: MO,
  [Symbol.iterator]: CO
};
function LO(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function rr(e, t) {
  if (e = LO(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
function kc(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function sm(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function ms() {
}
var Ji = 0.7, ha = 1 / Ji, zr = "\\s*([+-]?\\d+)\\s*", ts = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", tn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", DO = /^#([0-9a-f]{3,8})$/, kO = new RegExp(`^rgb\\(${zr},${zr},${zr}\\)$`), RO = new RegExp(`^rgb\\(${tn},${tn},${tn}\\)$`), IO = new RegExp(`^rgba\\(${zr},${zr},${zr},${ts}\\)$`), NO = new RegExp(`^rgba\\(${tn},${tn},${tn},${ts}\\)$`), PO = new RegExp(`^hsl\\(${ts},${tn},${tn}\\)$`), UO = new RegExp(`^hsla\\(${ts},${tn},${tn},${ts}\\)$`), dh = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
kc(ms, Tn, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: ph,
  // Deprecated! Use color.formatHex.
  formatHex: ph,
  formatHex8: BO,
  formatHsl: HO,
  formatRgb: fh,
  toString: fh
});
function ph() {
  return this.rgb().formatHex();
}
function BO() {
  return this.rgb().formatHex8();
}
function HO() {
  return am(this).formatHsl();
}
function fh() {
  return this.rgb().formatRgb();
}
function Tn(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = DO.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? mh(t) : n === 3 ? new he(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? $s(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? $s(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = kO.exec(e)) ? new he(t[1], t[2], t[3], 1) : (t = RO.exec(e)) ? new he(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = IO.exec(e)) ? $s(t[1], t[2], t[3], t[4]) : (t = NO.exec(e)) ? $s(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = PO.exec(e)) ? yh(t[1], t[2] / 100, t[3] / 100, 1) : (t = UO.exec(e)) ? yh(t[1], t[2] / 100, t[3] / 100, t[4]) : dh.hasOwnProperty(e) ? mh(dh[e]) : e === "transparent" ? new he(NaN, NaN, NaN, 0) : null;
}
function mh(e) {
  return new he(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function $s(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new he(e, t, n, r);
}
function VO(e) {
  return e instanceof ms || (e = Tn(e)), e ? (e = e.rgb(), new he(e.r, e.g, e.b, e.opacity)) : new he();
}
function Ol(e, t, n, r) {
  return arguments.length === 1 ? VO(e) : new he(e, t, n, r ?? 1);
}
function he(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
kc(he, Ol, sm(ms, {
  brighter(e) {
    return e = e == null ? ha : Math.pow(ha, e), new he(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ji : Math.pow(Ji, e), new he(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new he(tr(this.r), tr(this.g), tr(this.b), da(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: gh,
  // Deprecated! Use color.formatHex.
  formatHex: gh,
  formatHex8: GO,
  formatRgb: vh,
  toString: vh
}));
function gh() {
  return `#${Qn(this.r)}${Qn(this.g)}${Qn(this.b)}`;
}
function GO() {
  return `#${Qn(this.r)}${Qn(this.g)}${Qn(this.b)}${Qn((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function vh() {
  const e = da(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${tr(this.r)}, ${tr(this.g)}, ${tr(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function da(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function tr(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Qn(e) {
  return e = tr(e), (e < 16 ? "0" : "") + e.toString(16);
}
function yh(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new He(e, t, n, r);
}
function am(e) {
  if (e instanceof He) return new He(e.h, e.s, e.l, e.opacity);
  if (e instanceof ms || (e = Tn(e)), !e) return new He();
  if (e instanceof He) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), s = Math.max(t, n, r), a = NaN, o = s - i, l = (s + i) / 2;
  return o ? (t === s ? a = (n - r) / o + (n < r) * 6 : n === s ? a = (r - t) / o + 2 : a = (t - n) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new He(a, o, l, e.opacity);
}
function om(e, t, n, r) {
  return arguments.length === 1 ? am(e) : new He(e, t, n, r ?? 1);
}
function He(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
kc(He, om, sm(ms, {
  brighter(e) {
    return e = e == null ? ha : Math.pow(ha, e), new He(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ji : Math.pow(Ji, e), new He(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new he(
      Mo(e >= 240 ? e - 240 : e + 120, i, r),
      Mo(e, i, r),
      Mo(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new He(xh(this.h), Ms(this.s), Ms(this.l), da(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = da(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${xh(this.h)}, ${Ms(this.s) * 100}%, ${Ms(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function xh(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Ms(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Mo(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const Rc = (e) => () => e;
function zO(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function FO(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function jO(e) {
  return (e = +e) == 1 ? lm : function(t, n) {
    return n - t ? FO(t, n, e) : Rc(isNaN(t) ? n : t);
  };
}
function lm(e, t) {
  var n = t - e;
  return n ? zO(e, n) : Rc(isNaN(e) ? t : e);
}
const pa = function e(t) {
  var n = jO(t);
  function r(i, s) {
    var a = n((i = Ol(i)).r, (s = Ol(s)).r), o = n(i.g, s.g), l = n(i.b, s.b), c = lm(i.opacity, s.opacity);
    return function(u) {
      return i.r = a(u), i.g = o(u), i.b = l(u), i.opacity = c(u), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function WO(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(s) {
    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - s) + t[i] * s;
    return r;
  };
}
function qO(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function YO(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), s = new Array(n), a;
  for (a = 0; a < r; ++a) i[a] = gs(e[a], t[a]);
  for (; a < n; ++a) s[a] = t[a];
  return function(o) {
    for (a = 0; a < r; ++a) s[a] = i[a](o);
    return s;
  };
}
function XO(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function xe(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function ZO(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = gs(e[i], t[i]) : r[i] = t[i];
  return function(s) {
    for (i in n) r[i] = n[i](s);
    return r;
  };
}
var Sl = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Co = new RegExp(Sl.source, "g");
function KO(e) {
  return function() {
    return e;
  };
}
function QO(e) {
  return function(t) {
    return e(t) + "";
  };
}
function cm(e, t) {
  var n = Sl.lastIndex = Co.lastIndex = 0, r, i, s, a = -1, o = [], l = [];
  for (e = e + "", t = t + ""; (r = Sl.exec(e)) && (i = Co.exec(t)); )
    (s = i.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (r = r[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: xe(r, i) })), n = Co.lastIndex;
  return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? QO(l[0].x) : KO(t) : (t = l.length, function(c) {
    for (var u = 0, d; u < t; ++u) o[(d = l[u]).i] = d.x(c);
    return o.join("");
  });
}
function gs(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? Rc(t) : (n === "number" ? xe : n === "string" ? (r = Tn(t)) ? (t = r, pa) : cm : t instanceof Tn ? pa : t instanceof Date ? XO : qO(t) ? WO : Array.isArray(t) ? YO : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? ZO : xe)(e, t);
}
function um(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var bh = 180 / Math.PI, hm = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function dm(e, t, n, r, i, s) {
  var a, o, l;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * r) && (n -= e * l, r -= t * l), (o = Math.sqrt(n * n + r * r)) && (n /= o, r /= o, l /= o), e * r < t * n && (e = -e, t = -t, l = -l, a = -a), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(t, e) * bh,
    skewX: Math.atan(l) * bh,
    scaleX: a,
    scaleY: o
  };
}
var Cs;
function JO(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? hm : dm(t.a, t.b, t.c, t.d, t.e, t.f);
}
function tS(e) {
  return e == null || (Cs || (Cs = document.createElementNS("http://www.w3.org/2000/svg", "g")), Cs.setAttribute("transform", e), !(e = Cs.transform.baseVal.consolidate())) ? hm : (e = e.matrix, dm(e.a, e.b, e.c, e.d, e.e, e.f));
}
function pm(e, t, n, r) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, u, d, h, p, f) {
    if (c !== d || u !== h) {
      var g = p.push("translate(", null, t, null, n);
      f.push({ i: g - 4, x: xe(c, d) }, { i: g - 2, x: xe(u, h) });
    } else (d || h) && p.push("translate(" + d + t + h + n);
  }
  function a(c, u, d, h) {
    c !== u ? (c - u > 180 ? u += 360 : u - c > 180 && (c += 360), h.push({ i: d.push(i(d) + "rotate(", null, r) - 2, x: xe(c, u) })) : u && d.push(i(d) + "rotate(" + u + r);
  }
  function o(c, u, d, h) {
    c !== u ? h.push({ i: d.push(i(d) + "skewX(", null, r) - 2, x: xe(c, u) }) : u && d.push(i(d) + "skewX(" + u + r);
  }
  function l(c, u, d, h, p, f) {
    if (c !== d || u !== h) {
      var g = p.push(i(p) + "scale(", null, ",", null, ")");
      f.push({ i: g - 4, x: xe(c, d) }, { i: g - 2, x: xe(u, h) });
    } else (d !== 1 || h !== 1) && p.push(i(p) + "scale(" + d + "," + h + ")");
  }
  return function(c, u) {
    var d = [], h = [];
    return c = e(c), u = e(u), s(c.translateX, c.translateY, u.translateX, u.translateY, d, h), a(c.rotate, u.rotate, d, h), o(c.skewX, u.skewX, d, h), l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, d, h), c = u = null, function(p) {
      for (var f = -1, g = h.length, m; ++f < g; ) d[(m = h[f]).i] = m.x(p);
      return d.join("");
    };
  };
}
var eS = pm(JO, "px, ", "px)", "deg)"), nS = pm(tS, ", ", ")", ")"), Kr = 0, wi = 0, mi = 0, fm = 1e3, fa, $i, ma = 0, ir = 0, eo = 0, es = typeof performance == "object" && performance.now ? performance : Date, mm = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Ic() {
  return ir || (mm(rS), ir = es.now() + eo);
}
function rS() {
  ir = 0;
}
function ga() {
  this._call = this._time = this._next = null;
}
ga.prototype = gm.prototype = {
  constructor: ga,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Ic() : +n) + (t == null ? 0 : +t), !this._next && $i !== this && ($i ? $i._next = this : fa = this, $i = this), this._call = e, this._time = n, Tl();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Tl());
  }
};
function gm(e, t, n) {
  var r = new ga();
  return r.restart(e, t, n), r;
}
function iS() {
  Ic(), ++Kr;
  for (var e = fa, t; e; )
    (t = ir - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Kr;
}
function _h() {
  ir = (ma = es.now()) + eo, Kr = wi = 0;
  try {
    iS();
  } finally {
    Kr = 0, aS(), ir = 0;
  }
}
function sS() {
  var e = es.now(), t = e - ma;
  t > fm && (eo -= t, ma = e);
}
function aS() {
  for (var e, t = fa, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : fa = n);
  $i = e, Tl(r);
}
function Tl(e) {
  if (!Kr) {
    wi && (wi = clearTimeout(wi));
    var t = e - ir;
    t > 24 ? (e < 1 / 0 && (wi = setTimeout(_h, e - es.now() - eo)), mi && (mi = clearInterval(mi))) : (mi || (ma = es.now(), mi = setInterval(sS, fm)), Kr = 1, mm(_h));
  }
}
function Eh(e, t, n) {
  var r = new ga();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var oS = Ac("start", "end", "cancel", "interrupt"), lS = [], vm = 0, Oh = 1, wl = 2, Xs = 3, Sh = 4, $l = 5, Zs = 6;
function no(e, t, n, r, i, s) {
  var a = e.__transition;
  if (!a) e.__transition = {};
  else if (n in a) return;
  cS(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: oS,
    tween: lS,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: vm
  });
}
function Nc(e, t) {
  var n = qe(e, t);
  if (n.state > vm) throw new Error("too late; already scheduled");
  return n;
}
function sn(e, t) {
  var n = qe(e, t);
  if (n.state > Xs) throw new Error("too late; already running");
  return n;
}
function qe(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function cS(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = gm(s, 0, n.time);
  function s(c) {
    n.state = Oh, n.timer.restart(a, n.delay, n.time), n.delay <= c && a(c - n.delay);
  }
  function a(c) {
    var u, d, h, p;
    if (n.state !== Oh) return l();
    for (u in r)
      if (p = r[u], p.name === n.name) {
        if (p.state === Xs) return Eh(a);
        p.state === Sh ? (p.state = Zs, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete r[u]) : +u < t && (p.state = Zs, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete r[u]);
      }
    if (Eh(function() {
      n.state === Xs && (n.state = Sh, n.timer.restart(o, n.delay, n.time), o(c));
    }), n.state = wl, n.on.call("start", e, e.__data__, n.index, n.group), n.state === wl) {
      for (n.state = Xs, i = new Array(h = n.tween.length), u = 0, d = -1; u < h; ++u)
        (p = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (i[++d] = p);
      i.length = d + 1;
    }
  }
  function o(c) {
    for (var u = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(l), n.state = $l, 1), d = -1, h = i.length; ++d < h; )
      i[d].call(e, u);
    n.state === $l && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = Zs, n.timer.stop(), delete r[t];
    for (var c in r) return;
    delete e.__transition;
  }
}
function Ml(e, t) {
  var n = e.__transition, r, i, s = !0, a;
  if (n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((r = n[a]).name !== t) {
        s = !1;
        continue;
      }
      i = r.state > wl && r.state < $l, r.state = Zs, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];
    }
    s && delete e.__transition;
  }
}
function uS(e) {
  return this.each(function() {
    Ml(this, e);
  });
}
function hS(e, t) {
  var n, r;
  return function() {
    var i = sn(this, e), s = i.tween;
    if (s !== n) {
      r = n = s;
      for (var a = 0, o = r.length; a < o; ++a)
        if (r[a].name === t) {
          r = r.slice(), r.splice(a, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function dS(e, t, n) {
  var r, i;
  if (typeof n != "function") throw new Error();
  return function() {
    var s = sn(this, e), a = s.tween;
    if (a !== r) {
      i = (r = a).slice();
      for (var o = { name: t, value: n }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === t) {
          i[l] = o;
          break;
        }
      l === c && i.push(o);
    }
    s.tween = i;
  };
}
function pS(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = qe(this.node(), n).tween, i = 0, s = r.length, a; i < s; ++i)
      if ((a = r[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? hS : dS)(n, e, t));
}
function Pc(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = sn(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return qe(i, r).value[t];
  };
}
function ym(e, t) {
  var n;
  return (typeof t == "number" ? xe : t instanceof Tn ? pa : (n = Tn(t)) ? (t = n, pa) : cm)(e, t);
}
function fS(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function mS(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function gS(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function vS(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function yS(e, t, n) {
  var r, i, s;
  return function() {
    var a, o = n(this), l;
    return o == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));
  };
}
function xS(e, t, n) {
  var r, i, s;
  return function() {
    var a, o = n(this), l;
    return o == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));
  };
}
function bS(e, t) {
  var n = to(e), r = n === "transform" ? nS : ym;
  return this.attrTween(e, typeof t == "function" ? (n.local ? xS : yS)(n, r, Pc(this, "attr." + e, t)) : t == null ? (n.local ? mS : fS)(n) : (n.local ? vS : gS)(n, r, t));
}
function _S(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function ES(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function OS(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && ES(e, s)), n;
  }
  return i._value = t, i;
}
function SS(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && _S(e, s)), n;
  }
  return i._value = t, i;
}
function TS(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = to(e);
  return this.tween(n, (r.local ? OS : SS)(r, t));
}
function wS(e, t) {
  return function() {
    Nc(this, e).delay = +t.apply(this, arguments);
  };
}
function $S(e, t) {
  return t = +t, function() {
    Nc(this, e).delay = t;
  };
}
function MS(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? wS : $S)(t, e)) : qe(this.node(), t).delay;
}
function CS(e, t) {
  return function() {
    sn(this, e).duration = +t.apply(this, arguments);
  };
}
function AS(e, t) {
  return t = +t, function() {
    sn(this, e).duration = t;
  };
}
function LS(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? CS : AS)(t, e)) : qe(this.node(), t).duration;
}
function DS(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    sn(this, e).ease = t;
  };
}
function kS(e) {
  var t = this._id;
  return arguments.length ? this.each(DS(t, e)) : qe(this.node(), t).ease;
}
function RS(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    sn(this, e).ease = n;
  };
}
function IS(e) {
  if (typeof e != "function") throw new Error();
  return this.each(RS(this._id, e));
}
function NS(e) {
  typeof e != "function" && (e = Xf(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);
  return new wn(r, this._parents, this._name, this._id);
}
function PS(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, s = Math.min(r, i), a = new Array(r), o = 0; o < s; ++o)
    for (var l = t[o], c = n[o], u = l.length, d = a[o] = new Array(u), h, p = 0; p < u; ++p)
      (h = l[p] || c[p]) && (d[p] = h);
  for (; o < r; ++o)
    a[o] = t[o];
  return new wn(a, this._parents, this._name, this._id);
}
function US(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function BS(e, t, n) {
  var r, i, s = US(t) ? Nc : sn;
  return function() {
    var a = s(this, e), o = a.on;
    o !== r && (i = (r = o).copy()).on(t, n), a.on = i;
  };
}
function HS(e, t) {
  var n = this._id;
  return arguments.length < 2 ? qe(this.node(), n).on.on(e) : this.each(BS(n, e, t));
}
function VS(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function GS() {
  return this.on("end.remove", VS(this._id));
}
function zS(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Lc(e));
  for (var r = this._groups, i = r.length, s = new Array(i), a = 0; a < i; ++a)
    for (var o = r[a], l = o.length, c = s[a] = new Array(l), u, d, h = 0; h < l; ++h)
      (u = o[h]) && (d = e.call(u, u.__data__, h, o)) && ("__data__" in u && (d.__data__ = u.__data__), c[h] = d, no(c[h], t, n, h, c, qe(u, n)));
  return new wn(s, this._parents, t, n);
}
function FS(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Yf(e));
  for (var r = this._groups, i = r.length, s = [], a = [], o = 0; o < i; ++o)
    for (var l = r[o], c = l.length, u, d = 0; d < c; ++d)
      if (u = l[d]) {
        for (var h = e.call(u, u.__data__, d, l), p, f = qe(u, n), g = 0, m = h.length; g < m; ++g)
          (p = h[g]) && no(p, t, n, g, h, f);
        s.push(h), a.push(u);
      }
  return new wn(s, a, t, n);
}
var jS = fs.prototype.constructor;
function WS() {
  return new jS(this._groups, this._parents);
}
function qS(e, t) {
  var n, r, i;
  return function() {
    var s = Zr(this, e), a = (this.style.removeProperty(e), Zr(this, e));
    return s === a ? null : s === n && a === r ? i : i = t(n = s, r = a);
  };
}
function xm(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function YS(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = Zr(this, e);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function XS(e, t, n) {
  var r, i, s;
  return function() {
    var a = Zr(this, e), o = n(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(e), Zr(this, e))), a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o));
  };
}
function ZS(e, t) {
  var n, r, i, s = "style." + t, a = "end." + s, o;
  return function() {
    var l = sn(this, e), c = l.on, u = l.value[s] == null ? o || (o = xm(t)) : void 0;
    (c !== n || i !== u) && (r = (n = c).copy()).on(a, i = u), l.on = r;
  };
}
function KS(e, t, n) {
  var r = (e += "") == "transform" ? eS : ym;
  return t == null ? this.styleTween(e, qS(e, r)).on("end.style." + e, xm(e)) : typeof t == "function" ? this.styleTween(e, XS(e, r, Pc(this, "style." + e, t))).each(ZS(this._id, e)) : this.styleTween(e, YS(e, r, t), n).on("end.style." + e, null);
}
function QS(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function JS(e, t, n) {
  var r, i;
  function s() {
    var a = t.apply(this, arguments);
    return a !== i && (r = (i = a) && QS(e, a, n)), r;
  }
  return s._value = t, s;
}
function tT(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, JS(e, t, n ?? ""));
}
function eT(e) {
  return function() {
    this.textContent = e;
  };
}
function nT(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function rT(e) {
  return this.tween("text", typeof e == "function" ? nT(Pc(this, "text", e)) : eT(e == null ? "" : e + ""));
}
function iT(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function sT(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && iT(i)), t;
  }
  return r._value = e, r;
}
function aT(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, sT(e));
}
function oT() {
  for (var e = this._name, t = this._id, n = bm(), r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)
      if (l = a[c]) {
        var u = qe(l, t);
        no(l, e, n, c, a, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease
        });
      }
  return new wn(r, this._parents, e, n);
}
function lT() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(s, a) {
    var o = { value: a }, l = { value: function() {
      --i === 0 && s();
    } };
    n.each(function() {
      var c = sn(this, r), u = c.on;
      u !== e && (t = (e = u).copy(), t._.cancel.push(o), t._.interrupt.push(o), t._.end.push(l)), c.on = t;
    }), i === 0 && s();
  });
}
var cT = 0;
function wn(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function bm() {
  return ++cT;
}
var un = fs.prototype;
wn.prototype = {
  constructor: wn,
  select: zS,
  selectAll: FS,
  selectChild: un.selectChild,
  selectChildren: un.selectChildren,
  filter: NS,
  merge: PS,
  selection: WS,
  transition: oT,
  call: un.call,
  nodes: un.nodes,
  node: un.node,
  size: un.size,
  empty: un.empty,
  each: un.each,
  on: HS,
  attr: bS,
  attrTween: TS,
  style: KS,
  styleTween: tT,
  text: rT,
  textTween: aT,
  remove: GS,
  tween: pS,
  delay: MS,
  duration: LS,
  ease: kS,
  easeVarying: IS,
  end: lT,
  [Symbol.iterator]: un[Symbol.iterator]
};
function _m(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var uT = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: _m
};
function hT(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function dT(e) {
  var t, n;
  e instanceof wn ? (t = e._id, e = e._name) : (t = bm(), (n = uT).time = Ic(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && no(l, e, t, c, a, n || hT(l, t));
  return new wn(r, this._parents, e, t);
}
fs.prototype.interrupt = uS;
fs.prototype.transition = dT;
function pT(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function va(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function Qr(e) {
  return e = va(Math.abs(e)), e ? e[1] : NaN;
}
function fT(e, t) {
  return function(n, r) {
    for (var i = n.length, s = [], a = 0, o = e[0], l = 0; i > 0 && o > 0 && (l + o + 1 > r && (o = Math.max(1, r - l)), s.push(n.substring(i -= o, i + o)), !((l += o + 1) > r)); )
      o = e[a = (a + 1) % e.length];
    return s.reverse().join(t);
  };
}
function mT(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var gT = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function ns(e) {
  if (!(t = gT.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new Uc({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
ns.prototype = Uc.prototype;
function Uc(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Uc.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function vT(e) {
  t: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
    switch (e[n]) {
      case ".":
        r = i = n;
        break;
      case "0":
        r === 0 && (r = n), i = n;
        break;
      default:
        if (!+e[n]) break t;
        r > 0 && (r = 0);
        break;
    }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var Em;
function yT(e, t) {
  var n = va(e, t);
  if (!n) return e + "";
  var r = n[0], i = n[1], s = i - (Em = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;
  return s === a ? r : s > a ? r + new Array(s - a + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + va(e, Math.max(0, t + s - 1))[0];
}
function Th(e, t) {
  var n = va(e, t);
  if (!n) return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const wh = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: pT,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => Th(e * 100, t),
  r: Th,
  s: yT,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function $h(e) {
  return e;
}
var Mh = Array.prototype.map, Ch = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function xT(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? $h : fT(Mh.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? $h : mT(Mh.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", o = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function c(d) {
    d = ns(d);
    var h = d.fill, p = d.align, f = d.sign, g = d.symbol, m = d.zero, v = d.width, b = d.comma, _ = d.precision, E = d.trim, x = d.type;
    x === "n" ? (b = !0, x = "g") : wh[x] || (_ === void 0 && (_ = 12), E = !0, x = "g"), (m || h === "0" && p === "=") && (m = !0, h = "0", p = "=");
    var S = g === "$" ? n : g === "#" && /[boxX]/.test(x) ? "0" + x.toLowerCase() : "", $ = g === "$" ? r : /[%p]/.test(x) ? a : "", D = wh[x], C = /[defgprs%]/.test(x);
    _ = _ === void 0 ? 6 : /[gprs]/.test(x) ? Math.max(1, Math.min(21, _)) : Math.max(0, Math.min(20, _));
    function R(M) {
      var H = S, P = $, B, O, w;
      if (x === "c")
        P = D(M) + P, M = "";
      else {
        M = +M;
        var L = M < 0 || 1 / M < 0;
        if (M = isNaN(M) ? l : D(Math.abs(M), _), E && (M = vT(M)), L && +M == 0 && f !== "+" && (L = !1), H = (L ? f === "(" ? f : o : f === "-" || f === "(" ? "" : f) + H, P = (x === "s" ? Ch[8 + Em / 3] : "") + P + (L && f === "(" ? ")" : ""), C) {
          for (B = -1, O = M.length; ++B < O; )
            if (w = M.charCodeAt(B), 48 > w || w > 57) {
              P = (w === 46 ? i + M.slice(B + 1) : M.slice(B)) + P, M = M.slice(0, B);
              break;
            }
        }
      }
      b && !m && (M = t(M, 1 / 0));
      var k = H.length + M.length + P.length, U = k < v ? new Array(v - k + 1).join(h) : "";
      switch (b && m && (M = t(U + M, U.length ? v - P.length : 1 / 0), U = ""), p) {
        case "<":
          M = H + M + P + U;
          break;
        case "=":
          M = H + U + M + P;
          break;
        case "^":
          M = U.slice(0, k = U.length >> 1) + H + M + P + U.slice(k);
          break;
        default:
          M = U + H + M + P;
          break;
      }
      return s(M);
    }
    return R.toString = function() {
      return d + "";
    }, R;
  }
  function u(d, h) {
    var p = c((d = ns(d), d.type = "f", d)), f = Math.max(-8, Math.min(8, Math.floor(Qr(h) / 3))) * 3, g = Math.pow(10, -f), m = Ch[8 + f / 3];
    return function(v) {
      return p(g * v) + m;
    };
  }
  return {
    format: c,
    formatPrefix: u
  };
}
var As, Bc, Om;
bT({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function bT(e) {
  return As = xT(e), Bc = As.format, Om = As.formatPrefix, As;
}
function _T(e) {
  return Math.max(0, -Qr(Math.abs(e)));
}
function ET(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Qr(t) / 3))) * 3 - Qr(Math.abs(e)));
}
function OT(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Qr(t) - Qr(e)) + 1;
}
function ai(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
const Ah = Symbol("implicit");
function ro() {
  var e = new lh(), t = [], n = [], r = Ah;
  function i(s) {
    let a = e.get(s);
    if (a === void 0) {
      if (r !== Ah) return r;
      e.set(s, a = t.push(s) - 1);
    }
    return n[a % n.length];
  }
  return i.domain = function(s) {
    if (!arguments.length) return t.slice();
    t = [], e = new lh();
    for (const a of s)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (n = Array.from(s), i) : n.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return ro(t, n).unknown(r);
  }, ai.apply(i, arguments), i;
}
function ST(e) {
  return function() {
    return e;
  };
}
function TT(e) {
  return +e;
}
var Lh = [0, 1];
function Nr(e) {
  return e;
}
function Cl(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : ST(isNaN(t) ? NaN : 0.5);
}
function wT(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function $T(e, t, n) {
  var r = e[0], i = e[1], s = t[0], a = t[1];
  return i < r ? (r = Cl(i, r), s = n(a, s)) : (r = Cl(r, i), s = n(s, a)), function(o) {
    return s(r(o));
  };
}
function MT(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), s = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    i[a] = Cl(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);
  return function(o) {
    var l = Cc(e, o, 1, r) - 1;
    return s[l](i[l](o));
  };
}
function Hc(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function Sm() {
  var e = Lh, t = Lh, n = gs, r, i, s, a = Nr, o, l, c;
  function u() {
    var h = Math.min(e.length, t.length);
    return a !== Nr && (a = wT(e[0], e[h - 1])), o = h > 2 ? MT : $T, l = c = null, d;
  }
  function d(h) {
    return h == null || isNaN(h = +h) ? s : (l || (l = o(e.map(r), t, n)))(r(a(h)));
  }
  return d.invert = function(h) {
    return a(i((c || (c = o(t, e.map(r), xe)))(h)));
  }, d.domain = function(h) {
    return arguments.length ? (e = Array.from(h, TT), u()) : e.slice();
  }, d.range = function(h) {
    return arguments.length ? (t = Array.from(h), u()) : t.slice();
  }, d.rangeRound = function(h) {
    return t = Array.from(h), n = um, u();
  }, d.clamp = function(h) {
    return arguments.length ? (a = h ? !0 : Nr, u()) : a !== Nr;
  }, d.interpolate = function(h) {
    return arguments.length ? (n = h, u()) : n;
  }, d.unknown = function(h) {
    return arguments.length ? (s = h, d) : s;
  }, function(h, p) {
    return r = h, i = p, u();
  };
}
function Tm() {
  return Sm()(Nr, Nr);
}
function CT(e, t, n, r) {
  var i = _l(e, t, n), s;
  switch (r = ns(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(s = ET(i, a)) && (r.precision = s), Om(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(s = OT(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(s = _T(i)) && (r.precision = s - (r.type === "%") * 2);
      break;
    }
  }
  return Bc(r);
}
function wm(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return ca(r[0], r[r.length - 1], n ?? 10);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return CT(i[0], i[i.length - 1], n ?? 10, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, s = r.length - 1, a = r[i], o = r[s], l, c, u = 10;
    for (o < a && (c = a, a = o, o = c, c = i, i = s, s = c); u-- > 0; ) {
      if (c = Xr(a, o, n), c === l)
        return r[i] = a, r[s] = o, t(r);
      if (c > 0)
        a = Math.floor(a / c) * c, o = Math.ceil(o / c) * c;
      else if (c < 0)
        a = Math.ceil(a * c) / c, o = Math.floor(o * c) / c;
      else
        break;
      l = c;
    }
    return e;
  }, e;
}
function Fe() {
  var e = Tm();
  return e.copy = function() {
    return Hc(e, Fe());
  }, ai.apply(e, arguments), wm(e);
}
function Vc() {
  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], s;
  function a(l) {
    return l != null && l <= l ? i[Cc(r, l, 0, n)] : s;
  }
  function o() {
    var l = -1;
    for (r = new Array(n); ++l < n; ) r[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, o()) : [e, t];
  }, a.range = function(l) {
    return arguments.length ? (n = (i = Array.from(l)).length - 1, o()) : i.slice();
  }, a.invertExtent = function(l) {
    var c = i.indexOf(l);
    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];
  }, a.unknown = function(l) {
    return arguments.length && (s = l), a;
  }, a.thresholds = function() {
    return r.slice();
  }, a.copy = function() {
    return Vc().domain([e, t]).range(i).unknown(s);
  }, ai.apply(wm(a), arguments);
}
function Mi(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Mi.prototype = {
  constructor: Mi,
  scale: function(e) {
    return e === 1 ? this : new Mi(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Mi(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Mi.prototype;
const ue = "cds", yn = {
  opacity: {
    unselected: 0.05,
    selected: 0.4
  }
}, Pn = {
  ticks: {
    number: 7,
    verticalSpaceRatio: 2.5,
    horizontalSpaceRatio: 3.5
  },
  ratio: {
    reference: "value",
    compareTo: "marker"
  },
  paddingRatio: 0.1,
  hover: {
    rectanglePadding: 4
  }
}, Pr = {
  duration: 1e3,
  ease: _m,
  zoomLevel: 3
}, Ar = {
  circles: {
    fillOpacity: 0.3,
    hover: {
      stroke: "#FFF"
    }
  },
  padding: {
    mainGroup: 4,
    children: 2
  },
  depth: 2
}, $m = {
  pairingOptions: {
    "1-color": 4,
    "2-color": 5,
    "3-color": 5,
    "4-color": 3,
    "5-color": 2,
    "14-color": 1
  }
}, Te = {
  circle: {
    radius: 4,
    opacity: {
      hovered: 1,
      default: 0.3
    }
  },
  box: {
    opacity: {
      hovered: 0.5,
      default: 0.3
    }
  },
  strokeWidth: {
    default: 1,
    thicker: 2
  }
}, AT = {
  defaultBins: 10
}, It = {
  items: {
    status: {
      ACTIVE: 1,
      DISABLED: 0
    },
    horizontalSpace: 12,
    verticalSpace: 24,
    textYOffset: 8,
    spaceAfter: 4
  },
  checkbox: {
    radius: 6.5
  },
  radius: {
    iconData: [
      { cx: 7, cy: 7, r: 6.5 },
      { cx: 7, cy: 10, r: 3.5 }
    ],
    fill: null,
    stroke: "#8c8c8c"
  },
  line: {
    yPosition: 6,
    width: 24,
    strokeWidth: 1.4,
    fill: null,
    stroke: "#999999"
  },
  area: {
    width: 24,
    height: 14,
    fill: "#6f6f6f",
    stroke: null
  },
  size: {
    iconData: [
      { width: 23, height: 12 },
      { width: 13, height: 6 }
    ],
    fill: null,
    stroke: "#8D8D8D"
  },
  quartile: {
    iconData: [
      { x: 0, y: 0, width: 24, height: 13 },
      { x: 11, y: 4, width: 1, height: 4 }
    ]
  },
  zoom: {
    iconData: [{ x: 0, y: 0, width: 12, height: 12 }],
    color: "#8D8D8D"
  },
  color: {
    barWidth: 300,
    barHeight: 8,
    axisYTranslation: 10
  }
}, vn = {
  opacity: {
    unselected: 0.3,
    selected: 1
  },
  weight: {
    selected: 2,
    unselected: 1
  }
}, Zt = {
  statusBar: {
    paddingRight: 5
  },
  status: {
    indicatorSize: 16,
    paddingLeft: 15
  },
  total: {
    paddingLeft: 36,
    paddingRight: 24
  },
  height: {
    default: 8,
    proportional: 16
  },
  dividerWidth: 2
}, Mt = {
  radiusOffset: -15,
  innerRadius: 2,
  padAngle: 7e-3,
  hoverArc: {
    outerRadiusOffset: 3
  },
  xOffset: 30,
  yOffset: 20,
  yOffsetCallout: 10,
  callout: {
    minSliceDegree: 5,
    offsetX: 15,
    offsetY: 12,
    horizontalLineLength: 8,
    textMargin: 2
  }
}, Wn = {
  opacity: {
    unselected: 0.1,
    selected: 0.3
  },
  xLabelPadding: 10,
  yLabelPadding: 8,
  yTicksNumber: 4,
  minRange: 10,
  xAxisRectHeight: 50,
  dotsRadius: 5
}, Pe = {
  nodeWidth: 4,
  minNodePadding: 24,
  opacity: {
    unfocus: 0.3,
    default: 0.8,
    selected: 1
  }
}, Dh = {
  minCellDividerDimension: 16
}, kh = {
  default: {
    size: 24
  }
}, Rh = {
  defaultOffset: 4,
  horizontalOffset: 10
}, Ih = {
  default: {
    duration: 300
  },
  pie_slice_mouseover: {
    duration: 100
  },
  pie_slice_mouseout: {
    duration: 100
  },
  pie_chart_titles: {
    duration: 375
  },
  graph_element_mouseover_fill_update: {
    duration: 100
  },
  graph_element_mouseout_fill_update: {
    duration: 100
  }
}, ye = {
  height: {
    [Ke.GRAPH_VIEW]: 32,
    [Ke.SLIDER_VIEW]: 10
  },
  spacerHeight: 8,
  handleWidth: 5,
  handleBarWidth: 1,
  handleBarHeight: 12
}, LT = [
  {
    type: Gt.RADIUS,
    name: "Radius"
  },
  {
    type: Gt.AREA,
    name: "Poor area"
  },
  {
    type: Gt.AREA,
    name: "Satisfactory area"
  },
  {
    type: Gt.AREA,
    name: "Great area"
  },
  {
    type: Gt.QUARTILE,
    name: "Quartiles"
  }
], Ur = {
  type: Ve.END_LINE,
  threshold: 16,
  numCharacter: 14
}, Mm = 4, DT = {
  code: typeof navigator < "u" && navigator?.language || "en-US",
  // read from browser's navigator.language
  number: (e, t = navigator?.language || "en-US") => e?.toLocaleString?.(t),
  // based on code property if specified
  date: (e, t = navigator?.language || "en-US", n = {}, r = null) => r || e.toLocaleDateString(t, n),
  // based on code property if specified
  time: (e, t = navigator?.language || "en-US", n = {}, r = null) => r || e.toLocaleTimeString(t, n),
  // based on code property if specified
  optionsObject: {
    "15seconds": {
      primary: {
        "MMM d, pp": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
          hourCycle: "h12"
        },
        "MMM d, h:mm:ss.SSS a": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          fractionalSecondDigits: 3,
          hourCycle: "h12"
        }
      },
      secondary: {
        pp: {
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
          hourCycle: "h12"
        },
        "h:mm:ss.SSS a": {
          hour: "numeric",
          minute: "2-digit",
          fractionalSecondDigits: 3,
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    minute: {
      primary: {
        "MMM d, p": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      secondary: {
        p: {
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    "30minutes": {
      primary: {
        "MMM d, p": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      secondary: {
        p: {
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    hourly: {
      primary: {
        "MMM d, hh a": {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          hourCycle: "h12"
        }
      },
      secondary: {
        "hh a": {
          hour: "2-digit",
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    daily: {
      primary: {
        "MMM d": {
          month: "short",
          day: "numeric"
        }
      },
      secondary: {
        d: {
          day: "numeric"
        }
      },
      type: "date"
    },
    weekly: {
      primary: {
        "eee, MMM d": {
          weekday: "short",
          month: "short",
          day: "numeric"
        }
      },
      secondary: {
        eee: {
          weekday: "short"
        }
      },
      type: "date"
    },
    monthly: {
      primary: {
        "MMM yyyy": {
          month: "short",
          year: "numeric"
        }
      },
      secondary: {
        MMM: {
          month: "short"
        }
      },
      type: "date"
    },
    quarterly: {
      primary: {},
      secondary: {},
      type: "date"
    },
    yearly: {
      primary: {
        yyyy: {
          year: "numeric"
        }
      },
      secondary: {
        yyyy: {
          year: "numeric"
        }
      },
      type: "date"
    }
  },
  translations: {
    group: "Group",
    total: "Total",
    meter: {
      title: ""
      //default is emply string as meter title is dataset label
    },
    tabularRep: {
      title: "Tabular representation",
      downloadAsCSV: "Download as CSV"
    },
    toolbar: {
      exportAsCSV: "Export to CSV",
      exportAsJPG: "Export to JPG",
      exportAsPNG: "Export to PNG",
      zoomIn: "Zoom in",
      zoomOut: "Zoom out",
      resetZoom: "Reset zoom",
      moreOptions: "More options",
      makeFullScreen: "Make fullscreen",
      exitFullScreen: "Exit fullscreen",
      showAsTable: "Show as table"
    }
  }
}, kT = {
  enabled: !0,
  position: Ui.BOTTOM,
  clickable: !0,
  truncation: Ur,
  alignment: jt.LEFT,
  order: null,
  additionalItems: []
}, RT = {
  x: {
    // set enable to false will not draw grid and stroke of grid backdrop
    enabled: !0,
    numberOfTicks: 15,
    alignWithAxisTicks: !1
  },
  y: {
    // set enable to false will not draw grid and stroke of grid backdrop
    enabled: !0,
    numberOfTicks: 5,
    alignWithAxisTicks: !1
  }
}, IT = {
  // enable or disable ruler
  enabled: !0
}, Cm = {
  enabled: !0,
  showTotal: !0,
  truncation: Ur,
  groupLabel: "Group"
}, Am = {
  top: {
    visible: !0,
    includeZero: !0,
    truncation: Ur
  },
  bottom: {
    visible: !0,
    includeZero: !0,
    truncation: Ur
  },
  left: {
    visible: !0,
    includeZero: !0,
    truncation: Ur
  },
  right: {
    visible: !0,
    includeZero: !0,
    truncation: Ur
  }
}, io = {
  addSpaceOnEdges: 1,
  showDayName: !1,
  localeObject: hf,
  timeIntervalFormats: {
    "15seconds": { primary: "MMM d, pp", secondary: "pp" },
    minute: { primary: "MMM d, p", secondary: "p" },
    "30minutes": { primary: "MMM d, p", secondary: "p" },
    hourly: { primary: "MMM d, hh a", secondary: "hh a" },
    daily: { primary: "MMM d", secondary: "d" },
    weekly: { primary: "eee, MMM d", secondary: "eee" },
    monthly: { primary: "MMM yyyy", secondary: "MMM" },
    quarterly: { primary: "QQQ ''yy", secondary: "QQQ" },
    yearly: { primary: "yyyy", secondary: "yyyy" }
  }
};
let Lm = !1;
try {
  Lm = typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
} catch (e) {
  console.warn("Fullscreen capabilities check failed: ", e.message);
}
const re = {
  width: null,
  height: null,
  resizable: !0,
  theme: af.WHITE,
  tooltip: Cm,
  legend: kT,
  locale: DT,
  style: {
    prefix: "cc"
  },
  data: {
    groupMapsTo: "group",
    loading: !1,
    selectedGroups: []
  },
  color: {
    scale: null,
    pairing: {
      numberOfVariants: null,
      option: 1
    },
    gradient: {
      enabled: !1
    }
  },
  toolbar: {
    enabled: !0,
    numberOfIcons: 3,
    controls: [
      {
        type: _t.SHOW_AS_DATATABLE
      },
      ...Lm ? [
        {
          type: _t.MAKE_FULLSCREEN
        }
      ] : [],
      {
        type: _t.EXPORT_CSV
      },
      {
        type: _t.EXPORT_PNG
      },
      {
        type: _t.EXPORT_JPG
      }
    ]
  }
}, Dm = at({}, re, {
  thematic: {
    projection: gn.geoNaturalEarth1
  }
}), vs = at({}, re, {
  axes: Am,
  timeScale: io,
  grid: RT,
  ruler: IT,
  zoomBar: {
    zoomRatio: 0.4,
    minZoomRatio: 0.01,
    top: {
      enabled: !1,
      type: Ke.GRAPH_VIEW
    }
  }
}), sr = at({}, vs, {
  bars: {
    maxWidth: 16,
    spacingFactor: 0.25,
    preserveSpaceForMissingBars: !0
  },
  timeScale: at(io, {
    addSpaceOnEdges: 1
  })
}), NT = at({}, sr, {}), PT = at({}, sr, {}), UT = at({}, sr, {
  bars: at({}, sr.bars, {
    dividerSize: 1.5
  })
}), BT = at({}, sr, {}), Gc = at({}, vs, {
  points: {
    // default point radius to 4
    radius: 4,
    fillOpacity: 0.3,
    filled: !0,
    enabled: !0
  }
}), HT = Gc, km = at({}, Gc, {
  points: {
    // default point radius to 3
    radius: 3,
    filled: !1,
    enabled: !0
  }
}), Rm = at({}, km, {
  timeScale: at(io, {
    addSpaceOnEdges: 0
  })
}), VT = Rm, GT = at({}, vs, {
  bubble: {
    radiusMapsTo: "radius",
    radiusLabel: "Radius",
    radiusRange: (e) => {
      const t = Math.min(e.width, e.height);
      return [t * 3 / 400, t * 25 / 400];
    },
    fillOpacity: 0.2,
    enabled: !0
  },
  points: {
    filled: !0
  },
  legend: {
    additionalItems: [
      {
        type: Gt.RADIUS,
        name: "Radius"
      }
    ]
  }
}), zT = at({}, vs, {
  bullet: {
    performanceAreaTitles: ["Poor", "Satisfactory", "Great"]
  },
  grid: {
    x: {
      enabled: !1
    },
    y: {
      enabled: !1
    }
  },
  legend: {
    additionalItems: [
      {
        type: Gt.AREA,
        name: "Poor area"
      },
      {
        type: Gt.AREA,
        name: "Satisfactory area"
      },
      {
        type: Gt.AREA,
        name: "Great area"
      },
      {
        type: Gt.QUARTILE,
        name: "Quartiles"
      }
    ]
  }
}), FT = at({}, sr, {
  bars: {
    dividerSize: 1.5
  },
  timeScale: at(io, {
    addSpaceOnEdges: 0
  })
}), jT = at({}, re, {
  tooltip: at({}, Cm, {
    wordLabel: "Word",
    valueLabel: "Value"
  }),
  wordCloud: {
    fontSizeMapsTo: "value",
    fontSizeRange: (e) => {
      const t = Math.min(e.width, e.height);
      return [t * 20 / 400, t * 75 / 400];
    },
    wordMapsTo: "word"
  }
}), Im = at({}, re, {
  pie: {
    labels: {
      formatter: null,
      enabled: !0
    },
    alignment: jt.LEFT,
    sortFunction: null,
    valueMapsTo: "value"
  }
}), WT = at({}, re, {
  legend: {
    enabled: !1
  },
  gauge: {
    type: Ir.SEMI,
    arcWidth: 16,
    deltaArrow: {
      size: (e) => e / 8,
      enabled: !0
    },
    showPercentageSymbol: !0,
    status: null,
    numberSpacing: 10,
    deltaFontSize: (e) => e / 8,
    valueFontSize: (e) => e / 2.5,
    alignment: jt.LEFT
  }
}), qT = at({}, Im, {
  donut: {
    center: {
      numberFontSize: (e) => `${Math.min(e / 100 * 24, 24)}px`,
      titleFontSize: (e) => `${Math.min(e / 100 * 15, 15)}px`,
      titleYPosition: (e) => Math.min(e / 80 * 20, 20)
    },
    alignment: jt.LEFT
  }
}), Nm = at({}, re, {
  legend: {
    enabled: !1,
    clickable: !1
  },
  meter: {
    showLabels: !0,
    proportional: null,
    statusBar: {
      percentageIndicator: {
        enabled: !0
      }
    }
  }
}), YT = at({}, Nm, {
  legend: {
    enabled: !0
  }
}), XT = at({}, re, {
  radar: {
    axes: {
      angle: "key",
      value: "value"
    },
    alignment: jt.LEFT
  },
  tooltip: {
    gridline: {
      enabled: !0
    }
  }
}), ZT = at({}, sr, {
  comboChartTypes: []
}), KT = at(
  {
    tree: {
      type: dc.TREE
    }
  },
  re,
  {}
), QT = at({}, re, {
  data: at(re.data, {
    groupMapsTo: "name"
  })
}), JT = at({}, re, Ar, {
  data: at(re.data, {
    groupMapsTo: "name"
  })
}), tw = at({}, re, {
  alluvial: {
    data: at(re.data, {
      groupMapsTo: "source"
    }),
    nodeAlignment: jt.CENTER,
    nodePadding: 24,
    monochrome: !1,
    nodes: []
  }
}), ew = at({}, re, {
  axes: Am,
  heatmap: {
    divider: {
      state: Bi.AUTO
    },
    colorLegend: {
      type: "linear"
    }
  }
}), nw = at({}, Dm, {
  choropleth: {
    colorLegend: {
      type: "linear"
    }
  }
}), wt = {
  alluvialChart: tw,
  areaChart: Rm,
  axisChart: vs,
  boxplotChart: BT,
  bubbleChart: GT,
  bulletChart: zT,
  chart: re,
  circlePackChart: JT,
  choroplethChart: nw,
  comboChart: ZT,
  donutChart: qT,
  gaugeChart: WT,
  groupedBarChart: PT,
  heatmapChart: ew,
  histogramChart: FT,
  lineChart: km,
  lollipopChart: HT,
  meterChart: Nm,
  pieChart: Im,
  proportionalMeterChart: YT,
  radarChart: XT,
  scatterChart: Gc,
  simpleBarChart: NT,
  stackedAreaChart: VT,
  stackedBarChart: UT,
  thematicChart: Dm,
  treeChart: KT,
  treemapChart: QT,
  wordCloudChart: jT
};
function rw(e, t, n) {
  let r = null;
  return function(...i) {
    const s = this;
    s.mousePosition = rr(i[0], n), clearTimeout(r), r = setTimeout(function() {
      e.apply(s, i);
    }, t);
  };
}
function Rt(e, t) {
  const n = Sn(e), r = Object.keys(t.axes || {});
  t?.toolbar?.controls && delete n.toolbar.controls, r.length === 0 && delete n.axes;
  for (const i in n.axes)
    if (r.includes(i)) {
      const s = t.axes[i];
      if ((s.primary || s.secondary) && console.warn(
        "`primary` & `secondary` are no longer needed for axis configurations. Read more here https://charts.carbondesignsystem.com/"
      ), s.mapsTo == null) {
        const o = s.scaleType;
        o == null ? s.mapsTo = "value" : o === et.TIME ? s.mapsTo = "date" : o === et.LABELS && (s.mapsTo = "key");
      }
    } else
      delete n.axes[i];
  return zc(n, t), at(n, t);
}
function fn(e) {
  if (!e)
    return;
  const t = /translate\([0-9]+\.?[0-9]*,[0-9]+\.?[0-9]*\)/, n = e.getAttribute("transform").match(t);
  if (!n)
    return null;
  if (n[0]) {
    const r = n[0].replace(/translate\(/, "").replace(/\)/, "").split(",");
    return {
      tx: r[0],
      ty: r[1]
    };
  }
  return null;
}
function Ci(e) {
  const t = /\(([^)]+)\)/.exec(e);
  if (t && t.length > 1) {
    const n = t[1].split(",");
    if (n.length > 1)
      return {
        x: parseFloat(n[0]),
        y: parseFloat(n[1])
      };
  }
  return { x: 0, y: 0 };
}
function Ao(e, t, n = "value", r = !1) {
  const i = e / t.reduce((s, a) => s + a[n], 0) * 100;
  return r ? i : i % 1 !== 0 ? parseFloat(i.toFixed(1)) : i;
}
function rs(e, t, n) {
  if (n > e.length)
    return e;
  if (t === Ve.MID_LINE)
    return e.substr(0, n / 2) + "..." + e.substr(-n / 2);
  if (t === Ve.FRONT_LINE)
    return "..." + e.substr(-n);
  if (t === Ve.END_LINE)
    return e.substr(0, n) + "...";
}
function zc(e, t) {
  const n = y(e, "legend", "additionalItems"), r = y(t, "legend", "additionalItems");
  if (n && r) {
    const i = r.map((o) => o.type), s = n.map((o) => o.type), a = LT.filter(
      (o) => s.includes(o.type) && !i.includes(o.type)
    );
    e.legend.additionalItems = a, t.legend.additionalItems = U_(
      a,
      r,
      "name"
    );
  }
}
const y = (e, ...t) => {
  let n = e;
  if (n) {
    for (const r of t)
      if (n[r] !== null && n[r] !== void 0)
        n = n[r];
      else
        return null;
    return n;
  }
  return null;
}, Pm = (e, t) => t === Ft.HORIZONTAL ? {
  y0: e.x0,
  y1: e.x1,
  x0: e.y0,
  x1: e.y1
} : e, ae = (e, t) => {
  const { x0: n, x1: r, y0: i, y1: s } = Pm(e, t);
  return `M${n},${i}L${n},${s}L${r},${s}L${r},${i}L${n},${i}`;
};
function En(e, t, n) {
  return n === Ft.VERTICAL ? [e, t] : [t, e];
}
function Nh(e) {
  const t = Ht(e), n = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return n.setUTCFullYear(t.getFullYear()), +e - +n;
}
function Ph(e, t) {
  const n = Ht(e, t?.in);
  return n.setHours(0, 0, 0, 0), n;
}
function Um(e, t, n) {
  const [r, i] = ur(
    n?.in,
    e,
    t
  ), s = Ph(r), a = Ph(i), o = +s - Nh(s), l = +a - Nh(a);
  return Math.round((o - l) / m1);
}
function iw(e, t) {
  const n = Ht(e, t?.in);
  return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function sw(e, t) {
  const n = Ht(e, t?.in);
  return Um(n, iw(n)) + 1;
}
function ya(e, t) {
  return Yi(e, { ...t, weekStartsOn: 1 });
}
function Bm(e, t) {
  const n = Ht(e, t?.in), r = n.getFullYear(), i = Le(n, 0);
  i.setFullYear(r + 1, 0, 4), i.setHours(0, 0, 0, 0);
  const s = ya(i), a = Le(n, 0);
  a.setFullYear(r, 0, 4), a.setHours(0, 0, 0, 0);
  const o = ya(a);
  return n.getTime() >= s.getTime() ? r + 1 : n.getTime() >= o.getTime() ? r : r - 1;
}
function aw(e, t) {
  const n = Bm(e, t), r = Le(e, 0);
  return r.setFullYear(n, 0, 4), r.setHours(0, 0, 0, 0), ya(r);
}
function ow(e, t) {
  const n = Ht(e, t?.in), r = +ya(n) - +aw(n);
  return Math.round(r / lf) + 1;
}
function Hm(e, t) {
  const n = Ht(e, t?.in), r = n.getFullYear(), i = za(), s = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? i.firstWeekContainsDate ?? i.locale?.options?.firstWeekContainsDate ?? 1, a = Le(t?.in || e, 0);
  a.setFullYear(r + 1, 0, s), a.setHours(0, 0, 0, 0);
  const o = Yi(a, t), l = Le(t?.in || e, 0);
  l.setFullYear(r, 0, s), l.setHours(0, 0, 0, 0);
  const c = Yi(l, t);
  return +n >= +o ? r + 1 : +n >= +c ? r : r - 1;
}
function lw(e, t) {
  const n = za(), r = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? n.firstWeekContainsDate ?? n.locale?.options?.firstWeekContainsDate ?? 1, i = Hm(e, t), s = Le(t?.in || e, 0);
  return s.setFullYear(i, 0, r), s.setHours(0, 0, 0, 0), Yi(s, t);
}
function cw(e, t) {
  const n = Ht(e, t?.in), r = +Yi(n, t) - +lw(n, t);
  return Math.round(r / lf) + 1;
}
function Et(e, t) {
  const n = e < 0 ? "-" : "", r = Math.abs(e).toString().padStart(t, "0");
  return n + r;
}
const Rn = {
  // Year
  y(e, t) {
    const n = e.getFullYear(), r = n > 0 ? n : 1 - n;
    return Et(t === "yy" ? r % 100 : r, t.length);
  },
  // Month
  M(e, t) {
    const n = e.getMonth();
    return t === "M" ? String(n + 1) : Et(n + 1, 2);
  },
  // Day of the month
  d(e, t) {
    return Et(e.getDate(), t.length);
  },
  // AM or PM
  a(e, t) {
    const n = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(e, t) {
    return Et(e.getHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H(e, t) {
    return Et(e.getHours(), t.length);
  },
  // Minute
  m(e, t) {
    return Et(e.getMinutes(), t.length);
  },
  // Second
  s(e, t) {
    return Et(e.getSeconds(), t.length);
  },
  // Fraction of second
  S(e, t) {
    const n = t.length, r = e.getMilliseconds(), i = Math.trunc(
      r * Math.pow(10, n - 3)
    );
    return Et(i, t.length);
  }
}, Or = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, Uh = {
  // Era
  G: function(e, t, n) {
    const r = e.getFullYear() > 0 ? 1 : 0;
    switch (t) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return n.era(r, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return n.era(r, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return n.era(r, { width: "wide" });
    }
  },
  // Year
  y: function(e, t, n) {
    if (t === "yo") {
      const r = e.getFullYear(), i = r > 0 ? r : 1 - r;
      return n.ordinalNumber(i, { unit: "year" });
    }
    return Rn.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, n, r) {
    const i = Hm(e, r), s = i > 0 ? i : 1 - i;
    if (t === "YY") {
      const a = s % 100;
      return Et(a, 2);
    }
    return t === "Yo" ? n.ordinalNumber(s, { unit: "year" }) : Et(s, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    const n = Bm(e);
    return Et(n, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    const n = e.getFullYear();
    return Et(n, t.length);
  },
  // Quarter
  Q: function(e, t, n) {
    const r = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      // 1, 2, 3, 4
      case "Q":
        return String(r);
      // 01, 02, 03, 04
      case "QQ":
        return Et(r, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, n) {
    const r = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      // 1, 2, 3, 4
      case "q":
        return String(r);
      // 01, 02, 03, 04
      case "qq":
        return Et(r, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, n) {
    const r = e.getMonth();
    switch (t) {
      case "M":
      case "MM":
        return Rn.M(e, t);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return n.month(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return n.month(r, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return n.month(r, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(e, t, n) {
    const r = e.getMonth();
    switch (t) {
      // 1, 2, ..., 12
      case "L":
        return String(r + 1);
      // 01, 02, ..., 12
      case "LL":
        return Et(r + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return n.month(r, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return n.month(r, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return n.month(r, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(e, t, n, r) {
    const i = cw(e, r);
    return t === "wo" ? n.ordinalNumber(i, { unit: "week" }) : Et(i, t.length);
  },
  // ISO week of year
  I: function(e, t, n) {
    const r = ow(e);
    return t === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Et(r, t.length);
  },
  // Day of the month
  d: function(e, t, n) {
    return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : Rn.d(e, t);
  },
  // Day of year
  D: function(e, t, n) {
    const r = sw(e);
    return t === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Et(r, t.length);
  },
  // Day of week
  E: function(e, t, n) {
    const r = e.getDay();
    switch (t) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, n, r) {
    const i = e.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(s);
      // Padded numerical value
      case "ee":
        return Et(s, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return n.ordinalNumber(s, { unit: "day" });
      case "eee":
        return n.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return n.day(i, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return n.day(i, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return n.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, n, r) {
    const i = e.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      // Numerical value (same as in `e`)
      case "c":
        return String(s);
      // Padded numerical value
      case "cc":
        return Et(s, t.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return n.ordinalNumber(s, { unit: "day" });
      case "ccc":
        return n.day(i, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return n.day(i, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return n.day(i, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return n.day(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, n) {
    const r = e.getDay(), i = r === 0 ? 7 : r;
    switch (t) {
      // 2
      case "i":
        return String(i);
      // 02
      case "ii":
        return Et(i, t.length);
      // 2nd
      case "io":
        return n.ordinalNumber(i, { unit: "day" });
      // Tue
      case "iii":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, n) {
    const r = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, n) {
    const r = e.getHours();
    let i;
    switch (r === 12 ? i = Or.noon : r === 0 ? i = Or.midnight : i = r / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, n) {
    const r = e.getHours();
    let i;
    switch (r >= 17 ? i = Or.evening : r >= 12 ? i = Or.afternoon : r >= 4 ? i = Or.morning : i = Or.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, n) {
    if (t === "ho") {
      let r = e.getHours() % 12;
      return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" });
    }
    return Rn.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, n) {
    return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : Rn.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, n) {
    const r = e.getHours() % 12;
    return t === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Et(r, t.length);
  },
  // Hour [1-24]
  k: function(e, t, n) {
    let r = e.getHours();
    return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Et(r, t.length);
  },
  // Minute
  m: function(e, t, n) {
    return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : Rn.m(e, t);
  },
  // Second
  s: function(e, t, n) {
    return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : Rn.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return Rn.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, n) {
    const r = e.getTimezoneOffset();
    if (r === 0)
      return "Z";
    switch (t) {
      // Hours and optional minutes
      case "X":
        return Hh(r);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return Yn(r);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return Yn(r, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      // Hours and optional minutes
      case "x":
        return Hh(r);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return Yn(r);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return Yn(r, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + Bh(r, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + Yn(r, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + Bh(r, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + Yn(r, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, n) {
    const r = Math.trunc(+e / 1e3);
    return Et(r, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, n) {
    return Et(+e, t.length);
  }
};
function Bh(e, t = "") {
  const n = e > 0 ? "-" : "+", r = Math.abs(e), i = Math.trunc(r / 60), s = r % 60;
  return s === 0 ? n + String(i) : n + String(i) + t + Et(s, 2);
}
function Hh(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + Et(Math.abs(e) / 60, 2) : Yn(e, t);
}
function Yn(e, t = "") {
  const n = e > 0 ? "-" : "+", r = Math.abs(e), i = Et(Math.trunc(r / 60), 2), s = Et(r % 60, 2);
  return n + i + t + s;
}
const Vh = (e, t) => {
  switch (e) {
    case "P":
      return t.date({ width: "short" });
    case "PP":
      return t.date({ width: "medium" });
    case "PPP":
      return t.date({ width: "long" });
    case "PPPP":
    default:
      return t.date({ width: "full" });
  }
}, Vm = (e, t) => {
  switch (e) {
    case "p":
      return t.time({ width: "short" });
    case "pp":
      return t.time({ width: "medium" });
    case "ppp":
      return t.time({ width: "long" });
    case "pppp":
    default:
      return t.time({ width: "full" });
  }
}, uw = (e, t) => {
  const n = e.match(/(P+)(p+)?/) || [], r = n[1], i = n[2];
  if (!i)
    return Vh(e, t);
  let s;
  switch (r) {
    case "P":
      s = t.dateTime({ width: "short" });
      break;
    case "PP":
      s = t.dateTime({ width: "medium" });
      break;
    case "PPP":
      s = t.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      s = t.dateTime({ width: "full" });
      break;
  }
  return s.replace("{{date}}", Vh(r, t)).replace("{{time}}", Vm(i, t));
}, hw = {
  p: Vm,
  P: uw
}, dw = /^D+$/, pw = /^Y+$/, fw = ["D", "DD", "YY", "YYYY"];
function mw(e) {
  return dw.test(e);
}
function gw(e) {
  return pw.test(e);
}
function vw(e, t, n) {
  const r = yw(e, t, n);
  if (console.warn(r), fw.includes(e)) throw new RangeError(r);
}
function yw(e, t, n) {
  const r = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
function xw(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function bw(e) {
  return !(!xw(e) && typeof e != "number" || isNaN(+Ht(e)));
}
const _w = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, Ew = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Ow = /^'([^]*?)'?$/, Sw = /''/g, Tw = /[a-zA-Z]/;
function Al(e, t, n) {
  const r = za(), i = n?.locale ?? r.locale ?? hf, s = n?.firstWeekContainsDate ?? n?.locale?.options?.firstWeekContainsDate ?? r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1, a = n?.weekStartsOn ?? n?.locale?.options?.weekStartsOn ?? r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0, o = Ht(e, n?.in);
  if (!bw(o))
    throw new RangeError("Invalid time value");
  let l = t.match(Ew).map((u) => {
    const d = u[0];
    if (d === "p" || d === "P") {
      const h = hw[d];
      return h(u, i.formatLong);
    }
    return u;
  }).join("").match(_w).map((u) => {
    if (u === "''")
      return { isToken: !1, value: "'" };
    const d = u[0];
    if (d === "'")
      return { isToken: !1, value: ww(u) };
    if (Uh[d])
      return { isToken: !0, value: u };
    if (d.match(Tw))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + d + "`"
      );
    return { isToken: !1, value: u };
  });
  i.localize.preprocessor && (l = i.localize.preprocessor(o, l));
  const c = {
    firstWeekContainsDate: s,
    weekStartsOn: a,
    locale: i
  };
  return l.map((u) => {
    if (!u.isToken) return u.value;
    const d = u.value;
    (!n?.useAdditionalWeekYearTokens && gw(d) || !n?.useAdditionalDayOfYearTokens && mw(d)) && vw(d, t, String(e));
    const h = Uh[d[0]];
    return h(o, d, i.localize, c);
  }).join("");
}
function ww(e) {
  const t = e.match(Ow);
  return t ? t[1].replace(Sw, "'") : e;
}
const Lo = [
  ["15seconds", 15 * 1e3],
  ["minute", 60 * 1e3],
  ["30minutes", 1800 * 1e3],
  ["hourly", 3600 * 1e3],
  ["daily", 1440 * 60 * 1e3],
  ["monthly", 720 * 60 * 60 * 1e3],
  ["quarterly", 2160 * 60 * 60 * 1e3],
  ["yearly", 360 * 24 * 60 * 60 * 1e3]
];
function Gm(e, t, n, r, i) {
  const s = t === 0, a = Number(Al(new Date(e), "c")) === 2, o = Number(Al(new Date(e), "q")) === 1, l = t !== 0 ? n[t - 1] : null;
  switch (r) {
    case "15seconds":
      return s || Ls(e) || gi(e, l) || In(e);
    case "minute":
      return s || Ls(e) || gi(e, l) || In(e);
    case "30minutes":
      return s || Ls(e) || gi(e, l) || In(e);
    case "hourly":
      return s || Ls(e) || gi(e, l) || In(e);
    case "daily":
      return i ? s || a || In(e) : s || gi(e, l) || In(e);
    case "weekly":
      return s || a || In(e);
    case "monthly":
      return s || In(e);
    case "quarterly":
      return s || o;
    case "yearly":
      return !1;
    default:
      throw new Error(`${r} is not a valid time interval.`);
  }
}
function Ll(e, t, n, r, i, s) {
  const a = i.showDayName, o = r === "daily" && a ? "weekly" : r, l = new Date(e), c = y(i, "timeIntervalFormats")[o], u = y(c, "primary"), d = y(c, "secondary"), h = Gm(e, t, n, r, a);
  let p = h ? u : d;
  r === "15seconds" && l.getMilliseconds() !== 0 && (p = p.replace("pp", "h:mm:ss.SSS a"));
  const f = i.localeObject, { code: g, optionsObject: m } = s, v = m[r].type, b = m[r][h ? "primary" : "secondary"][p];
  if (r === "quarterly" || !b) {
    const _ = Al(l, p, { locale: f }).split("").map((E) => {
      const x = Number(E);
      return E !== " " && !Number.isNaN(x) ? x?.toLocaleString?.(g) : E;
    });
    return s[v](l, g, {}, _.join(""));
  } else
    return s[v](l, g, b);
}
function xa(e) {
  const t = new Date(e);
  return {
    M: t.getMonth() + 1,
    // month: 1-12
    d: t.getDate(),
    // day of the month: 1-31
    H: t.getHours(),
    // 24-hour clock: 0-23
    m: t.getMinutes(),
    // minute: 0-59
    s: t.getSeconds()
    // seconds: 0-59
  };
}
function $w(e) {
  if (e)
    return e.slice(1).map((t, n) => t - e[n]);
}
function Mw(e) {
  const t = Lo.reduce((n, [, r], i) => {
    const s = Lo[n][1], a = Math.abs(s - e), o = Math.abs(r - e);
    return a < o ? n : i;
  }, 0);
  return Lo[t][0];
}
function Dl(e, t) {
  if (of[t])
    return t;
  if (e.length === 1)
    return "15seconds";
  const n = $w(e), r = Bn(n);
  return Mw(r);
}
function Ls(e) {
  const { s: t, m: n, H: r } = xa(e);
  return r === 0 && n === 0 && t === 0;
}
function gi(e, t) {
  const n = xa(e).M, r = xa(t).M;
  return n !== r;
}
function In(e) {
  const { M: t, d: n, s: r, m: i, H: s } = xa(e);
  return t === 1 && n === 1 && s === 0 && i === 0 && r === 0;
}
function Gh(e) {
  return e === void 0 ? "" : e.toISOString();
}
function zm(e) {
  const t = ze(e, (r) => r.value), n = Fe().domain(t).nice().domain();
  if (n[0] > 0)
    n[0] = 0;
  else if (n[0] === 0 && n[1] === 0)
    return [0, 1];
  return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;
}
function Fm(e, t) {
  const n = y(t, "gradient", "colors"), r = !Be(n);
  let i = y(t, "pairing", "option");
  const s = zm(e), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";
  (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);
  const o = r ? n : [];
  if (!r) {
    const l = a === "diverge" ? 17 : 11;
    for (let c = 1; c < l + 1; c++)
      o.push(`fill-${a}-${i}-${c}`);
  }
  return Vc().domain(s).range(o);
}
var ht = /* @__PURE__ */ ((e) => (e.GRAPHICS_DOCUMENT = "graphics-document", e.GRAPHICS_OBJECT = "graphics-object", e.GRAPHICS_SYMBOL = "graphics-symbol", e.GROUP = "group", e.DOCUMENT = "document", e.CHECKBOX = "checkbox", e.BUTTON = "button", e.MENU = "menu", e.MENU_ITEM = "menuitem", e.IMG = "img", e))(ht || {});
function Cw(e, t) {
  return e && zf(e, t, us);
}
function Aw(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!fr(n))
      return e(n, r);
    for (var i = n.length, s = -1, a = Object(n); ++s < i && r(a[s], s, a) !== !1; )
      ;
    return n;
  };
}
var Fc = Aw(Cw);
function dt(e) {
  return function() {
    return e;
  };
}
var Lw = Array.prototype.slice;
function so(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Dw(e, t, n, r) {
  for (var i = -1, s = e == null ? 0 : e.length; ++i < s; ) {
    var a = e[i];
    t(r, a, n(a), e);
  }
  return r;
}
function kw(e, t, n, r) {
  return Fc(e, function(i, s, a) {
    t(r, i, n(i), a);
  }), r;
}
function Rw(e, t) {
  return function(n, r) {
    var i = Kt(n) ? Dw : kw, s = {};
    return i(n, e, Ja(r), s);
  };
}
function Iw(e) {
  for (var t = -1, n = e == null ? 0 : e.length, r = {}; ++t < n; ) {
    var i = e[t];
    r[i[0]] = i[1];
  }
  return r;
}
var Nw = Object.prototype, Pw = Nw.hasOwnProperty, Uw = Rw(function(e, t, n) {
  Pw.call(e, n) ? e[n].push(t) : ja(e, n, [t]);
});
function Bw(e, t) {
  let n = 0;
  for (let r of e)
    r != null && (r = +r) >= r && ++n;
  return n;
}
function Hw(e) {
  return e;
}
function Vw(e = Jn) {
  if (e === Jn) return jm;
  if (typeof e != "function") throw new TypeError("compare is not a function");
  return (t, n) => {
    const r = e(t, n);
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function jm(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
var Gw = Array.prototype, zw = Gw.slice;
function Do(e) {
  return () => e;
}
function Fw(e, t, n) {
  let r;
  for (; ; ) {
    const i = Xr(e, t, n);
    if (i === r || i === 0 || !isFinite(i))
      return [e, t];
    i > 0 ? (e = Math.floor(e / i) * i, t = Math.ceil(t / i) * i) : i < 0 && (e = Math.ceil(e * i) / i, t = Math.floor(t * i) / i), r = i;
  }
}
function jw(e) {
  return Math.max(1, Math.ceil(Math.log(Bw(e)) / Math.LN2) + 1);
}
function Ww() {
  var e = Hw, t = ze, n = jw;
  function r(i) {
    Array.isArray(i) || (i = Array.from(i));
    var s, a = i.length, o, l, c = new Array(a);
    for (s = 0; s < a; ++s)
      c[s] = e(i[s], s, i);
    var u = t(c), d = u[0], h = u[1], p = n(c, d, h);
    if (!Array.isArray(p)) {
      const _ = h, E = +p;
      if (t === ze && ([d, h] = Fw(d, h, E)), p = ca(d, h, E), p[0] <= d && (l = Xr(d, h, E)), p[p.length - 1] >= h)
        if (_ >= h && t === ze) {
          const x = Xr(d, h, E);
          isFinite(x) && (x > 0 ? h = (Math.floor(h / x) + 1) * x : x < 0 && (h = (Math.ceil(h * -x) + 1) / -x));
        } else
          p.pop();
    }
    for (var f = p.length, g = 0, m = f; p[g] <= d; ) ++g;
    for (; p[m - 1] > h; ) --m;
    (g || m < f) && (p = p.slice(g, m), f = m - g);
    var v = new Array(f + 1), b;
    for (s = 0; s <= f; ++s)
      b = v[s] = [], b.x0 = s > 0 ? p[s - 1] : d, b.x1 = s < f ? p[s] : h;
    if (isFinite(l)) {
      if (l > 0)
        for (s = 0; s < a; ++s)
          (o = c[s]) != null && d <= o && o <= h && v[Math.min(f, Math.floor((o - d) / l))].push(i[s]);
      else if (l < 0) {
        for (s = 0; s < a; ++s)
          if ((o = c[s]) != null && d <= o && o <= h) {
            const _ = Math.floor((d - o) * l);
            v[Math.min(f, _ + (p[_] <= o))].push(i[s]);
          }
      }
    } else
      for (s = 0; s < a; ++s)
        (o = c[s]) != null && d <= o && o <= h && v[Cc(p, o, 0, f)].push(i[s]);
    return v;
  }
  return r.value = function(i) {
    return arguments.length ? (e = typeof i == "function" ? i : Do(i), r) : e;
  }, r.domain = function(i) {
    return arguments.length ? (t = typeof i == "function" ? i : Do([i[0], i[1]]), r) : t;
  }, r.thresholds = function(i) {
    return arguments.length ? (n = typeof i == "function" ? i : Do(Array.isArray(i) ? zw.call(i) : i), r) : n;
  }, r;
}
function Wm(e, t, n = 0, r = 1 / 0, i) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r)) return e;
  for (i = i === void 0 ? jm : Vw(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, c = t - n + 1, u = Math.log(l), d = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * d * (l - d) / l) * (c - l / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(t - c * d / l + h)), f = Math.min(r, Math.floor(t + (l - c) * d / l + h));
      Wm(e, t, p, f, i);
    }
    const s = e[t];
    let a = n, o = r;
    for (vi(e, n, t), i(e[r], s) > 0 && vi(e, n, r); a < o; ) {
      for (vi(e, a, o), ++a, --o; i(e[a], s) < 0; ) ++a;
      for (; i(e[o], s) > 0; ) --o;
    }
    i(e[n], s) === 0 ? vi(e, n, o) : (++o, vi(e, o, r)), o <= t && (n = o + 1), t <= o && (r = o - 1);
  }
  return e;
}
function vi(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function ko(e, t, n) {
  if (e = Float64Array.from(G_(e)), !(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2) return Bn(e);
    if (t >= 1) return nr(e);
    var r, i = (r - 1) * t, s = Math.floor(i), a = nr(Wm(e, s).subarray(0, s + 1)), o = Bn(e.subarray(s + 1));
    return a + (o - a) * (i - s);
  }
}
function zh(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, s = e[t[0]], a, o = s.length; n < a; ++n)
      for (i = s, s = e[t[n]], r = 0; r < o; ++r)
        s[r][1] += s[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function Fh(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; ) n[t] = t;
  return n;
}
function qw(e, t) {
  return e[t];
}
function Yw(e) {
  const t = [];
  return t.key = e, t;
}
function Ro() {
  var e = dt([]), t = Fh, n = zh, r = qw;
  function i(s) {
    var a = Array.from(e.apply(this, arguments), Yw), o, l = a.length, c = -1, u;
    for (const d of s)
      for (o = 0, ++c; o < l; ++o)
        (a[o][c] = [0, +r(d, a[o].key, c, s)]).data = d;
    for (o = 0, u = so(t(a)); o < l; ++o)
      a[u[o]].index = o;
    return n(a, u), a;
  }
  return i.keys = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : dt(Array.from(s)), i) : e;
  }, i.value = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : dt(+s), i) : r;
  }, i.order = function(s) {
    return arguments.length ? (t = s == null ? Fh : typeof s == "function" ? s : dt(Array.from(s)), i) : t;
  }, i.offset = function(s) {
    return arguments.length ? (n = s ?? zh, i) : n;
  }, i;
}
function Xw(e, t) {
  if ((l = e.length) > 0)
    for (var n, r = 0, i, s, a, o, l, c = e[t[0]].length; r < c; ++r)
      for (a = o = 0, n = 0; n < l; ++n)
        (s = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = a, i[1] = a += s) : s < 0 ? (i[1] = o, i[0] = o += s) : (i[0] = 0, i[1] = s);
}
function Zw(e) {
  const t = e.trim();
  return ["=", "+", "-", "@", "	", "\r"].includes(t.charAt(0)) ? `${t}` : /[,\"\n]/.test(t) ? `"${t}"` : t;
}
class an {
  constructor(t) {
    this.state = {
      options: {}
    }, this.colorScale = {}, this.colorClassNames = {}, this.services = t;
  }
  formatTable({ headers: t, cells: n }) {
    const r = this.getOptions(), {
      code: i,
      date: s,
      number: a
    } = y(r, "locale"), o = y(r, "tabularRepModal", "tableHeadingFormatter"), l = y(r, "tabularRepModal", "tableCellFormatter"), { cartesianScales: c } = this.services, u = c?.getDomainAxisScaleType();
    let d;
    return u === et.TIME && (d = (h) => s(h, i, { month: "short", day: "numeric", year: "numeric" })), [
      typeof o == "function" ? o(t) : t,
      ...typeof l == "function" ? l(n) : n.map((h) => {
        d && (h[1] = d(h[1]));
        for (const p in h) {
          const f = h[p];
          typeof f == "number" && (h[p] = a(f, i));
        }
        return h;
      })
    ];
  }
  getAllDataFromDomain(t) {
    if (!this.getData())
      return null;
    const n = this.getOptions();
    let r = this.getData();
    const i = this.getDataGroups(), { groupMapsTo: s } = y(n, "data"), a = y(n, "axes");
    return t && (r = r.filter((o) => t.includes(o[s]))), a && Object.keys(a).forEach((o) => {
      const l = a[o].mapsTo, c = a[o].scaleType;
      if ((c === et.LINEAR || c === et.LOG) && (r = r.map((u) => ({
        ...u,
        [l]: u[l] === null ? u[l] : Number(u[l])
      }))), l && a[o].domain)
        if (c === et.LABELS)
          r = r.filter(
            (u) => a[o].domain.includes(u[l])
          );
        else {
          const [u, d] = a[o].domain;
          r = r.filter(
            (h) => !(l in h) || h[l] >= u && h[l] <= d
          );
        }
    }), r.filter((o) => i.find((l) => l.name === o[s]));
  }
  /**
   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart
   * @param groups the included datasets for the particular chart
   */
  getDisplayData(t) {
    if (!this.get("data"))
      return null;
    const { ACTIVE: n } = It.items.status, r = this.getDataGroups(t), { groupMapsTo: i } = this.getOptions().data;
    return this.getAllDataFromDomain(t).filter((s) => r.find(
      (a) => a.name === s[i] && a.status === n
    ));
  }
  getData() {
    return this.get("data");
  }
  isDataEmpty() {
    return !this.getData().length;
  }
  /**
   * Sets the data for the current instance.
   *
   * This method sanitizes the provided data, generates data groups,
   * and updates the instance's state with the sanitized data and data groups.
   *
   * @param {any} newData - The new data to be set. This data will be cloned and sanitized.
   * @returns {any} - The sanitized version of the provided data.
   */
  setData(t) {
    const n = this.sanitize(Sn(t)), r = this.generateDataGroups(n);
    return this.set({
      data: n,
      dataGroups: r
    }), n;
  }
  getDataGroups(t) {
    return y(this.getOptions(), "data", "loading") ? [] : t ? this.get("dataGroups").filter((n) => t.includes(n.name)) : this.get("dataGroups");
  }
  getActiveDataGroups(t) {
    const { ACTIVE: n } = It.items.status;
    return this.getDataGroups(t).filter((r) => r.status === n);
  }
  getDataGroupNames(t) {
    return this.getDataGroups(t).map((n) => n.name);
  }
  getActiveDataGroupNames(t) {
    return this.getActiveDataGroups(t).map((n) => n.name);
  }
  aggregateBinDataByGroup(t) {
    return Uw(t, "group");
  }
  getBinConfigurations() {
    const t = this.getDisplayData(), n = this.getOptions(), r = this.services.cartesianScales.getMainXAxisPosition(), i = this.services.cartesianScales.getDomainIdentifier(), s = n.axes[r], { groupMapsTo: a } = n.data, { bins: o = AT.defaultBins } = s, l = Array.isArray(o), c = Ww().value((p) => p[i]).thresholds(o)(t);
    if (l)
      c[c.length - 1].x1 = o[o.length - 1];
    else {
      const p = c[0].x1 - c[0].x0;
      c[c.length - 1].x1 = +c[c.length - 1].x0 + p;
    }
    const u = l ? [o[0], o[o.length - 1]] : [c[0].x0, c[c.length - 1].x1], d = Array.from(new Set(t.map((p) => p[a]))), h = [];
    return c.forEach((p) => {
      const f = `${p.x0}-${p.x1}`, g = this.aggregateBinDataByGroup(p);
      d.forEach((m) => {
        h.push({
          group: m,
          key: f,
          value: g[m] || 0,
          bin: p.x0
        });
      });
    }), {
      bins: c,
      binsDomain: u
    };
  }
  getBinnedStackedData() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getActiveDataGroupNames(), { bins: i } = this.getBinConfigurations(), s = this.getDataValuesGroupedByKeys({
      bins: i
    });
    return Ro().keys(r)(s).map((a, o) => Object.keys(a).filter((l) => !isNaN(l)).map((l) => {
      const c = a[l];
      return c[n] = r[o], c;
    }));
  }
  getGroupedData(t) {
    const n = this.getDisplayData(t), r = {}, { groupMapsTo: i } = this.getOptions().data;
    return n.map((s) => {
      const a = s[i];
      r[a] !== null && r[a] !== void 0 ? r[a].push(s) : r[a] = [s];
    }), Object.keys(r).map((s) => ({
      name: s,
      data: r[s]
    }));
  }
  getStackKeys({ bins: t = null, groups: n = null } = { bins: null, groups: null }) {
    const r = this.getOptions(), i = this.getDisplayData(n);
    let s;
    t ? s = t.map((l) => `${l.x0}:${l.x1}`) : s = Qi(
      i.map((l) => {
        const c = this.services.cartesianScales.getDomainIdentifier(l);
        return l[c] instanceof Date ? Gh(l[c]) : l[c] && typeof l[c].toString == "function" ? l[c].toString() : l[c];
      })
    );
    const a = this.services.cartesianScales.domainAxisPosition, o = r.axes[a].scaleType;
    return o === et.TIME ? s.sort((l, c) => {
      const u = new Date(l), d = new Date(c);
      return u - d;
    }) : (o === et.LOG || o === et.LINEAR) && s.sort((l, c) => l - c), s;
  }
  getDataValuesGroupedByKeys({ bins: t = null, groups: n = null }) {
    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.getDisplayData(n), a = this.getDataGroupNames(), o = this.getStackKeys({ bins: t, groups: n });
    return t ? o.map((l) => {
      const [c, u] = l.split(":"), d = { x0: c, x1: u }, h = t.find((p) => p.x0.toString() === c.toString());
      return a.forEach((p) => {
        d[p] = h.filter(
          (f) => f[i] === p
        ).length;
      }), d;
    }) : o.map((l) => {
      const c = { sharedStackKey: l };
      return a.forEach((u) => {
        const d = s.find((p) => {
          const f = this.services.cartesianScales.getDomainIdentifier(p);
          return p[i] === u && Object.prototype.hasOwnProperty.call(p, f) && (p[f] instanceof Date ? Gh(p[f]) === l : p[f].toString() === l);
        }), h = this.services.cartesianScales.getRangeIdentifier(c);
        c[u] = d ? d[h] : null;
      }), c;
    });
  }
  getStackedData({ percentage: t = !1, groups: n = null, divergent: r = !1 }) {
    const i = this.getOptions(), { groupMapsTo: s } = i.data, a = this.getActiveDataGroupNames(n), o = this.getDataValuesGroupedByKeys({
      groups: n
    });
    if (t) {
      const l = Iw(o.map((c) => [c.sharedStackKey, 0]));
      o.forEach((c) => {
        a.forEach((u) => {
          l[c.sharedStackKey] += c[u];
        });
      }), o.forEach((c) => {
        a.forEach((u) => {
          const d = l[c.sharedStackKey];
          l[c.sharedStackKey] ? c[u] = c[u] / d * 100 : c[u] = 0;
        });
      });
    }
    return (r ? Ro().offset(Xw) : Ro()).keys(a)(o).map((l, c) => Object.keys(l).filter((u) => !isNaN(u)).map((u) => {
      const d = l[u];
      return d[s] = a[c], d;
    }));
  }
  /**
   * Retrieves the current options from the instance's state.
   *
   * @returns {any} - The current options stored in the instance's state.
   */
  getOptions() {
    return this.state.options;
  }
  set(t, n) {
    this.state = Object.assign({}, this.state, t);
    const r = Object.assign(
      { skipUpdate: !1, animate: !0 },
      // default configs
      n
    );
    r.skipUpdate || this.update(r.animate);
  }
  get(t) {
    return t ? this.state[t] : this.state;
  }
  /**
   * Updates the current options for the instance.
   *
   * This method retrieves the existing options, updates the legend additional items,
   * and merges the new options with the existing ones. The instance's state is then updated
   * with the merged options.
   *
   * @param {any} newOptions - The new options to be set. These options will be merged with the existing options.
   */
  setOptions(t) {
    const n = this.getOptions();
    zc(n, t), this.set({
      options: at(n, t)
    });
  }
  /**
   *
   * Updates miscellanous information within the model
   * such as the color scales, or the legend data labels
   */
  update(t = !0) {
    this.getDisplayData() && (this.updateAllDataGroups(), this.setCustomColorScale(), this.setColorClassNames(), this.services.events.dispatchEvent(T.Model.UPDATE, { animate: t }));
  }
  /*
   * Data labels
   */
  toggleDataLabel(t) {
    const { ACTIVE: n, DISABLED: r } = It.items.status, i = this.getDataGroups(), s = i.some((c) => c.status === r), a = i.filter((c) => c.status === n);
    if (s)
      if (a.length === 1 && a[0].name === t)
        i.forEach((c, u) => {
          i[u].status = n;
        });
      else {
        const c = i.findIndex((u) => u.name === t);
        i[c].status = i[c].status === r ? n : r;
      }
    else
      i.forEach((c, u) => {
        i[u].status = c.name === t ? n : r;
      });
    const o = i.filter((c) => c.status === n), l = this.getOptions();
    i.some((c) => c.status === r) ? l.data.selectedGroups = o.map((c) => c.name) : l.data.selectedGroups = [], this.services.events.dispatchEvent(T.Legend.ITEMS_UPDATE, {
      dataGroups: i
    }), this.set({
      dataGroups: i
    });
  }
  /**
   * Should the data point be filled?
   * @param group
   * @param key
   * @param data
   * @param defaultFilled the default for this chart
   */
  getIsFilled(t, n, r, i) {
    const s = this.getOptions();
    return s.getIsFilled ? s.getIsFilled(t, n, r, i) : i;
  }
  getFillColor(t, n, r) {
    const i = this.getOptions(), s = y(this.colorScale, t);
    return i.getFillColor ? i.getFillColor(t, n, r, s) : s;
  }
  getStrokeColor(t, n, r) {
    const i = this.getOptions(), s = y(this.colorScale, t);
    return i.getStrokeColor ? i.getStrokeColor(t, n, r, s) : s;
  }
  isUserProvidedColorScaleValid() {
    const t = y(this.getOptions(), "color", "scale"), n = this.getDataGroups();
    return t == null || Object.keys(t).length == 0 ? !1 : n.some(
      (r) => Object.keys(t).includes(r.name)
    );
  }
  getColorClassName(t) {
    const n = this.colorClassNames(t.dataGroupName);
    let r = t.originalClassName;
    return t.classNameTypes.forEach(
      (i) => r = t.originalClassName ? `${r} ${i}-${n}` : `${i}-${n}`
    ), r || "";
  }
  /**
   * For charts that might hold an associated status for their dataset
   */
  getStatus() {
    return null;
  }
  getAllDataGroupsNames() {
    return this.allDataGroups;
  }
  /**
   * Converts data provided in the older format to tabular
   *
   */
  transformToTabularData(t) {
    console.warn(
      "We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://charts.carbondesignsystem.com/"
    );
    const n = [], { datasets: r, labels: i } = t;
    return r.forEach((s) => {
      s.data.forEach((a, o) => {
        let l;
        const c = y(s, "label");
        if (c === null) {
          const d = y(i, o);
          d ? l = d : l = "Ungrouped";
        } else
          l = c;
        const u = {
          group: l,
          key: i[o]
        };
        isNaN(a) ? (u.value = a.value, u.date = a.date) : u.value = a, n.push(u);
      });
    }), n;
  }
  getTabularDataArray() {
    return [];
  }
  exportToCSV() {
    const t = this.getTabularDataArray().map(
      (s) => s.map((a) => `"${(a === "&ndash;" ? "" : a).split(/[,;'"`]/).map((o) => Zw(o)).join("")}"`)
    ).map((s) => s.join(",")).join(`
`), n = this.getOptions();
    let r = "myChart";
    const i = y(n, "fileDownload", "fileName");
    typeof i == "function" ? r = i("csv") : typeof i == "string" && (r = i), this.services.files.downloadCSV(t, `${r}.csv`);
  }
  getTabularData(t) {
    return Array.isArray(t) ? t : this.transformToTabularData(t);
  }
  sanitize(t) {
    return t = this.getTabularData(t), t;
  }
  /*
   * Data groups
   */
  updateAllDataGroups() {
    this.allDataGroups ? this.getDataGroupNames().forEach((t) => {
      this.allDataGroups.indexOf(t) === -1 && this.allDataGroups.push(t);
    }) : this.allDataGroups = this.getDataGroupNames();
  }
  generateDataGroups(t) {
    const { groupMapsTo: n } = this.getOptions().data, { ACTIVE: r, DISABLED: i } = It.items.status, s = this.getOptions(), a = Qi(t.map((l) => l[n]));
    s.data.selectedGroups.length && (s.data.selectedGroups.every(
      (l) => a.includes(l)
    ) || (s.data.selectedGroups = []));
    const o = (l) => !s.data.selectedGroups.length || s.data.selectedGroups.includes(l) ? r : i;
    return a.map((l) => ({
      name: l,
      status: o(l)
    }));
  }
  /*
   * Fill scales
   */
  setCustomColorScale() {
    if (!this.isUserProvidedColorScaleValid())
      return;
    const t = this.getOptions(), n = y(t, "color", "scale");
    Object.keys(n).forEach((r) => {
      this.allDataGroups.includes(r) || console.warn(`"${r}" does not exist in data groups.`);
    }), this.allDataGroups.filter((r) => n[r]).forEach(
      (r) => this.colorScale[r] = n[r]
    );
  }
  /*
   * Color palette
   */
  setColorClassNames() {
    const t = y(this.getOptions(), "color", "pairing");
    let n = y(t, "numberOfVariants");
    (!n || n < this.allDataGroups.length) && (n = this.allDataGroups.length);
    let r = y(t, "option");
    const i = $m.pairingOptions, s = n > 5 ? 14 : n, a = `${s}-color`;
    r = r <= i[a] ? r : 1;
    const o = this.allDataGroups.map(
      (l, c) => `${s}-${r}-${c % 14 + 1}`
    );
    this.colorClassNames = ro().range(o).domain(this.allDataGroups);
  }
}
class mr extends an {
  // can't be protected as it's used by two-dimensional-axes.ts
  constructor(t) {
    super(t), this.axisFlavor = Ga.DEFAULT;
  }
  // get the scales information
  // needed for getTabularArray()
  assignRangeAndDomains() {
    const { cartesianScales: t } = this.services, n = this.getOptions(), r = t.isDualAxes(), i = {
      primaryDomain: t.domainAxisPosition,
      primaryRange: t.rangeAxisPosition,
      secondaryDomain: null,
      secondaryRange: null
    };
    return r && (i.secondaryDomain = t.secondaryDomainAxisPosition, i.secondaryRange = t.secondaryRangeAxisPosition), Object.keys(i).forEach(
      (s) => {
        const a = i[s];
        t.scales[a] ? i[s] = {
          position: a,
          label: t.getScaleLabel(a),
          identifier: y(n, "axes", a, "mapsTo")
        } : i[s] = null;
      }
    ), i;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { primaryDomain: i, primaryRange: s, secondaryDomain: a, secondaryRange: o } = this.assignRangeAndDomains(), { number: l, code: c } = y(this.getOptions(), "locale"), u = [
      "Group",
      i.label,
      s.label,
      ...a ? [a.label] : [],
      ...o ? [o.label] : []
    ], d = t.map((h) => [
      h[r],
      h[i.identifier] === null ? "&ndash;" : h[i.identifier],
      h[s.identifier] === null || isNaN(h[s.identifier]) ? "&ndash;" : l(h[s.identifier], c),
      ...a ? [
        h[a.identifier] === null ? "&ndash;" : h[a.identifier]
      ] : [],
      ...o ? [
        h[o.identifier] === null || isNaN(h[o.identifier]) ? "&ndash;" : h[o.identifier]
      ] : []
    ]);
    return super.formatTable({ headers: u, cells: d });
  }
  setData(t) {
    let n;
    if (t && (n = super.setData(t), y(this.getOptions(), "zoomBar", G.TOP, "enabled"))) {
      const r = y(
        this.getOptions(),
        "zoomBar",
        G.TOP,
        "data"
      );
      this.setZoomBarData(r);
    }
    return n;
  }
  /**
   * Sets the zoom bar data for the current instance.
   *
   * This method sanitizes the provided zoom bar data or uses the display data if no explicit
   * zoom data is provided. It normalizes the zoom bar data by aggregating values based on unique
   * dates and updates the instance's state with the normalized data.
   *
   * @param {any} [newZoomBarData] - The new zoom bar data to be set. If not provided, the display data will be used.
   */
  setZoomBarData(t) {
    const n = t ? this.sanitize(Sn(t)) : this.getDisplayData();
    let r = n;
    const { cartesianScales: i } = this.services;
    if (n && i.domainAxisPosition && i.rangeAxisPosition) {
      const s = i.getDomainIdentifier(), a = i.getRangeIdentifier();
      let o = n.map((l) => l[s].getTime());
      o = Qi(o).sort(), r = o.map((l) => {
        let c = 0;
        const u = {};
        return n.forEach((d) => {
          d[s].getTime() === l && (c += d[a]);
        }), u[s] = new Date(l), u[a] = c, u;
      });
    }
    this.set({ zoomBarData: r });
  }
  getZoomBarData() {
    return this.get("zoomBarData");
  }
  sanitizeDateValues(t) {
    const n = this.getOptions();
    if (!n.axes)
      return t;
    const r = [];
    return Object.keys(G).forEach((i) => {
      const s = G[i], a = n.axes[s];
      if (a && a.scaleType === et.TIME) {
        const o = a.mapsTo;
        (o !== null || o !== void 0) && r.push(o);
      }
    }), r.length > 0 && t.forEach((i) => {
      r.forEach((s) => {
        y(i, s, "getTime") === null && (i[s] = new Date(i[s]));
      });
    }), t;
  }
  sanitize(t) {
    return t = super.sanitize(t), t = this.sanitizeDateValues(t), t;
  }
}
let Kw = class extends mr {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale");
    t.sort((a, o) => a.source.localeCompare(o.source));
    const i = ["Source", "Target", "Value"], s = [
      ...t.map((a) => [
        a.source,
        a.target,
        a.value === null ? "&ndash;" : n(a.value, r)
      ])
    ];
    return super.formatTable({ headers: i, cells: s });
  }
}, Qw = class extends mr {
  constructor(t) {
    super(t);
  }
  getBoxQuartiles(t) {
    return {
      q_25: ko(t, 0.25),
      q_50: ko(t, 0.5),
      q_75: ko(t, 0.75)
    };
  }
  getBoxplotData() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getGroupedData(), i = [];
    for (const { name: s, data: a } of r) {
      const o = this.services.cartesianScales.getRangeIdentifier(), l = a.map((_) => _[o]).sort(Jn), c = {
        [n]: s,
        counts: l,
        quartiles: this.getBoxQuartiles(l),
        outliers: null,
        whiskers: null
      }, u = c.quartiles.q_25, d = c.quartiles.q_75, h = (d - u) * 1.5, p = u - h, f = d + h, g = [], m = [];
      for (const _ of l)
        _ < p || _ > f ? g.push(_) : m.push(_);
      c.outliers = g;
      const v = Bn(m), b = nr(m);
      c.whiskers = {
        min: v || Bn([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75]),
        max: b || nr([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75])
      }, i.push(c);
    }
    return i;
  }
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getBoxplotData(), { number: i, code: s } = y(t, "locale"), a = ["Group", "Minimum", "Q1", "Median", "Q3", "Maximum", "IQR", "Outlier(s)"], o = [
      ...r.map((l) => {
        let c = y(l, "outliers");
        return (c === null || c.length === 0) && (c = ["&ndash;"]), [
          l[n],
          y(l, "whiskers", "min") !== null ? i(y(l, "whiskers", "min"), s) : "&ndash;",
          y(l, "quartiles", "q_25") !== null ? i(y(l, "quartiles", "q_25"), s) : "&ndash;",
          y(l, "quartiles", "q_50") !== null ? i(y(l, "quartiles", "q_50"), s) : "&ndash;",
          y(l, "quartiles", "q_75") !== null ? i(y(l, "quartiles", "q_75"), s) : "&ndash;",
          y(l, "whiskers", "max") !== null ? i(y(l, "whiskers", "max"), s) : "&ndash;",
          y(l, "quartiles", "q_75") !== null && y(l, "quartiles", "q_25") !== null ? (i(
            y(l, "quartiles", "q_75") - y(l, "quartiles", "q_25")
          ), s) : "&ndash;",
          c.map((u) => i(u, s)).join(",")
        ];
      })
    ];
    return super.formatTable({ headers: a, cells: o });
  }
  setColorClassNames() {
    const t = y(this.getOptions(), "color", "pairing");
    let n = y(t, "option");
    const r = $m.pairingOptions;
    n = n <= r["1-color"] ? n : 1;
    const i = this.allDataGroups.map(() => `1-${n}-1`);
    this.colorClassNames = ro().range(i).domain(this.allDataGroups);
  }
}, Jw = class extends mr {
  constructor(t) {
    super(t);
  }
  /**
   * Determines the index of the performance area titles to use
   * @param datum
   * @returns number
   */
  getMatchingRangeIndexForDatapoint(t) {
    let n;
    for (let r = t.ranges.length - 1; r > 0; r--) {
      const i = t.ranges[r];
      if (t.value >= i)
        return n = r, n;
    }
    return 0;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), { number: s, code: a } = y(n, "locale"), o = y(n, "bullet", "performanceAreaTitles"), l = ["Title", "Group", "Value", "Target", "Percentage", "Performance"], c = [
      ...t.map((u) => [
        u.title,
        u[r],
        u.value === null ? "&ndash;" : s(u.value, a),
        y(u, "marker") === null ? "&ndash;" : s(u.marker, a),
        y(u, "marker") === null ? "&ndash;" : `${s(Math.floor(u[i] / u.marker * 100), a)}%`,
        o[this.getMatchingRangeIndexForDatapoint(u)]
      ])
    ];
    return super.formatTable({ headers: l, cells: c });
  }
}, t$ = class extends an {
  constructor(t) {
    super(t), this._colorScale = void 0, this._matrix = {};
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Helper function that will generate a dictionary
   */
  getCombinedData() {
    if (Be(this._matrix)) {
      const t = this.getOptions(), n = this.getDisplayData();
      !Be(n) && !Be(t.geoData.objects.countries) && (t.geoData.objects.countries.geometries.forEach((r) => {
        this._matrix[r.properties.NAME] = r;
      }), n.forEach((r) => {
        this._matrix[r.name] ? this._matrix[r.name].value = r.value || null : console.warn(`Data point ${r} is missing geographical data.`);
      }));
    }
    return this._matrix;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale"), i = ["Country ID", "Country Name", "Value"], s = [
      ...t.map((a) => [
        a.id === null ? "&ndash;" : a.id,
        a.name,
        a.value === null ? "&ndash;" : n(a.value, r)
      ])
    ];
    return super.formatTable({ headers: i, cells: s });
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName || ""} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = y(this.getOptions(), "color");
    this._colorScale = Fm(this.getDisplayData(), t);
  }
}, e$ = class extends an {
  constructor(t) {
    super(t), this.parentNode = !1, this.set({ depth: 2 }, { skipUpdate: !0 });
  }
  setData(t) {
    super.setData(t), this.setDataGroups(), t.length === 1 && (this.parentNode = !0), this.setZoom();
  }
  setOptions(t) {
    const n = this.getOptions(), r = at({}, t, this.getZoomOptions(t));
    zc(n, r);
    const i = this.getHierarchyLevel(), s = y(n, "circlePack", "depth");
    this.set({
      options: at(n, r),
      depth: s && s < 4 ? s : i
    });
  }
  getZoomOptions(t) {
    if (!this.getDisplayData())
      return {};
    const n = this.getDisplayData(), r = t || this.getOptions(), i = n.length === 1 && y(n, 0, "children") ? y(n, 0, "children") : n;
    let s = this.getHierarchyLevel();
    return i.some((a) => {
      if (a.children && a.children.some((o) => o.children))
        return s = 3, !1;
    }), y(r, "canvasZoom", "enabled") === !0 && s > 2 ? {
      legend: {
        additionalItems: [
          {
            type: Gt.ZOOM,
            name: "Click to zoom"
          }
        ]
      }
    } : null;
  }
  setZoom(t) {
    this.setOptions(this.getZoomOptions(t));
  }
  // update the hierarchy level
  updateHierarchyLevel(t) {
    this.set({ depth: t });
  }
  getHierarchyLevel() {
    return this.get("depth");
  }
  hasParentNode() {
    return this.parentNode;
  }
  // set the datagroup name on the items that are it's children
  setDataGroups() {
    const t = this.getData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = t.map((s) => {
      const a = s[r];
      return this.setChildrenDataGroup(s, a);
    });
    this.set(
      {
        data: i
      },
      { skipUpdate: !0 }
    );
  }
  // sets name recursively down the node tree
  setChildrenDataGroup(t, n) {
    return t.children ? {
      ...t,
      dataGroupName: n,
      children: t.children.map((r) => this.setChildrenDataGroup(r, n))
    } : { ...t, dataGroupName: n };
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale"), i = ["Child", "Parent", "Value"], s = [];
    return t.forEach((a) => {
      let o = a.value ? a.value : 0;
      a.children && (o += this.getChildrenDatums(a.children, a.name, s, 0)), s.push(["&ndash;", a.name, n(o, r)]);
    }), super.formatTable({ headers: i, cells: s });
  }
  /**
   * Recursively determine the relationship between all the nested elements in the child
   * @private
   * @param {any} children - The children nodes to process.
   * @param {any} parent - The parent node associated with the children.
   * @param {string[][]} [result=[]] - An array to accumulate the resulting data.
   * @param {number} [totalSum=0] - The running total sum of values processed.
   * @returns {number} Sum.
   */
  getChildrenDatums(t, n, r = [], i = 0) {
    const s = n, { number: a, code: o } = y(this.getOptions(), "locale");
    return t.forEach((l) => {
      const c = l.name;
      let u = 0;
      if (l.children)
        l.children.length > 0 && (typeof l.value == "number" && (i += l.value), u += this.getChildrenDatums(l.children, c, r, u), r.push([c, s, a(u, o)]), i += u);
      else {
        let d = 0;
        typeof l.value == "number" && (d = l.value, i += l.value), r.push([l.name, s, a(d, o)]);
      }
    }), i;
  }
}, n$ = class extends an {
  constructor(t) {
    super(t);
  }
  getTabularData(t) {
    const n = super.getTabularData(t);
    return t !== n && n.forEach((r) => {
      r.key && r.key !== r.group && (r.group = r.key);
    }), n;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { valueMapsTo: i } = n.pie, { number: s, code: a } = y(n, "locale"), o = ["Group", "Value"], l = [
      ...t.map((c) => [
        c[r],
        c[i] === null ? "&ndash;" : s(c[i], a)
      ])
    ];
    return super.formatTable({ headers: o, cells: l });
  }
  sanitize(t) {
    return this.getTabularData(t).sort((n, r) => r.value - n.value);
  }
}, r$ = class extends an {
  constructor(t) {
    super(t);
  }
  getDataGroups() {
    return super.getDataGroups().filter((t) => t.name !== "delta");
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { number: i, code: s } = y(this.getOptions(), "locale"), a = ["Group", "Value"], o = [
      ...t.map((l) => [
        l[r],
        l.value === null ? "&ndash;" : i(l.value, s)
      ])
    ];
    return super.formatTable({ headers: a, cells: o });
  }
}, i$ = class extends mr {
  constructor(t) {
    super(t), this.axisFlavor = Ga.HOVERABLE, this._colorScale = void 0, this._domains = [], this._ranges = [], this._matrix = {};
    const n = y(this.getOptions(), "axes");
    if (y(n, "left", "scaleType") && y(n, "left", "scaleType") !== et.LABELS || y(n, "right", "scaleType") && y(n, "right", "scaleType") !== et.LABELS || y(n, "top", "scaleType") && y(n, "top", "scaleType") !== et.LABELS || y(n, "bottom", "scaleType") && y(n, "bottom", "scaleType") !== et.LABELS)
      throw Error("Heatmap only supports label scaletypes.");
  }
  /**
   * Get min and maximum value of the display data
   * @returns Array consisting of smallest and largest values in  data
   */
  getValueDomain() {
    const t = ze(this.getDisplayData(), (r) => r.value), n = Fe().domain(t).nice().domain();
    if (n[0] > 0)
      n[0] = 0;
    else if (n[0] === 0 && n[1] === 0)
      return [0, 1];
    return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Generate a list of all unique domains
   * @returns String[]
   */
  getUniqueDomain() {
    if (Be(this._domains)) {
      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getDomainIdentifier(), i = n.getMainXAxisPosition(), s = n.getCustomDomainValuesByposition(i);
      if (s)
        return s;
      this._domains = Array.from(
        new Set(
          t.map((a) => a[r])
        )
      );
    }
    return this._domains;
  }
  /**
   * Generates a list of all unique ranges
   * @returns String[]
   */
  getUniqueRanges() {
    if (Be(this._ranges)) {
      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getRangeIdentifier(), i = n.getMainYAxisPosition(), s = n.getCustomDomainValuesByposition(i);
      if (s)
        return s;
      this._ranges = Array.from(
        new Set(
          t.map((a) => a[r])
        )
      );
    }
    return this._ranges;
  }
  /**
   * Generates a matrix (If doesn't exist) and returns it
   * @returns Object
   */
  getMatrix() {
    if (Be(this._matrix)) {
      const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = {};
      n.forEach((a) => {
        s[a] = {
          value: null,
          index: -1
        };
      }), t.forEach((a) => {
        this._matrix[a] = Sn(s);
      }), this.getDisplayData().forEach((a, o) => {
        this._matrix[a[r]][a[i]] = {
          value: a.value,
          index: o
        };
      });
    }
    return this._matrix;
  }
  /**
   * Sets the data for the current instance.
   *
   * This method sanitizes the provided data, generates data groups,
   * and updates the instance's state with the sanitized data and data groups.
   * It also resets the `_domains`, `_ranges`, and `_matrix` attributes to their empty states.
   *
   * @param {any} newData - The new data to be set. This data will be cloned and sanitized.
   * @returns {any} - The sanitized version of the provided data.
   */
  setData(t) {
    const n = this.sanitize(Sn(t)), r = this.generateDataGroups(n);
    return this.set({
      data: n,
      dataGroups: r
    }), this._domains = [], this._ranges = [], this._matrix = {}, n;
  }
  /**
   * Converts Object matrix into a single array
   * @returns object[]
   */
  getMatrixAsArray() {
    Be(this._matrix) && this.getMatrix();
    const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = [];
    return t.forEach((a) => {
      n.forEach((o) => {
        const l = {
          value: this._matrix[a][o].value,
          index: this._matrix[a][o].index
        };
        l[r] = a, l[i] = o, s.push(l);
      });
    }), s;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { primaryDomain: n, primaryRange: r } = this.assignRangeAndDomains(), { number: i, code: s } = y(this.getOptions(), "locale"), a = [n.label, r.label, "Value"], o = [
      ...t.map((l) => [
        l[n.identifier] === null ? "&ndash;" : l[n.identifier],
        l[r.identifier] === null ? "&ndash;" : l[r.identifier],
        l.value === null ? "&ndash;" : i(l.value, s)
      ])
    ];
    return super.formatTable({ headers: a, cells: o });
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = this.getOptions(), n = y(t, "color", "gradient", "colors"), r = !Be(n);
    let i = y(t, "color", "pairing", "option");
    const s = this.getValueDomain(), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";
    (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);
    const o = r ? n : [];
    if (!r) {
      const c = a === "diverge" ? 17 : 11;
      for (let u = 1; u < c + 1; u++)
        o.push(`fill-${a}-${i}-${u}`);
    }
    this._colorScale = Vc().domain(s).range(o);
    const l = y(this.getOptions(), "color");
    this._colorScale = Fm(this.getDisplayData(), l);
  }
}, s$ = class extends mr {
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, { number: r, code: i } = y(this.getOptions(), "locale"), s = this.getBinnedStackedData(), a = [
      gt(t, "bins.rangeLabel") || "Range",
      ...s.map((l) => gt(l, `0.${n}`))
    ], o = [
      ...gt(s, 0).map((l, c) => [
        `${r(Number(gt(l, "data.x0")), i)}  ${r(
          Number(gt(l, "data.x1")),
          i
        )}`,
        ...s.map(
          (u) => r(gt(u[c], `data.${gt(u[c], n)}`), i)
        )
      ])
    ];
    return super.formatTable({ headers: a, cells: o });
  }
};
class a$ extends an {
  constructor(t) {
    super(t);
  }
  getMaximumDomain(t) {
    return t.reduce((n, r) => n + r.value, 0);
  }
  /**
   * Use a provided color for the bar or default to carbon color if no status provided.
   * Defaults to carbon color otherwise.
   * @param group dataset group label
   */
  getFillColor(t) {
    const n = this.getOptions(), r = y(n, "color", "scale"), i = this.getStatus();
    return r || !i ? super.getFillColor(t) : null;
  }
  /**
   * Get the associated status for the data by checking the ranges
   */
  getStatus() {
    const t = this.getOptions(), n = y(this.getDisplayData())?.reduce((s, a) => s + a.value, 0) ?? 0, r = y(t, "meter", "proportional") ? n : n > 100 ? 100 : n, i = y(t, "meter", "status", "ranges");
    if (i) {
      const s = i.filter(
        (a) => a.range[0] <= r && r <= a.range[1]
      );
      if (s.length > 0)
        return s[0].status;
    }
    return null;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getStatus(), s = y(n, "meter", "proportional"), { number: a, code: o } = y(this.getOptions(), "locale");
    let l = [], c = [], u;
    if (s === null) {
      u = 100;
      const d = t[0];
      l = ["Group", "Value", ...i ? ["Status"] : []], c = [
        [
          d[r],
          d.value === null ? "&ndash;" : a(d.value, o),
          ...i ? [i] : []
        ]
      ];
    } else
      u = y(s, "total") || this.getMaximumDomain(t), l = ["Group", "Value", "Percentage of total"], c = [
        ...t.map((h) => {
          let p;
          h.value !== null && h.value !== void 0 ? p = Number(h.value) : p = 0;
          const f = Number((h.value / u * 100).toFixed(2));
          return [
            h[r],
            h.value === null ? "&ndash;" : a(p, o),
            a(f, o) + " %"
          ];
        })
      ];
    return super.formatTable({ headers: l, cells: c });
  }
}
class o$ extends mr {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getOptions(), n = this.getGroupedData(), { angle: r, value: i } = y(t, "radar", "axes"), { number: s, code: a } = y(t, "locale"), o = y(n, "0", "data").map((u) => u[r]), l = ["Group", ...o], c = [
      ...n.map((u) => [
        u.name,
        ...o.map(
          (d, h) => y(u, "data", h, i) !== null ? s(y(u, "data", h, i), a) : "&ndash;"
        )
      ])
    ];
    return super.formatTable({ headers: l, cells: c });
  }
}
let l$ = class extends an {
  constructor(t) {
    super(t);
  }
  /**
   * Retrieves and formats tabular data from the display data.
   *
   * @returns {any[]} An object containing the headers and cells of the tabular data.
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), n = ["Child", "Parent"], r = [];
    return t.forEach((i) => {
      this.getChildrenDatums(i, r), r.push([i.name, "&ndash;"]);
    }), super.formatTable({ headers: n, cells: r });
  }
  /**
   * Determine the child parent relationship in nested data
   * @private
   * @param {any} datum - The datum node to process.
   * @param {any[]} [result=[]] - An array to accumulate the resulting data.
   * @returns {any[]} The accumulated result array.
   */
  getChildrenDatums(t, n = []) {
    t.children && t.children.length > 0 && t.children.forEach((r) => {
      this.getChildrenDatums(r, n), n.push([r.name, t.name]);
    });
  }
};
class c$ extends an {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = y(this.getOptions(), "locale"), i = ["Child", "Group", "Value"], s = [];
    return t.forEach((a) => {
      Array.isArray(a.children) ? a.children.forEach((o) => {
        s.push([
          o.name,
          a.name,
          o.value === null ? "&ndash;" : n(o.value, r)
        ]);
      }) : y(a.name) !== null && y(a.value) && s.push(["", a.name, n(a.value, r)]);
    }), super.formatTable({ headers: i, cells: s });
  }
}
let u$ = class extends an {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { fontSizeMapsTo: r, wordMapsTo: i } = n.wordCloud, { groupMapsTo: s } = n.data, { code: a, number: o } = y(n, "locale"), l = [n.tooltip.wordLabel, "Group", n.tooltip.valueLabel], c = [
      ...t.map((u) => [
        u[i],
        u[s],
        o(u[r], a)
      ])
    ];
    return super.formatTable({ headers: l, cells: c });
  }
};
var h$ = /\s/;
function d$(e) {
  for (var t = e.length; t-- && h$.test(e.charAt(t)); )
    ;
  return t;
}
var p$ = /^\s+/;
function f$(e) {
  return e && e.slice(0, d$(e) + 1).replace(p$, "");
}
var jh = NaN, m$ = /^[-+]0x[0-9a-f]+$/i, g$ = /^0b[01]+$/i, v$ = /^0o[0-7]+$/i, y$ = parseInt;
function Fr(e) {
  if (typeof e == "number")
    return e;
  if (Fa(e))
    return jh;
  if (ke(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = ke(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = f$(e);
  var n = g$.test(e);
  return n || v$.test(e) ? y$(e.slice(2), n ? 2 : 8) : m$.test(e) ? jh : +e;
}
var Io = function() {
  return We.Date.now();
}, x$ = "Expected a function", b$ = Math.max, _$ = Math.min;
function ba(e, t, n) {
  var r, i, s, a, o, l, c = 0, u = !1, d = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(x$);
  t = Fr(t) || 0, ke(n) && (u = !!n.leading, d = "maxWait" in n, s = d ? b$(Fr(n.maxWait) || 0, t) : s, h = "trailing" in n ? !!n.trailing : h);
  function p(S) {
    var $ = r, D = i;
    return r = i = void 0, c = S, a = e.apply(D, $), a;
  }
  function f(S) {
    return c = S, o = setTimeout(v, t), u ? p(S) : a;
  }
  function g(S) {
    var $ = S - l, D = S - c, C = t - $;
    return d ? _$(C, s - D) : C;
  }
  function m(S) {
    var $ = S - l, D = S - c;
    return l === void 0 || $ >= t || $ < 0 || d && D >= s;
  }
  function v() {
    var S = Io();
    if (m(S))
      return b(S);
    o = setTimeout(v, g(S));
  }
  function b(S) {
    return o = void 0, h && r ? p(S) : (r = i = void 0, a);
  }
  function _() {
    o !== void 0 && clearTimeout(o), c = 0, r = l = i = o = void 0;
  }
  function E() {
    return o === void 0 ? a : b(Io());
  }
  function x() {
    var S = Io(), $ = m(S);
    if (r = arguments, i = this, l = S, $) {
      if (o === void 0)
        return f(l);
      if (d)
        return clearTimeout(o), o = setTimeout(v, t), p(l);
    }
    return o === void 0 && (o = setTimeout(v, t)), a;
  }
  return x.cancel = _, x.flush = E, x;
}
function E$(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(i); ++r < i; )
    s[r] = e + r * n;
  return s;
}
function I(e) {
  return typeof e == "string" ? new _e([[document.querySelector(e)]], [document.documentElement]) : new _e([[e]], im);
}
function Jr() {
  var e = ro().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, s, a, o = !1, l = 0, c = 0, u = 0.5;
  delete e.unknown;
  function d() {
    var h = t().length, p = i < r, f = p ? i : r, g = p ? r : i;
    s = (g - f) / Math.max(1, h - l + c * 2), o && (s = Math.floor(s)), f += (g - f - s * (h - l)) * u, a = s * (1 - l), o && (f = Math.round(f), a = Math.round(a));
    var m = E$(h).map(function(v) {
      return f + s * v;
    });
    return n(p ? m.reverse() : m);
  }
  return e.domain = function(h) {
    return arguments.length ? (t(h), d()) : t();
  }, e.range = function(h) {
    return arguments.length ? ([r, i] = h, r = +r, i = +i, d()) : [r, i];
  }, e.rangeRound = function(h) {
    return [r, i] = h, r = +r, i = +i, o = !0, d();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return s;
  }, e.round = function(h) {
    return arguments.length ? (o = !!h, d()) : o;
  }, e.padding = function(h) {
    return arguments.length ? (l = Math.min(1, c = +h), d()) : l;
  }, e.paddingInner = function(h) {
    return arguments.length ? (l = Math.min(1, h), d()) : l;
  }, e.paddingOuter = function(h) {
    return arguments.length ? (c = +h, d()) : c;
  }, e.align = function(h) {
    return arguments.length ? (u = Math.max(0, Math.min(1, h)), d()) : u;
  }, e.copy = function() {
    return Jr(t(), [r, i]).round(o).paddingInner(l).paddingOuter(c).align(u);
  }, ai.apply(d(), arguments);
}
function qm(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], s = e[r], a;
  return s < i && (a = n, n = r, r = a, a = i, i = s, s = a), e[n] = t.floor(i), e[r] = t.ceil(s), e;
}
const No = /* @__PURE__ */ new Date(), Po = /* @__PURE__ */ new Date();
function Wt(e, t, n, r) {
  function i(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return i.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {
    const a = i(s), o = i.ceil(s);
    return s - a < o - s ? a : o;
  }, i.offset = (s, a) => (t(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), i.range = (s, a, o) => {
    const l = [];
    if (s = i.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0)) return l;
    let c;
    do
      l.push(c = /* @__PURE__ */ new Date(+s)), t(s, o), e(s);
    while (c < s && s < a);
    return l;
  }, i.filter = (s) => Wt((a) => {
    if (a >= a) for (; e(a), !s(a); ) a.setTime(a - 1);
  }, (a, o) => {
    if (a >= a)
      if (o < 0) for (; ++o <= 0; )
        for (; t(a, -1), !s(a); )
          ;
      else for (; --o >= 0; )
        for (; t(a, 1), !s(a); )
          ;
  }), n && (i.count = (s, a) => (No.setTime(+s), Po.setTime(+a), e(No), e(Po), Math.floor(n(No, Po))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(r ? (a) => r(a) % s === 0 : (a) => i.count(0, a) % s === 0) : i)), i;
}
const _a = Wt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
_a.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Wt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : _a);
_a.range;
const bn = 1e3, Ce = bn * 60, _n = Ce * 60, $n = _n * 24, jc = $n * 7, Wh = $n * 30, Uo = $n * 365, Br = Wt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * bn);
}, (e, t) => (t - e) / bn, (e) => e.getUTCSeconds());
Br.range;
const Wc = Wt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * bn);
}, (e, t) => {
  e.setTime(+e + t * Ce);
}, (e, t) => (t - e) / Ce, (e) => e.getMinutes());
Wc.range;
const O$ = Wt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Ce);
}, (e, t) => (t - e) / Ce, (e) => e.getUTCMinutes());
O$.range;
const qc = Wt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * bn - e.getMinutes() * Ce);
}, (e, t) => {
  e.setTime(+e + t * _n);
}, (e, t) => (t - e) / _n, (e) => e.getHours());
qc.range;
const S$ = Wt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * _n);
}, (e, t) => (t - e) / _n, (e) => e.getUTCHours());
S$.range;
const ys = Wt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Ce) / $n,
  (e) => e.getDate() - 1
);
ys.range;
const Yc = Wt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / $n, (e) => e.getUTCDate() - 1);
Yc.range;
const T$ = Wt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / $n, (e) => Math.floor(e / $n));
T$.range;
function gr(e) {
  return Wt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Ce) / jc);
}
const ao = gr(0), Ea = gr(1), w$ = gr(2), $$ = gr(3), ti = gr(4), M$ = gr(5), C$ = gr(6);
ao.range;
Ea.range;
w$.range;
$$.range;
ti.range;
M$.range;
C$.range;
function vr(e) {
  return Wt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / jc);
}
const Ym = vr(0), Oa = vr(1), A$ = vr(2), L$ = vr(3), ei = vr(4), D$ = vr(5), k$ = vr(6);
Ym.range;
Oa.range;
A$.range;
L$.range;
ei.range;
D$.range;
k$.range;
const Xc = Wt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
Xc.range;
const R$ = Wt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
R$.range;
const Mn = Wt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
Mn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Wt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
Mn.range;
const ar = Wt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
ar.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Wt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
ar.range;
function I$(e, t, n, r, i, s) {
  const a = [
    [Br, 1, bn],
    [Br, 5, 5 * bn],
    [Br, 15, 15 * bn],
    [Br, 30, 30 * bn],
    [s, 1, Ce],
    [s, 5, 5 * Ce],
    [s, 15, 15 * Ce],
    [s, 30, 30 * Ce],
    [i, 1, _n],
    [i, 3, 3 * _n],
    [i, 6, 6 * _n],
    [i, 12, 12 * _n],
    [r, 1, $n],
    [r, 2, 2 * $n],
    [n, 1, jc],
    [t, 1, Wh],
    [t, 3, 3 * Wh],
    [e, 1, Uo]
  ];
  function o(c, u, d) {
    const h = u < c;
    h && ([c, u] = [u, c]);
    const p = d && typeof d.range == "function" ? d : l(c, u, d), f = p ? p.range(c, +u + 1) : [];
    return h ? f.reverse() : f;
  }
  function l(c, u, d) {
    const h = Math.abs(u - c) / d, p = Mc(([, , m]) => m).right(a, h);
    if (p === a.length) return e.every(_l(c / Uo, u / Uo, d));
    if (p === 0) return _a.every(Math.max(_l(c, u, d), 1));
    const [f, g] = a[h / a[p - 1][2] < a[p][2] / h ? p - 1 : p];
    return f.every(g);
  }
  return [o, l];
}
const [N$, P$] = I$(Mn, Xc, ao, ys, qc, Wc);
function Bo(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Ho(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function yi(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function U$(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, s = e.days, a = e.shortDays, o = e.months, l = e.shortMonths, c = xi(i), u = bi(i), d = xi(s), h = bi(s), p = xi(a), f = bi(a), g = xi(o), m = bi(o), v = xi(l), b = bi(l), _ = {
    a: L,
    A: k,
    b: U,
    B: Z,
    c: null,
    d: Qh,
    e: Qh,
    f: oM,
    g: vM,
    G: xM,
    H: iM,
    I: sM,
    j: aM,
    L: Xm,
    m: lM,
    M: cM,
    p: j,
    q: F,
    Q: ed,
    s: nd,
    S: uM,
    u: hM,
    U: dM,
    V: pM,
    w: fM,
    W: mM,
    x: null,
    X: null,
    y: gM,
    Y: yM,
    Z: bM,
    "%": td
  }, E = {
    a: Y,
    A: ot,
    b: Q,
    B: q,
    c: null,
    d: Jh,
    e: Jh,
    f: SM,
    g: RM,
    G: NM,
    H: _M,
    I: EM,
    j: OM,
    L: Km,
    m: TM,
    M: wM,
    p: tt,
    q: lt,
    Q: ed,
    s: nd,
    S: $M,
    u: MM,
    U: CM,
    V: AM,
    w: LM,
    W: DM,
    x: null,
    X: null,
    y: kM,
    Y: IM,
    Z: PM,
    "%": td
  }, x = {
    a: R,
    A: M,
    b: H,
    B: P,
    c: B,
    d: Zh,
    e: Zh,
    f: tM,
    g: Xh,
    G: Yh,
    H: Kh,
    I: Kh,
    j: Z$,
    L: J$,
    m: X$,
    M: K$,
    p: C,
    q: Y$,
    Q: nM,
    s: rM,
    S: Q$,
    u: z$,
    U: F$,
    V: j$,
    w: G$,
    W: W$,
    x: O,
    X: w,
    y: Xh,
    Y: Yh,
    Z: q$,
    "%": eM
  };
  _.x = S(n, _), _.X = S(r, _), _.c = S(t, _), E.x = S(n, E), E.X = S(r, E), E.c = S(t, E);
  function S(z, W) {
    return function(X) {
      var V = [], ut = -1, st = 0, kt = z.length, Nt, nt, yt;
      for (X instanceof Date || (X = /* @__PURE__ */ new Date(+X)); ++ut < kt; )
        z.charCodeAt(ut) === 37 && (V.push(z.slice(st, ut)), (nt = qh[Nt = z.charAt(++ut)]) != null ? Nt = z.charAt(++ut) : nt = Nt === "e" ? " " : "0", (yt = W[Nt]) && (Nt = yt(X, nt)), V.push(Nt), st = ut + 1);
      return V.push(z.slice(st, ut)), V.join("");
    };
  }
  function $(z, W) {
    return function(X) {
      var V = yi(1900, void 0, 1), ut = D(V, z, X += "", 0), st, kt;
      if (ut != X.length) return null;
      if ("Q" in V) return new Date(V.Q);
      if ("s" in V) return new Date(V.s * 1e3 + ("L" in V ? V.L : 0));
      if (W && !("Z" in V) && (V.Z = 0), "p" in V && (V.H = V.H % 12 + V.p * 12), V.m === void 0 && (V.m = "q" in V ? V.q : 0), "V" in V) {
        if (V.V < 1 || V.V > 53) return null;
        "w" in V || (V.w = 1), "Z" in V ? (st = Ho(yi(V.y, 0, 1)), kt = st.getUTCDay(), st = kt > 4 || kt === 0 ? Oa.ceil(st) : Oa(st), st = Yc.offset(st, (V.V - 1) * 7), V.y = st.getUTCFullYear(), V.m = st.getUTCMonth(), V.d = st.getUTCDate() + (V.w + 6) % 7) : (st = Bo(yi(V.y, 0, 1)), kt = st.getDay(), st = kt > 4 || kt === 0 ? Ea.ceil(st) : Ea(st), st = ys.offset(st, (V.V - 1) * 7), V.y = st.getFullYear(), V.m = st.getMonth(), V.d = st.getDate() + (V.w + 6) % 7);
      } else ("W" in V || "U" in V) && ("w" in V || (V.w = "u" in V ? V.u % 7 : "W" in V ? 1 : 0), kt = "Z" in V ? Ho(yi(V.y, 0, 1)).getUTCDay() : Bo(yi(V.y, 0, 1)).getDay(), V.m = 0, V.d = "W" in V ? (V.w + 6) % 7 + V.W * 7 - (kt + 5) % 7 : V.w + V.U * 7 - (kt + 6) % 7);
      return "Z" in V ? (V.H += V.Z / 100 | 0, V.M += V.Z % 100, Ho(V)) : Bo(V);
    };
  }
  function D(z, W, X, V) {
    for (var ut = 0, st = W.length, kt = X.length, Nt, nt; ut < st; ) {
      if (V >= kt) return -1;
      if (Nt = W.charCodeAt(ut++), Nt === 37) {
        if (Nt = W.charAt(ut++), nt = x[Nt in qh ? W.charAt(ut++) : Nt], !nt || (V = nt(z, X, V)) < 0) return -1;
      } else if (Nt != X.charCodeAt(V++))
        return -1;
    }
    return V;
  }
  function C(z, W, X) {
    var V = c.exec(W.slice(X));
    return V ? (z.p = u.get(V[0].toLowerCase()), X + V[0].length) : -1;
  }
  function R(z, W, X) {
    var V = p.exec(W.slice(X));
    return V ? (z.w = f.get(V[0].toLowerCase()), X + V[0].length) : -1;
  }
  function M(z, W, X) {
    var V = d.exec(W.slice(X));
    return V ? (z.w = h.get(V[0].toLowerCase()), X + V[0].length) : -1;
  }
  function H(z, W, X) {
    var V = v.exec(W.slice(X));
    return V ? (z.m = b.get(V[0].toLowerCase()), X + V[0].length) : -1;
  }
  function P(z, W, X) {
    var V = g.exec(W.slice(X));
    return V ? (z.m = m.get(V[0].toLowerCase()), X + V[0].length) : -1;
  }
  function B(z, W, X) {
    return D(z, t, W, X);
  }
  function O(z, W, X) {
    return D(z, n, W, X);
  }
  function w(z, W, X) {
    return D(z, r, W, X);
  }
  function L(z) {
    return a[z.getDay()];
  }
  function k(z) {
    return s[z.getDay()];
  }
  function U(z) {
    return l[z.getMonth()];
  }
  function Z(z) {
    return o[z.getMonth()];
  }
  function j(z) {
    return i[+(z.getHours() >= 12)];
  }
  function F(z) {
    return 1 + ~~(z.getMonth() / 3);
  }
  function Y(z) {
    return a[z.getUTCDay()];
  }
  function ot(z) {
    return s[z.getUTCDay()];
  }
  function Q(z) {
    return l[z.getUTCMonth()];
  }
  function q(z) {
    return o[z.getUTCMonth()];
  }
  function tt(z) {
    return i[+(z.getUTCHours() >= 12)];
  }
  function lt(z) {
    return 1 + ~~(z.getUTCMonth() / 3);
  }
  return {
    format: function(z) {
      var W = S(z += "", _);
      return W.toString = function() {
        return z;
      }, W;
    },
    parse: function(z) {
      var W = $(z += "", !1);
      return W.toString = function() {
        return z;
      }, W;
    },
    utcFormat: function(z) {
      var W = S(z += "", E);
      return W.toString = function() {
        return z;
      }, W;
    },
    utcParse: function(z) {
      var W = $(z += "", !0);
      return W.toString = function() {
        return z;
      }, W;
    }
  };
}
var qh = { "-": "", _: " ", 0: "0" }, Yt = /^\s*\d+/, B$ = /^%/, H$ = /[\\^$*+?|[\]().{}]/g;
function vt(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", s = i.length;
  return r + (s < n ? new Array(n - s + 1).join(t) + i : i);
}
function V$(e) {
  return e.replace(H$, "\\$&");
}
function xi(e) {
  return new RegExp("^(?:" + e.map(V$).join("|") + ")", "i");
}
function bi(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function G$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function z$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function F$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function j$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function W$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function Yh(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function Xh(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function q$(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function Y$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function X$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function Zh(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function Z$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function Kh(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function K$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function Q$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function J$(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function tM(e, t, n) {
  var r = Yt.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function eM(e, t, n) {
  var r = B$.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function nM(e, t, n) {
  var r = Yt.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function rM(e, t, n) {
  var r = Yt.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function Qh(e, t) {
  return vt(e.getDate(), t, 2);
}
function iM(e, t) {
  return vt(e.getHours(), t, 2);
}
function sM(e, t) {
  return vt(e.getHours() % 12 || 12, t, 2);
}
function aM(e, t) {
  return vt(1 + ys.count(Mn(e), e), t, 3);
}
function Xm(e, t) {
  return vt(e.getMilliseconds(), t, 3);
}
function oM(e, t) {
  return Xm(e, t) + "000";
}
function lM(e, t) {
  return vt(e.getMonth() + 1, t, 2);
}
function cM(e, t) {
  return vt(e.getMinutes(), t, 2);
}
function uM(e, t) {
  return vt(e.getSeconds(), t, 2);
}
function hM(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function dM(e, t) {
  return vt(ao.count(Mn(e) - 1, e), t, 2);
}
function Zm(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ti(e) : ti.ceil(e);
}
function pM(e, t) {
  return e = Zm(e), vt(ti.count(Mn(e), e) + (Mn(e).getDay() === 4), t, 2);
}
function fM(e) {
  return e.getDay();
}
function mM(e, t) {
  return vt(Ea.count(Mn(e) - 1, e), t, 2);
}
function gM(e, t) {
  return vt(e.getFullYear() % 100, t, 2);
}
function vM(e, t) {
  return e = Zm(e), vt(e.getFullYear() % 100, t, 2);
}
function yM(e, t) {
  return vt(e.getFullYear() % 1e4, t, 4);
}
function xM(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? ti(e) : ti.ceil(e), vt(e.getFullYear() % 1e4, t, 4);
}
function bM(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + vt(t / 60 | 0, "0", 2) + vt(t % 60, "0", 2);
}
function Jh(e, t) {
  return vt(e.getUTCDate(), t, 2);
}
function _M(e, t) {
  return vt(e.getUTCHours(), t, 2);
}
function EM(e, t) {
  return vt(e.getUTCHours() % 12 || 12, t, 2);
}
function OM(e, t) {
  return vt(1 + Yc.count(ar(e), e), t, 3);
}
function Km(e, t) {
  return vt(e.getUTCMilliseconds(), t, 3);
}
function SM(e, t) {
  return Km(e, t) + "000";
}
function TM(e, t) {
  return vt(e.getUTCMonth() + 1, t, 2);
}
function wM(e, t) {
  return vt(e.getUTCMinutes(), t, 2);
}
function $M(e, t) {
  return vt(e.getUTCSeconds(), t, 2);
}
function MM(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function CM(e, t) {
  return vt(Ym.count(ar(e) - 1, e), t, 2);
}
function Qm(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? ei(e) : ei.ceil(e);
}
function AM(e, t) {
  return e = Qm(e), vt(ei.count(ar(e), e) + (ar(e).getUTCDay() === 4), t, 2);
}
function LM(e) {
  return e.getUTCDay();
}
function DM(e, t) {
  return vt(Oa.count(ar(e) - 1, e), t, 2);
}
function kM(e, t) {
  return vt(e.getUTCFullYear() % 100, t, 2);
}
function RM(e, t) {
  return e = Qm(e), vt(e.getUTCFullYear() % 100, t, 2);
}
function IM(e, t) {
  return vt(e.getUTCFullYear() % 1e4, t, 4);
}
function NM(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? ei(e) : ei.ceil(e), vt(e.getUTCFullYear() % 1e4, t, 4);
}
function PM() {
  return "+0000";
}
function td() {
  return "%";
}
function ed(e) {
  return +e;
}
function nd(e) {
  return Math.floor(+e / 1e3);
}
var Sr, Jm;
UM({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function UM(e) {
  return Sr = U$(e), Jm = Sr.format, Sr.parse, Sr.utcFormat, Sr.utcParse, Sr;
}
function BM(e) {
  return new Date(e);
}
function HM(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function tg(e, t, n, r, i, s, a, o, l, c) {
  var u = Tm(), d = u.invert, h = u.domain, p = c(".%L"), f = c(":%S"), g = c("%I:%M"), m = c("%I %p"), v = c("%a %d"), b = c("%b %d"), _ = c("%B"), E = c("%Y");
  function x(S) {
    return (l(S) < S ? p : o(S) < S ? f : a(S) < S ? g : s(S) < S ? m : r(S) < S ? i(S) < S ? v : b : n(S) < S ? _ : E)(S);
  }
  return u.invert = function(S) {
    return new Date(d(S));
  }, u.domain = function(S) {
    return arguments.length ? h(Array.from(S, HM)) : h().map(BM);
  }, u.ticks = function(S) {
    var $ = h();
    return e($[0], $[$.length - 1], S ?? 10);
  }, u.tickFormat = function(S, $) {
    return $ == null ? x : c($);
  }, u.nice = function(S) {
    var $ = h();
    return (!S || typeof S.range != "function") && (S = t($[0], $[$.length - 1], S ?? 10)), S ? h(qm($, S)) : u;
  }, u.copy = function() {
    return Hc(u, tg(e, t, n, r, i, s, a, o, l, c));
  }, u;
}
function eg() {
  return ai.apply(tg(N$, P$, Mn, Xc, ao, ys, qc, Wc, Br, Jm).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
const rd = Math.abs, Jt = Math.atan2, qn = Math.cos, VM = Math.max, Vo = Math.min, Ze = Math.sin, Hr = Math.sqrt, ne = 1e-12, is = Math.PI, Sa = is / 2, Ks = 2 * is;
function GM(e) {
  return e > 1 ? 0 : e < -1 ? is : Math.acos(e);
}
function id(e) {
  return e >= 1 ? Sa : e <= -1 ? -Sa : Math.asin(e);
}
function ng(e) {
  this._context = e;
}
ng.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function oo(e) {
  return new ng(e);
}
function Hn() {
}
function rg(e) {
  this._context = e;
}
rg.prototype = {
  areaStart: Hn,
  areaEnd: Hn,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function ig(e) {
  return new rg(e);
}
function zM(e, t) {
  if (e.match(/^[a-z]+:\/\//i))
    return e;
  if (e.match(/^\/\//))
    return window.location.protocol + e;
  if (e.match(/^[a-z]+:/i))
    return e;
  const n = document.implementation.createHTMLDocument(), r = n.createElement("base"), i = n.createElement("a");
  return n.head.appendChild(r), n.body.appendChild(i), t && (r.href = t), i.href = e, i.href;
}
const FM = /* @__PURE__ */ (() => {
  let e = 0;
  const t = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (e += 1, `u${t()}${e}`);
})();
function On(e) {
  const t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t.push(e[n]);
  return t;
}
function Ta(e, t) {
  const n = (e.ownerDocument.defaultView || window).getComputedStyle(e).getPropertyValue(t);
  return n ? parseFloat(n.replace("px", "")) : 0;
}
function jM(e) {
  const t = Ta(e, "border-left-width"), n = Ta(e, "border-right-width");
  return e.clientWidth + t + n;
}
function WM(e) {
  const t = Ta(e, "border-top-width"), n = Ta(e, "border-bottom-width");
  return e.clientHeight + t + n;
}
function sg(e, t = {}) {
  const n = t.width || jM(e), r = t.height || WM(e);
  return { width: n, height: r };
}
function qM() {
  let e, t;
  try {
    t = process;
  } catch {
  }
  const n = t && t.env ? t.env.devicePixelRatio : null;
  return n && (e = parseInt(n, 10), Number.isNaN(e) && (e = 1)), e || window.devicePixelRatio || 1;
}
const ve = 16384;
function YM(e) {
  (e.width > ve || e.height > ve) && (e.width > ve && e.height > ve ? e.width > e.height ? (e.height *= ve / e.width, e.width = ve) : (e.width *= ve / e.height, e.height = ve) : e.width > ve ? (e.height *= ve / e.width, e.width = ve) : (e.width *= ve / e.height, e.height = ve));
}
function wa(e) {
  return new Promise((t, n) => {
    const r = new Image();
    r.decode = () => t(r), r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = e;
  });
}
async function XM(e) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(e)).then(encodeURIComponent).then((t) => `data:image/svg+xml;charset=utf-8,${t}`);
}
async function ZM(e, t, n) {
  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), s = document.createElementNS(r, "foreignObject");
  return i.setAttribute("width", `${t}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${t} ${n}`), s.setAttribute("width", "100%"), s.setAttribute("height", "100%"), s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("externalResourcesRequired", "true"), i.appendChild(s), s.appendChild(e), XM(i);
}
const pe = (e, t) => {
  if (e instanceof t)
    return !0;
  const n = Object.getPrototypeOf(e);
  return n === null ? !1 : n.constructor.name === t.name || pe(n, t);
};
function KM(e) {
  const t = e.getPropertyValue("content");
  return `${e.cssText} content: '${t.replace(/'|"/g, "")}';`;
}
function QM(e) {
  return On(e).map((t) => {
    const n = e.getPropertyValue(t), r = e.getPropertyPriority(t);
    return `${t}: ${n}${r ? " !important" : ""};`;
  }).join(" ");
}
function JM(e, t, n) {
  const r = `.${e}:${t}`, i = n.cssText ? KM(n) : QM(n);
  return document.createTextNode(`${r}{${i}}`);
}
function sd(e, t, n) {
  const r = window.getComputedStyle(e, n), i = r.getPropertyValue("content");
  if (i === "" || i === "none")
    return;
  const s = FM();
  try {
    t.className = `${t.className} ${s}`;
  } catch {
    return;
  }
  const a = document.createElement("style");
  a.appendChild(JM(s, n, r)), t.appendChild(a);
}
function t2(e, t) {
  sd(e, t, ":before"), sd(e, t, ":after");
}
const ad = "application/font-woff", od = "image/jpeg", e2 = {
  woff: ad,
  woff2: ad,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: od,
  jpeg: od,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function n2(e) {
  const t = /\.([^./]*?)$/g.exec(e);
  return t ? t[1] : "";
}
function Zc(e) {
  const t = n2(e).toLowerCase();
  return e2[t] || "";
}
function r2(e) {
  return e.split(/,/)[1];
}
function kl(e) {
  return e.search(/^(data:)/) !== -1;
}
function i2(e, t) {
  return `data:${t};base64,${e}`;
}
async function ag(e, t, n) {
  const r = await fetch(e, t);
  if (r.status === 404)
    throw new Error(`Resource "${r.url}" not found`);
  const i = await r.blob();
  return new Promise((s, a) => {
    const o = new FileReader();
    o.onerror = a, o.onloadend = () => {
      try {
        s(n({ res: r, result: o.result }));
      } catch (l) {
        a(l);
      }
    }, o.readAsDataURL(i);
  });
}
const Go = {};
function s2(e, t, n) {
  let r = e.replace(/\?.*/, "");
  return n && (r = e), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), t ? `[${t}]${r}` : r;
}
async function Kc(e, t, n) {
  const r = s2(e, t, n.includeQueryParams);
  if (Go[r] != null)
    return Go[r];
  n.cacheBust && (e += (/\?/.test(e) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let i;
  try {
    const s = await ag(e, n.fetchRequestInit, ({ res: a, result: o }) => (t || (t = a.headers.get("Content-Type") || ""), r2(o)));
    i = i2(s, t);
  } catch (s) {
    i = n.imagePlaceholder || "";
    let a = `Failed to fetch resource: ${e}`;
    s && (a = typeof s == "string" ? s : s.message), a && console.warn(a);
  }
  return Go[r] = i, i;
}
async function a2(e) {
  const t = e.toDataURL();
  return t === "data:," ? e.cloneNode(!1) : wa(t);
}
async function o2(e, t) {
  if (e.currentSrc) {
    const s = document.createElement("canvas"), a = s.getContext("2d");
    s.width = e.clientWidth, s.height = e.clientHeight, a?.drawImage(e, 0, 0, s.width, s.height);
    const o = s.toDataURL();
    return wa(o);
  }
  const n = e.poster, r = Zc(n), i = await Kc(n, r, t);
  return wa(i);
}
async function l2(e) {
  var t;
  try {
    if (!((t = e?.contentDocument) === null || t === void 0) && t.body)
      return await lo(e.contentDocument.body, {}, !0);
  } catch {
  }
  return e.cloneNode(!1);
}
async function c2(e, t) {
  return pe(e, HTMLCanvasElement) ? a2(e) : pe(e, HTMLVideoElement) ? o2(e, t) : pe(e, HTMLIFrameElement) ? l2(e) : e.cloneNode(!1);
}
const u2 = (e) => e.tagName != null && e.tagName.toUpperCase() === "SLOT";
async function h2(e, t, n) {
  var r, i;
  let s = [];
  return u2(e) && e.assignedNodes ? s = On(e.assignedNodes()) : pe(e, HTMLIFrameElement) && !((r = e.contentDocument) === null || r === void 0) && r.body ? s = On(e.contentDocument.body.childNodes) : s = On(((i = e.shadowRoot) !== null && i !== void 0 ? i : e).childNodes), s.length === 0 || pe(e, HTMLVideoElement) || await s.reduce((a, o) => a.then(() => lo(o, n)).then((l) => {
    l && t.appendChild(l);
  }), Promise.resolve()), t;
}
function d2(e, t) {
  const n = t.style;
  if (!n)
    return;
  const r = window.getComputedStyle(e);
  r.cssText ? (n.cssText = r.cssText, n.transformOrigin = r.transformOrigin) : On(r).forEach((i) => {
    let s = r.getPropertyValue(i);
    i === "font-size" && s.endsWith("px") && (s = `${Math.floor(parseFloat(s.substring(0, s.length - 2))) - 0.1}px`), pe(e, HTMLIFrameElement) && i === "display" && s === "inline" && (s = "block"), i === "d" && t.getAttribute("d") && (s = `path(${t.getAttribute("d")})`), n.setProperty(i, s, r.getPropertyPriority(i));
  });
}
function p2(e, t) {
  pe(e, HTMLTextAreaElement) && (t.innerHTML = e.value), pe(e, HTMLInputElement) && t.setAttribute("value", e.value);
}
function f2(e, t) {
  if (pe(e, HTMLSelectElement)) {
    const n = t, r = Array.from(n.children).find((i) => e.value === i.getAttribute("value"));
    r && r.setAttribute("selected", "");
  }
}
function m2(e, t) {
  return pe(t, Element) && (d2(e, t), t2(e, t), p2(e, t), f2(e, t)), t;
}
async function g2(e, t) {
  const n = e.querySelectorAll ? e.querySelectorAll("use") : [];
  if (n.length === 0)
    return e;
  const r = {};
  for (let s = 0; s < n.length; s++) {
    const a = n[s].getAttribute("xlink:href");
    if (a) {
      const o = e.querySelector(a), l = document.querySelector(a);
      !o && l && !r[a] && (r[a] = await lo(l, t, !0));
    }
  }
  const i = Object.values(r);
  if (i.length) {
    const s = "http://www.w3.org/1999/xhtml", a = document.createElementNS(s, "svg");
    a.setAttribute("xmlns", s), a.style.position = "absolute", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", a.style.display = "none";
    const o = document.createElementNS(s, "defs");
    a.appendChild(o);
    for (let l = 0; l < i.length; l++)
      o.appendChild(i[l]);
    e.appendChild(a);
  }
  return e;
}
async function lo(e, t, n) {
  return !n && t.filter && !t.filter(e) ? null : Promise.resolve(e).then((r) => c2(r, t)).then((r) => h2(e, r, t)).then((r) => m2(e, r)).then((r) => g2(r, t));
}
const og = /url\((['"]?)([^'"]+?)\1\)/g, v2 = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, y2 = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function x2(e) {
  const t = e.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${t})(['"]?\\))`, "g");
}
function b2(e) {
  const t = [];
  return e.replace(og, (n, r, i) => (t.push(i), n)), t.filter((n) => !kl(n));
}
async function _2(e, t, n, r, i) {
  try {
    const s = n ? zM(t, n) : t, a = Zc(t);
    let o;
    return i || (o = await Kc(s, a, r)), e.replace(x2(t), `$1${o}$3`);
  } catch {
  }
  return e;
}
function E2(e, { preferredFontFormat: t }) {
  return t ? e.replace(y2, (n) => {
    for (; ; ) {
      const [r, , i] = v2.exec(n) || [];
      if (!i)
        return "";
      if (i === t)
        return `src: ${r};`;
    }
  }) : e;
}
function lg(e) {
  return e.search(og) !== -1;
}
async function cg(e, t, n) {
  if (!lg(e))
    return e;
  const r = E2(e, n);
  return b2(r).reduce((i, s) => i.then((a) => _2(a, s, t, n)), Promise.resolve(r));
}
async function Ds(e, t, n) {
  var r;
  const i = (r = t.style) === null || r === void 0 ? void 0 : r.getPropertyValue(e);
  if (i) {
    const s = await cg(i, null, n);
    return t.style.setProperty(e, s, t.style.getPropertyPriority(e)), !0;
  }
  return !1;
}
async function O2(e, t) {
  await Ds("background", e, t) || await Ds("background-image", e, t), await Ds("mask", e, t) || await Ds("mask-image", e, t);
}
async function S2(e, t) {
  const n = pe(e, HTMLImageElement);
  if (!(n && !kl(e.src)) && !(pe(e, SVGImageElement) && !kl(e.href.baseVal)))
    return;
  const r = n ? e.src : e.href.baseVal, i = await Kc(r, Zc(r), t);
  await new Promise((s, a) => {
    e.onload = s, e.onerror = a;
    const o = e;
    o.decode && (o.decode = s), o.loading === "lazy" && (o.loading = "eager"), n ? (e.srcset = "", e.src = i) : e.href.baseVal = i;
  });
}
async function T2(e, t) {
  const n = On(e.childNodes).map((r) => ug(r, t));
  await Promise.all(n).then(() => e);
}
async function ug(e, t) {
  pe(e, Element) && (await O2(e, t), await S2(e, t), await T2(e, t));
}
function w2(e, t) {
  const { style: n } = e;
  t.backgroundColor && (n.backgroundColor = t.backgroundColor), t.width && (n.width = `${t.width}px`), t.height && (n.height = `${t.height}px`);
  const r = t.style;
  return r != null && Object.keys(r).forEach((i) => {
    n[i] = r[i];
  }), e;
}
const ld = {};
async function cd(e) {
  let t = ld[e];
  if (t != null)
    return t;
  const n = await (await fetch(e)).text();
  return t = { url: e, cssText: n }, ld[e] = t, t;
}
async function ud(e, t) {
  let n = e.cssText;
  const r = /url\(["']?([^"')]+)["']?\)/g, i = (n.match(/url\([^)]+\)/g) || []).map(async (s) => {
    let a = s.replace(r, "$1");
    return a.startsWith("https://") || (a = new URL(a, e.url).href), ag(a, t.fetchRequestInit, ({ result: o }) => (n = n.replace(s, `url(${o})`), [s, o]));
  });
  return Promise.all(i).then(() => n);
}
function hd(e) {
  if (e == null)
    return [];
  const t = [], n = /(\/\*[\s\S]*?\*\/)/gi;
  let r = e.replace(n, "");
  const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const l = i.exec(r);
    if (l === null)
      break;
    t.push(l[0]);
  }
  r = r.replace(i, "");
  const s = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, a = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", o = new RegExp(a, "gi");
  for (; ; ) {
    let l = s.exec(r);
    if (l === null) {
      if (l = o.exec(r), l === null)
        break;
      s.lastIndex = o.lastIndex;
    } else
      o.lastIndex = s.lastIndex;
    t.push(l[0]);
  }
  return t;
}
async function $2(e, t) {
  const n = [], r = [];
  return e.forEach((i) => {
    if ("cssRules" in i)
      try {
        On(i.cssRules || []).forEach((s, a) => {
          if (s.type === CSSRule.IMPORT_RULE) {
            let o = a + 1;
            const l = s.href, c = cd(l).then((u) => ud(u, t)).then((u) => hd(u).forEach((d) => {
              try {
                i.insertRule(d, d.startsWith("@import") ? o += 1 : i.cssRules.length);
              } catch (h) {
                console.error("Error inserting rule from remote css", {
                  rule: d,
                  error: h
                });
              }
            })).catch((u) => {
              console.error("Error loading remote css", u.toString());
            });
            r.push(c);
          }
        });
      } catch (s) {
        const a = e.find((o) => o.href == null) || document.styleSheets[0];
        i.href != null && r.push(cd(i.href).then((o) => ud(o, t)).then((o) => hd(o).forEach((l) => {
          a.insertRule(l, i.cssRules.length);
        })).catch((o) => {
          console.error("Error loading remote stylesheet", o);
        })), console.error("Error inlining remote css file", s);
      }
  }), Promise.all(r).then(() => (e.forEach((i) => {
    if ("cssRules" in i)
      try {
        On(i.cssRules || []).forEach((s) => {
          n.push(s);
        });
      } catch (s) {
        console.error(`Error while reading CSS rules from ${i.href}`, s);
      }
  }), n));
}
function M2(e) {
  return e.filter((t) => t.type === CSSRule.FONT_FACE_RULE).filter((t) => lg(t.style.getPropertyValue("src")));
}
async function C2(e, t) {
  if (e.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const n = On(e.ownerDocument.styleSheets), r = await $2(n, t);
  return M2(r);
}
async function A2(e, t) {
  const n = await C2(e, t);
  return (await Promise.all(n.map((r) => {
    const i = r.parentStyleSheet ? r.parentStyleSheet.href : null;
    return cg(r.cssText, i, t);
  }))).join(`
`);
}
async function L2(e, t) {
  const n = t.fontEmbedCSS != null ? t.fontEmbedCSS : t.skipFonts ? null : await A2(e, t);
  if (n) {
    const r = document.createElement("style"), i = document.createTextNode(n);
    r.appendChild(i), e.firstChild ? e.insertBefore(r, e.firstChild) : e.appendChild(r);
  }
}
async function D2(e, t = {}) {
  const { width: n, height: r } = sg(e, t), i = await lo(e, t, !0);
  return await L2(i, t), await ug(i, t), w2(i, t), await ZM(i, n, r);
}
async function hg(e, t = {}) {
  const { width: n, height: r } = sg(e, t), i = await D2(e, t), s = await wa(i), a = document.createElement("canvas"), o = a.getContext("2d"), l = t.pixelRatio || qM(), c = t.canvasWidth || n, u = t.canvasHeight || r;
  return a.width = c * l, a.height = u * l, t.skipAutoScale || YM(a), a.style.width = `${c}`, a.style.height = `${u}`, t.backgroundColor && (o.fillStyle = t.backgroundColor, o.fillRect(0, 0, a.width, a.height)), o.drawImage(s, 0, 0, a.width, a.height), a;
}
async function k2(e, t = {}) {
  return (await hg(e, t)).toDataURL();
}
async function R2(e, t = {}) {
  return (await hg(e, t)).toDataURL("image/jpeg", t.quality || 1);
}
let kn = class {
  constructor(t, n) {
    this.model = t, this.services = n, this.init();
  }
  init() {
  }
  update() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down services to the components
  setServices(t) {
    this.services = t;
  }
};
const I2 = "DONT_STYLE_ME_css_styles_verifier";
let N = class Rl extends kn {
  // initialized in initializeID() called by init()
  constructor(t, n) {
    super(t, n);
  }
  static getHTMLElementSize(t) {
    return {
      width: t.clientWidth,
      height: t.clientHeight
    };
  }
  static getSVGElementSize(t, n = {
    useAttrs: !1,
    useClientDimensions: !1,
    useBBox: !1,
    useBoundingRect: !1
  }) {
    t.attr || (t = I(t));
    const r = {
      width: 0,
      height: 0
    }, i = (h) => {
      h && Object.keys(r).forEach((p) => {
        if (h[p]) {
          const f = h[p], g = parseFloat(f);
          f && g > r[p] && ("" + f).indexOf("%") === -1 && (r[p] = g);
        }
      });
    }, s = {
      width: t.attr("width"),
      height: t.attr("height")
    }, a = t.node();
    let o, l, c, u;
    try {
      typeof a.getBBox == "function" && (o = a.getBBox(), l = {
        width: o.width,
        height: o.height
      });
    } catch (h) {
      console.error(h);
    }
    try {
      typeof a?.getBoundingClientRect == "function" && (c = a.getBoundingClientRect(), u = {
        width: c.width,
        height: c.height
      });
    } catch (h) {
      console.error(h);
    }
    let d;
    if (a instanceof SVGSVGElement && (d = {
      width: a.clientWidth,
      height: a.clientHeight
    }), n) {
      if (n.useAttrs && (i(s), r.width > 0 && r.height > 0))
        return r;
      if (n.useClientDimensions && (i(d), r.width > 0 && r.height > 0))
        return d;
      if (n.useBBox && (i(l), r.width > 0 && r.height > 0))
        return l;
      if (n.useBoundingRect && (i(u), r.width > 0 && r.height > 0))
        return u;
    }
    try {
      const h = {
        width: y(t.node(), "width", "baseVal", "value"),
        height: y(t.node(), "height", "baseVal", "value")
      };
      i(h);
    } catch {
      i(d), i(l), i(s);
    }
    return r;
  }
  static appendOrSelect(t, n) {
    const r = t.select(`${n}`);
    if (r.empty()) {
      let i = n.split("#"), s, a;
      return i.length === 2 ? (s = i[0], i = i[1].split("."), a = i[0]) : (i = n.split("."), s = i[0]), t.append(s).attr("id", a).attr("class", i.slice(1).join(" "));
    }
    return r;
  }
  init() {
    this.initializeID(), this.styleHolderElement(), this.addMainContainer(), this.model.getOptions().resizable && this.addResizeListener(), this.addHolderListeners(), this.handleFullscreenChange();
  }
  getChartID() {
    return this.chartID;
  }
  getElementOffset(t, n = !1) {
    const r = { left: 0, top: 0 }, i = t.getBoundingClientRect(), s = n ? { left: 0, top: 0 } : this.getHolder().getBoundingClientRect();
    try {
      r.left = i.left - s.left, r.top = i.top - s.top;
    } catch (a) {
      console.error(a);
    }
    return r;
  }
  generateElementIDString(t) {
    return `chart-${this.chartID}-${t}`;
  }
  initializeID() {
    const t = this.model.getOptions().chartId;
    t ? this.chartID = t : this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);
  }
  addMainContainer() {
    const t = this.model.getOptions(), n = y(t, "style", "prefix"), r = I(this.getHolder()).append("div").classed(`${ue}--${n}--chart-wrapper`, !0).attr("id", `chart-${this.getChartID()}`).style("height", "100%").style("width", "100%");
    r.append("g").attr("class", I2), this.mainContainer = r.node();
  }
  update() {
    this.styleHolderElement();
  }
  styleHolderElement() {
    const t = this.getHolder(), { width: n, height: r, theme: i } = this.model.getOptions();
    n !== this.width && (t.style.width = n, this.width = n), r !== this.height && (t.style.height = r, this.height = r), I(this.getHolder()).classed(`${ue}--chart-holder`, !0).attr("data-carbon-theme", i);
  }
  getHolder() {
    return this.model.get("holder");
  }
  exportToJPG() {
    const t = this, n = this.model.getOptions(), r = this.getHolder(), i = I(r);
    i.classed("filled", !0), R2(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))
    }).then(function(s) {
      let a = "myChart";
      const o = y(n, "fileDownload", "fileName");
      typeof o == "function" ? a = o("jpg") : typeof o == "string" && (a = o), t.services.files?.downloadImage(s, `${a}.jpg`), i.classed("filled", !1);
    });
  }
  exportToPNG() {
    const t = this, n = this.model.getOptions(), r = this.getHolder(), i = I(r);
    i.classed("filled", !0), k2(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))
    }).then(function(s) {
      let a = "myChart";
      const o = y(n, "fileDownload", "fileName");
      typeof o == "function" ? a = o("png") : typeof o == "string" && (a = o), t.services.files?.downloadImage(s, `${a}.png`), i.classed("filled", !1);
    }).catch(function(s) {
      console.error("oops, something went wrong!", s);
    });
  }
  isFullScreenMode() {
    return I(this.getHolder()).classed("fullscreen");
  }
  toggleFullscreen() {
    const t = this.getHolder();
    I(t).classed("fullscreen") && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen() : t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen && t.msRequestFullscreen();
  }
  handleFullscreenChange() {
    document.addEventListener("fullscreenchange", () => {
      const t = I(this.getHolder()), n = t.classed("fullscreen");
      t.classed("fullscreen", !n);
    });
  }
  setSVGMaxHeight() {
    if (!this.model.getOptions().height) {
      const { height: t } = Rl.getSVGElementSize(
        I(this.mainContainer),
        {
          useBBox: !0
        }
      ), n = I(this.mainContainer).attr("class"), r = I(this.mainContainer).selectAll(`.${n} > svg`);
      let i = 0;
      r.nodes().forEach(function(s) {
        i += Number(
          Rl.getSVGElementSize(I(s), {
            useBBox: !0
          }).height
        );
      }), i <= t ? I(this.mainContainer).attr("height", i) : I(this.mainContainer).attr("height", "100%");
    }
  }
  getMainContainer() {
    return this.mainContainer;
  }
  addHolderListeners() {
    const t = this.getHolder();
    t && I(t).on("mouseover", () => {
      this.services.events?.dispatchEvent(T.Chart.MOUSEOVER);
    }).on("mouseout", () => {
      this.services.events?.dispatchEvent(T.Chart.MOUSEOUT);
    });
  }
  addResizeListener() {
    const t = this.getHolder();
    if (!t)
      return;
    let n = t.clientWidth, r = t.clientHeight;
    const i = ba(() => {
      t && (Math.abs(n - t.clientWidth) > 1 || Math.abs(r - t.clientHeight) > 1) && (n = t.clientWidth, r = t.clientHeight, this.services.events?.dispatchEvent(T.Chart.RESIZE));
    }, 12.5);
    new ResizeObserver(i).observe(t);
  }
}, Il = class dg extends kn {
  static appendOrUpdateLinearGradient(t) {
    let n = t.svg.select(`defs linearGradient#${t.id}`);
    n.empty() && (n = t.svg.append("defs").append("linearGradient").attr("id", t.id).attr("x1", t.x1).attr("x2", t.x2).attr("y1", t.y1).attr("y2", t.y2)), n.selectAll("stop").remove(), n.selectAll("stop").data(t.stops).enter().append("stop").attr("offset", (r) => r.offset).style("stop-color", (r) => r.color).style("stop-opacity", (r) => r.opacity);
  }
  static getOffsetRatio(t) {
    return (Math.abs(t[1]) * 100 / Math.abs(t[0] - t[1])).toFixed(2) + "%";
  }
  static getStops(t, n) {
    const r = t[0] < 0 && t[1] > 0;
    let i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: "80%",
        color: n,
        opacity: "0"
      }
    ];
    return r && (i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: dg.getOffsetRatio(t),
        color: n,
        opacity: "0"
      },
      {
        offset: "100%",
        color: n,
        opacity: "0.6"
      }
    ]), i;
  }
};
function dd(e) {
  const t = N2(pg(e), 360);
  return Nn(t, [0, 10]) || Nn(t, [350, 0]) ? {
    textAnchor: dn.START,
    dominantBaseline: pn.MIDDLE
  } : Nn(t, [10, 80]) ? {
    textAnchor: dn.START,
    dominantBaseline: pn.HANGING
  } : Nn(t, [80, 100]) ? {
    textAnchor: dn.MIDDLE,
    dominantBaseline: pn.HANGING
  } : Nn(t, [100, 170]) ? {
    textAnchor: dn.END,
    dominantBaseline: pn.HANGING
  } : Nn(t, [170, 190]) ? {
    textAnchor: dn.END,
    dominantBaseline: pn.MIDDLE
  } : Nn(t, [190, 260]) ? {
    textAnchor: dn.END,
    dominantBaseline: pn.BASELINE
  } : Nn(t, [260, 280]) ? {
    textAnchor: dn.MIDDLE,
    dominantBaseline: pn.BASELINE
  } : {
    textAnchor: dn.START,
    dominantBaseline: pn.BASELINE
  };
}
function N2(e, t) {
  return (e % t + t) % t;
}
function Nn(e, [t, n]) {
  return e >= t && e <= n;
}
function pg(e) {
  return e * (180 / Math.PI);
}
function Ut(e, t, n = { x: 0, y: 0 }) {
  const r = t * Math.cos(e) + n.x, i = t * Math.sin(e) + n.y;
  return { x: isNaN(r) ? 0 : r, y: isNaN(i) ? 0 : i };
}
function P2(e, t) {
  return t * Math.sin(e - Math.PI / 2);
}
function U2(e, t, n, r) {
  for (var i = -1, s = e == null ? 0 : e.length; ++i < s; )
    n = t(n, e[i], i, e);
  return n;
}
function B2(e) {
  return function(t) {
    return e?.[t];
  };
}
var H2 = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "s"
}, V2 = B2(H2), G2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, z2 = "\\u0300-\\u036f", F2 = "\\ufe20-\\ufe2f", j2 = "\\u20d0-\\u20ff", W2 = z2 + F2 + j2, q2 = "[" + W2 + "]", Y2 = RegExp(q2, "g");
function X2(e) {
  return e = ds(e), e && e.replace(G2, V2).replace(Y2, "");
}
var Z2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function K2(e) {
  return e.match(Z2) || [];
}
var Q2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function J2(e) {
  return Q2.test(e);
}
var fg = "\\ud800-\\udfff", tC = "\\u0300-\\u036f", eC = "\\ufe20-\\ufe2f", nC = "\\u20d0-\\u20ff", rC = tC + eC + nC, mg = "\\u2700-\\u27bf", gg = "a-z\\xdf-\\xf6\\xf8-\\xff", iC = "\\xac\\xb1\\xd7\\xf7", sC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", aC = "\\u2000-\\u206f", oC = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", vg = "A-Z\\xc0-\\xd6\\xd8-\\xde", lC = "\\ufe0e\\ufe0f", yg = iC + sC + aC + oC, xg = "[']", pd = "[" + yg + "]", cC = "[" + rC + "]", bg = "\\d+", uC = "[" + mg + "]", _g = "[" + gg + "]", Eg = "[^" + fg + yg + bg + mg + gg + vg + "]", hC = "\\ud83c[\\udffb-\\udfff]", dC = "(?:" + cC + "|" + hC + ")", pC = "[^" + fg + "]", Og = "(?:\\ud83c[\\udde6-\\uddff]){2}", Sg = "[\\ud800-\\udbff][\\udc00-\\udfff]", Lr = "[" + vg + "]", fC = "\\u200d", fd = "(?:" + _g + "|" + Eg + ")", mC = "(?:" + Lr + "|" + Eg + ")", md = "(?:" + xg + "(?:d|ll|m|re|s|t|ve))?", gd = "(?:" + xg + "(?:D|LL|M|RE|S|T|VE))?", Tg = dC + "?", wg = "[" + lC + "]?", gC = "(?:" + fC + "(?:" + [pC, Og, Sg].join("|") + ")" + wg + Tg + ")*", vC = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", yC = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", xC = wg + Tg + gC, bC = "(?:" + [uC, Og, Sg].join("|") + ")" + xC, _C = RegExp([
  Lr + "?" + _g + "+" + md + "(?=" + [pd, Lr, "$"].join("|") + ")",
  mC + "+" + gd + "(?=" + [pd, Lr + fd, "$"].join("|") + ")",
  Lr + "?" + fd + "+" + md,
  Lr + "+" + gd,
  yC,
  vC,
  bg,
  bC
].join("|"), "g");
function EC(e) {
  return e.match(_C) || [];
}
function OC(e, t, n) {
  return e = ds(e), t = t, t === void 0 ? J2(e) ? EC(e) : K2(e) : e.match(t) || [];
}
var SC = "[']", TC = RegExp(SC, "g");
function $g(e) {
  return function(t) {
    return U2(OC(X2(t).replace(TC, "")), e, "");
  };
}
function wC(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
function Mg(e, t, n) {
  return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = Fr(n), n = n === n ? n : 0), t !== void 0 && (t = Fr(t), t = t === t ? t : 0), wC(Fr(e), t, n);
}
var $C = "Expected a function";
function MC(e, t, n) {
  if (typeof e != "function")
    throw new TypeError($C);
  return setTimeout(function() {
    e.apply(void 0, n);
  }, t);
}
var CC = vc(function(e, t, n) {
  return MC(e, Fr(t) || 0, n);
});
function AC(e, t) {
  var n = -1, r = fr(e) ? Array(e.length) : [];
  return Fc(e, function(i, s, a) {
    r[++n] = t(i, s, a);
  }), r;
}
function LC(e, t) {
  var n = Kt(e) ? pc : AC;
  return n(e, Ja(t));
}
var DC = 1 / 0;
function kC(e, t) {
  return Ka(LC(e, t), DC);
}
function Cg(e, t) {
  return Qa(e, t);
}
var Tr = $g(function(e, t, n) {
  return e + (n ? "-" : "") + t.toLowerCase();
});
function RC(e, t) {
  var n;
  return Fc(e, function(r, i, s) {
    return n = t(r, i, s), !n;
  }), !!n;
}
function IC(e, t, n) {
  var r = Kt(e) ? Uf : RC;
  return r(e, Ja(t));
}
class or {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let r = 0;
    for (let i = 0; i < this._n && i < 32; i++) {
      const s = n[i], a = t + s, o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);
      o && (n[r++] = o), t = a;
    }
    return n[r] = t, this._n = r + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, r, i, s, a = 0;
    if (n > 0) {
      for (a = t[--n]; n > 0 && (r = a, i = t[--n], a = r + i, s = i - (a - r), !s); )
        ;
      n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (i = s * 2, r = a + i, i == r - a && (a = r));
    }
    return a;
  }
}
function* NC(e) {
  for (const t of e)
    yield* t;
}
function Ag(e) {
  return Array.from(NC(e));
}
function PC(e) {
  return e;
}
var Qs = 1, Js = 2, Nl = 3, Ai = 4, vd = 1e-6;
function UC(e) {
  return "translate(" + e + ",0)";
}
function BC(e) {
  return "translate(0," + e + ")";
}
function HC(e) {
  return (t) => +e(t);
}
function VC(e, t) {
  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
}
function GC() {
  return !this.__axis;
}
function co(e, t) {
  var n = [], r = null, i = null, s = 6, a = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, c = e === Qs || e === Ai ? -1 : 1, u = e === Ai || e === Js ? "x" : "y", d = e === Qs || e === Nl ? UC : BC;
  function h(p) {
    var f = r ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()), g = i ?? (t.tickFormat ? t.tickFormat.apply(t, n) : PC), m = Math.max(s, 0) + o, v = t.range(), b = +v[0] + l, _ = +v[v.length - 1] + l, E = (t.bandwidth ? VC : HC)(t.copy(), l), x = p.selection ? p.selection() : p, S = x.selectAll(".domain").data([null]), $ = x.selectAll(".tick").data(f, t).order(), D = $.exit(), C = $.enter().append("g").attr("class", "tick"), R = $.select("line"), M = $.select("text");
    S = S.merge(S.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), $ = $.merge(C), R = R.merge(C.append("line").attr("stroke", "currentColor").attr(u + "2", c * s)), M = M.merge(C.append("text").attr("fill", "currentColor").attr(u, c * m).attr("dy", e === Qs ? "0em" : e === Nl ? "0.71em" : "0.32em")), p !== x && (S = S.transition(p), $ = $.transition(p), R = R.transition(p), M = M.transition(p), D = D.transition(p).attr("opacity", vd).attr("transform", function(H) {
      return isFinite(H = E(H)) ? d(H + l) : this.getAttribute("transform");
    }), C.attr("opacity", vd).attr("transform", function(H) {
      var P = this.parentNode.__axis;
      return d((P && isFinite(P = P(H)) ? P : E(H)) + l);
    })), D.remove(), S.attr("d", e === Ai || e === Js ? a ? "M" + c * a + "," + b + "H" + l + "V" + _ + "H" + c * a : "M" + l + "," + b + "V" + _ : a ? "M" + b + "," + c * a + "V" + l + "H" + _ + "V" + c * a : "M" + b + "," + l + "H" + _), $.attr("opacity", 1).attr("transform", function(H) {
      return d(E(H) + l);
    }), R.attr(u + "2", c * s), M.attr(u, c * m).text(g), x.filter(GC).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === Js ? "start" : e === Ai ? "end" : "middle"), x.each(function() {
      this.__axis = E;
    });
  }
  return h.scale = function(p) {
    return arguments.length ? (t = p, h) : t;
  }, h.ticks = function() {
    return n = Array.from(arguments), h;
  }, h.tickArguments = function(p) {
    return arguments.length ? (n = p == null ? [] : Array.from(p), h) : n.slice();
  }, h.tickValues = function(p) {
    return arguments.length ? (r = p == null ? null : Array.from(p), h) : r && r.slice();
  }, h.tickFormat = function(p) {
    return arguments.length ? (i = p, h) : i;
  }, h.tickSize = function(p) {
    return arguments.length ? (s = a = +p, h) : s;
  }, h.tickSizeInner = function(p) {
    return arguments.length ? (s = +p, h) : s;
  }, h.tickSizeOuter = function(p) {
    return arguments.length ? (a = +p, h) : a;
  }, h.tickPadding = function(p) {
    return arguments.length ? (o = +p, h) : o;
  }, h.offset = function(p) {
    return arguments.length ? (l = +p, h) : l;
  }, h;
}
function zC(e) {
  return co(Qs, e);
}
function FC(e) {
  return co(Js, e);
}
function Qc(e) {
  return co(Nl, e);
}
function Lg(e) {
  return co(Ai, e);
}
const Pl = { capture: !0, passive: !1 };
function Ul(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function jC(e) {
  var t = e.document.documentElement, n = I(e).on("dragstart.drag", Ul, Pl);
  "onselectstart" in t ? n.on("selectstart.drag", Ul, Pl) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function WC(e, t) {
  var n = e.document.documentElement, r = I(e).on("dragstart.drag", null);
  t && (r.on("click.drag", Ul, Pl), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
function qC(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e(r / (t - 1));
  return n;
}
const YC = (e) => +e, zo = (e) => () => e;
function XC(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: i,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function ZC(e) {
  e.stopImmediatePropagation();
}
function Fo(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var yd = { name: "drag" }, jo = { name: "space" }, wr = { name: "handle" }, $r = { name: "center" };
const { abs: xd, max: te, min: ee } = Math;
function bd(e) {
  return [+e[0], +e[1]];
}
function _d(e) {
  return [bd(e[0]), bd(e[1])];
}
var ta = {
  name: "x",
  handles: ["w", "e"].map(Bl),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, Wo = {}, hn = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, Ed = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, Od = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, KC = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, QC = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Bl(e) {
  return { type: e };
}
function JC(e) {
  return !e.ctrlKey && !e.button;
}
function tA() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function eA() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function qo(e) {
  for (; !e.__brush; ) if (!(e = e.parentNode)) return;
  return e.__brush;
}
function nA(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function Dg() {
  return rA(ta);
}
function rA(e) {
  var t = tA, n = JC, r = eA, i = !0, s = Ac("start", "brush", "end"), a = 6, o;
  function l(m) {
    var v = m.property("__brush", g).selectAll(".overlay").data([Bl("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", hn.overlay).merge(v).each(function() {
      var _ = qo(this).extent;
      I(this).attr("x", _[0][0]).attr("y", _[0][1]).attr("width", _[1][0] - _[0][0]).attr("height", _[1][1] - _[0][1]);
    }), m.selectAll(".selection").data([Bl("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", hn.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var b = m.selectAll(".handle").data(e.handles, function(_) {
      return _.type;
    });
    b.exit().remove(), b.enter().append("rect").attr("class", function(_) {
      return "handle handle--" + _.type;
    }).attr("cursor", function(_) {
      return hn[_.type];
    }), m.each(c).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(r).on("touchstart.brush", h).on("touchmove.brush", p).on("touchend.brush touchcancel.brush", f).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  l.move = function(m, v, b) {
    m.tween ? m.on("start.brush", function(_) {
      u(this, arguments).beforestart().start(_);
    }).on("interrupt.brush end.brush", function(_) {
      u(this, arguments).end(_);
    }).tween("brush", function() {
      var _ = this, E = _.__brush, x = u(_, arguments), S = E.selection, $ = e.input(typeof v == "function" ? v.apply(this, arguments) : v, E.extent), D = gs(S, $);
      function C(R) {
        E.selection = R === 1 && $ === null ? null : D(R), c.call(_), x.brush();
      }
      return S !== null && $ !== null ? C : C(1);
    }) : m.each(function() {
      var _ = this, E = arguments, x = _.__brush, S = e.input(typeof v == "function" ? v.apply(_, E) : v, x.extent), $ = u(_, E).beforestart();
      Ml(_), x.selection = S === null ? null : S, c.call(_), $.start(b).brush(b).end(b);
    });
  }, l.clear = function(m, v) {
    l.move(m, null, v);
  };
  function c() {
    var m = I(this), v = qo(this).selection;
    v ? (m.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(b) {
      return b.type[b.type.length - 1] === "e" ? v[1][0] - a / 2 : v[0][0] - a / 2;
    }).attr("y", function(b) {
      return b.type[0] === "s" ? v[1][1] - a / 2 : v[0][1] - a / 2;
    }).attr("width", function(b) {
      return b.type === "n" || b.type === "s" ? v[1][0] - v[0][0] + a : a;
    }).attr("height", function(b) {
      return b.type === "e" || b.type === "w" ? v[1][1] - v[0][1] + a : a;
    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function u(m, v, b) {
    var _ = m.__brush.emitter;
    return _ && (!b || !_.clean) ? _ : new d(m, v, b);
  }
  function d(m, v, b) {
    this.that = m, this.args = v, this.state = m.__brush, this.active = 0, this.clean = b;
  }
  d.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(m, v) {
      return this.starting ? (this.starting = !1, this.emit("start", m, v)) : this.emit("brush", m), this;
    },
    brush: function(m, v) {
      return this.emit("brush", m, v), this;
    },
    end: function(m, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, v)), this;
    },
    emit: function(m, v, b) {
      var _ = I(this.that).datum();
      s.call(
        m,
        this.that,
        new XC(m, {
          sourceEvent: v,
          target: l,
          selection: e.output(this.state.selection),
          mode: b,
          dispatch: s
        }),
        _
      );
    }
  };
  function h(m) {
    if (o && !m.touches || !n.apply(this, arguments)) return;
    var v = this, b = m.target.__data__.type, _ = (i && m.metaKey ? b = "overlay" : b) === "selection" ? yd : i && m.altKey ? $r : wr, E = e === Wo ? null : KC[b], x = e === ta ? null : QC[b], S = qo(v), $ = S.extent, D = S.selection, C = $[0][0], R, M, H = $[0][1], P, B, O = $[1][0], w, L, k = $[1][1], U, Z, j = 0, F = 0, Y, ot = E && x && i && m.shiftKey, Q, q, tt = Array.from(m.touches || [m], (nt) => {
      const yt = nt.identifier;
      return nt = rr(nt, v), nt.point0 = nt.slice(), nt.identifier = yt, nt;
    });
    Ml(v);
    var lt = u(v, arguments, !0).beforestart();
    if (b === "overlay") {
      D && (Y = !0);
      const nt = [tt[0], tt[1] || tt[0]];
      S.selection = D = [[
        R = e === Wo ? C : ee(nt[0][0], nt[1][0]),
        P = e === ta ? H : ee(nt[0][1], nt[1][1])
      ], [
        w = e === Wo ? O : te(nt[0][0], nt[1][0]),
        U = e === ta ? k : te(nt[0][1], nt[1][1])
      ]], tt.length > 1 && ut(m);
    } else
      R = D[0][0], P = D[0][1], w = D[1][0], U = D[1][1];
    M = R, B = P, L = w, Z = U;
    var z = I(v).attr("pointer-events", "none"), W = z.selectAll(".overlay").attr("cursor", hn[b]);
    if (m.touches)
      lt.moved = V, lt.ended = st;
    else {
      var X = I(m.view).on("mousemove.brush", V, !0).on("mouseup.brush", st, !0);
      i && X.on("keydown.brush", kt, !0).on("keyup.brush", Nt, !0), jC(m.view);
    }
    c.call(v), lt.start(m, _.name);
    function V(nt) {
      for (const yt of nt.changedTouches || [nt])
        for (const Se of tt)
          Se.identifier === yt.identifier && (Se.cur = rr(yt, v));
      if (ot && !Q && !q && tt.length === 1) {
        const yt = tt[0];
        xd(yt.cur[0] - yt[0]) > xd(yt.cur[1] - yt[1]) ? q = !0 : Q = !0;
      }
      for (const yt of tt)
        yt.cur && (yt[0] = yt.cur[0], yt[1] = yt.cur[1]);
      Y = !0, Fo(nt), ut(nt);
    }
    function ut(nt) {
      const yt = tt[0], Se = yt.point0;
      var ge;
      switch (j = yt[0] - Se[0], F = yt[1] - Se[1], _) {
        case jo:
        case yd: {
          E && (j = te(C - R, ee(O - w, j)), M = R + j, L = w + j), x && (F = te(H - P, ee(k - U, F)), B = P + F, Z = U + F);
          break;
        }
        case wr: {
          tt[1] ? (E && (M = te(C, ee(O, tt[0][0])), L = te(C, ee(O, tt[1][0])), E = 1), x && (B = te(H, ee(k, tt[0][1])), Z = te(H, ee(k, tt[1][1])), x = 1)) : (E < 0 ? (j = te(C - R, ee(O - R, j)), M = R + j, L = w) : E > 0 && (j = te(C - w, ee(O - w, j)), M = R, L = w + j), x < 0 ? (F = te(H - P, ee(k - P, F)), B = P + F, Z = U) : x > 0 && (F = te(H - U, ee(k - U, F)), B = P, Z = U + F));
          break;
        }
        case $r: {
          E && (M = te(C, ee(O, R - j * E)), L = te(C, ee(O, w + j * E))), x && (B = te(H, ee(k, P - F * x)), Z = te(H, ee(k, U + F * x)));
          break;
        }
      }
      L < M && (E *= -1, ge = R, R = w, w = ge, ge = M, M = L, L = ge, b in Ed && W.attr("cursor", hn[b = Ed[b]])), Z < B && (x *= -1, ge = P, P = U, U = ge, ge = B, B = Z, Z = ge, b in Od && W.attr("cursor", hn[b = Od[b]])), S.selection && (D = S.selection), Q && (M = D[0][0], L = D[1][0]), q && (B = D[0][1], Z = D[1][1]), (D[0][0] !== M || D[0][1] !== B || D[1][0] !== L || D[1][1] !== Z) && (S.selection = [[M, B], [L, Z]], c.call(v), lt.brush(nt, _.name));
    }
    function st(nt) {
      if (ZC(nt), nt.touches) {
        if (nt.touches.length) return;
        o && clearTimeout(o), o = setTimeout(function() {
          o = null;
        }, 500);
      } else
        WC(nt.view, Y), X.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      z.attr("pointer-events", "all"), W.attr("cursor", hn.overlay), S.selection && (D = S.selection), nA(D) && (S.selection = null, c.call(v)), lt.end(nt, _.name);
    }
    function kt(nt) {
      switch (nt.keyCode) {
        case 16: {
          ot = E && x;
          break;
        }
        case 18: {
          _ === wr && (E && (w = L - j * E, R = M + j * E), x && (U = Z - F * x, P = B + F * x), _ = $r, ut(nt));
          break;
        }
        case 32: {
          (_ === wr || _ === $r) && (E < 0 ? w = L - j : E > 0 && (R = M - j), x < 0 ? U = Z - F : x > 0 && (P = B - F), _ = jo, W.attr("cursor", hn.selection), ut(nt));
          break;
        }
        default:
          return;
      }
      Fo(nt);
    }
    function Nt(nt) {
      switch (nt.keyCode) {
        case 16: {
          ot && (Q = q = ot = !1, ut(nt));
          break;
        }
        case 18: {
          _ === $r && (E < 0 ? w = L : E > 0 && (R = M), x < 0 ? U = Z : x > 0 && (P = B), _ = wr, ut(nt));
          break;
        }
        case 32: {
          _ === jo && (nt.altKey ? (E && (w = L - j * E, R = M + j * E), x && (U = Z - F * x, P = B + F * x), _ = $r) : (E < 0 ? w = L : E > 0 && (R = M), x < 0 ? U = Z : x > 0 && (P = B), _ = wr), W.attr("cursor", hn[b]), ut(nt));
          break;
        }
        default:
          return;
      }
      Fo(nt);
    }
  }
  function p(m) {
    u(this, arguments).moved(m);
  }
  function f(m) {
    u(this, arguments).ended(m);
  }
  function g() {
    var m = this.__brush || { selection: null };
    return m.extent = _d(t.apply(this, arguments)), m.dim = e, m;
  }
  return l.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : zo(_d(m)), l) : t;
  }, l.filter = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : zo(!!m), l) : n;
  }, l.touchable = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : zo(!!m), l) : r;
  }, l.handleSize = function(m) {
    return arguments.length ? (a = +m, l) : a;
  }, l.keyModifiers = function(m) {
    return arguments.length ? (i = !!m, l) : i;
  }, l.on = function() {
    var m = s.on.apply(s, arguments);
    return m === s ? l : m;
  }, l;
}
const Hl = Math.PI, Vl = 2 * Hl, Xn = 1e-6, iA = Vl - Xn;
function kg(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function sA(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return kg;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, s = r.length; i < s; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
let Jc = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? kg : sA(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, s, a) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(t, n, r, i, s) {
    if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let a = this._x1, o = this._y1, l = r - t, c = i - n, u = a - t, d = o - n, h = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (h > Xn) if (!(Math.abs(d * l - c * u) > Xn) || !s)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let p = r - a, f = i - o, g = l * l + c * c, m = p * p + f * f, v = Math.sqrt(g), b = Math.sqrt(h), _ = s * Math.tan((Hl - Math.acos((g + h - m) / (2 * v * b))) / 2), E = _ / b, x = _ / v;
      Math.abs(E - 1) > Xn && this._append`L${t + E * u},${n + E * d}`, this._append`A${s},${s},0,0,${+(d * p > u * f)},${this._x1 = t + x * l},${this._y1 = n + x * c}`;
    }
  }
  arc(t, n, r, i, s, a) {
    if (t = +t, n = +n, r = +r, a = !!a, r < 0) throw new Error(`negative radius: ${r}`);
    let o = r * Math.cos(i), l = r * Math.sin(i), c = t + o, u = n + l, d = 1 ^ a, h = a ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${u}` : (Math.abs(this._x1 - c) > Xn || Math.abs(this._y1 - u) > Xn) && this._append`L${c},${u}`, r && (h < 0 && (h = h % Vl + Vl), h > iA ? this._append`A${r},${r},0,1,${d},${t - o},${n - l}A${r},${r},0,1,${d},${this._x1 = c},${this._y1 = u}` : h > Xn && this._append`A${r},${r},0,${+(h >= Hl)},${d},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
};
function Rg() {
  return new Jc();
}
Rg.prototype = Jc.prototype;
var Ot = 1e-6, Ig = 1e-12, ft = Math.PI, de = ft / 2, Sd = ft / 4, Ee = ft * 2, se = 180 / ft, Bt = ft / 180, St = Math.abs, Ng = Math.atan, lr = Math.atan2, Tt = Math.cos, aA = Math.exp, oA = Math.log, xt = Math.sin, Un = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, je = Math.sqrt, lA = Math.tan;
function cA(e) {
  return e > 1 ? 0 : e < -1 ? ft : Math.acos(e);
}
function Cn(e) {
  return e > 1 ? de : e < -1 ? -de : Math.asin(e);
}
function Ae() {
}
function $a(e, t) {
  e && wd.hasOwnProperty(e.type) && wd[e.type](e, t);
}
var Td = {
  Feature: function(e, t) {
    $a(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, r = -1, i = n.length; ++r < i; ) $a(n[r].geometry, t);
  }
}, wd = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; ) e = n[r], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    Gl(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; ) Gl(n[r], t, 0);
  },
  Polygon: function(e, t) {
    $d(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; ) $d(n[r], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, r = -1, i = n.length; ++r < i; ) $a(n[r], t);
  }
};
function Gl(e, t, n) {
  var r = -1, i = e.length - n, s;
  for (t.lineStart(); ++r < i; ) s = e[r], t.point(s[0], s[1], s[2]);
  t.lineEnd();
}
function $d(e, t) {
  var n = -1, r = e.length;
  for (t.polygonStart(); ++n < r; ) Gl(e[n], t, 1);
  t.polygonEnd();
}
function Dr(e, t) {
  e && Td.hasOwnProperty(e.type) ? Td[e.type](e, t) : $a(e, t);
}
function zl(e) {
  return [lr(e[1], e[0]), Cn(e[2])];
}
function ni(e) {
  var t = e[0], n = e[1], r = Tt(n);
  return [r * Tt(t), r * xt(t), xt(n)];
}
function ks(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function Ma(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function Yo(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function Rs(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function Fl(e) {
  var t = je(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
function jl(e, t) {
  function n(r, i) {
    return r = e(r, i), t(r[0], r[1]);
  }
  return e.invert && t.invert && (n.invert = function(r, i) {
    return r = t.invert(r, i), r && e.invert(r[0], r[1]);
  }), n;
}
function Wl(e, t) {
  return St(e) > ft && (e -= Math.round(e / Ee) * Ee), [e, t];
}
Wl.invert = Wl;
function Pg(e, t, n) {
  return (e %= Ee) ? t || n ? jl(Cd(e), Ad(t, n)) : Cd(e) : t || n ? Ad(t, n) : Wl;
}
function Md(e) {
  return function(t, n) {
    return t += e, St(t) > ft && (t -= Math.round(t / Ee) * Ee), [t, n];
  };
}
function Cd(e) {
  var t = Md(e);
  return t.invert = Md(-e), t;
}
function Ad(e, t) {
  var n = Tt(e), r = xt(e), i = Tt(t), s = xt(t);
  function a(o, l) {
    var c = Tt(l), u = Tt(o) * c, d = xt(o) * c, h = xt(l), p = h * n + u * r;
    return [
      lr(d * i - p * s, u * n - h * r),
      Cn(p * i + d * s)
    ];
  }
  return a.invert = function(o, l) {
    var c = Tt(l), u = Tt(o) * c, d = xt(o) * c, h = xt(l), p = h * i - d * s;
    return [
      lr(d * i + h * s, u * n + p * r),
      Cn(p * n - u * r)
    ];
  }, a;
}
function uA(e) {
  e = Pg(e[0] * Bt, e[1] * Bt, e.length > 2 ? e[2] * Bt : 0);
  function t(n) {
    return n = e(n[0] * Bt, n[1] * Bt), n[0] *= se, n[1] *= se, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * Bt, n[1] * Bt), n[0] *= se, n[1] *= se, n;
  }, t;
}
function hA(e, t, n, r, i, s) {
  if (n) {
    var a = Tt(t), o = xt(t), l = r * n;
    i == null ? (i = t + r * Ee, s = t - l / 2) : (i = Ld(a, i), s = Ld(a, s), (r > 0 ? i < s : i > s) && (i += r * Ee));
    for (var c, u = i; r > 0 ? u > s : u < s; u -= l)
      c = zl([a, -o * Tt(u), -o * xt(u)]), e.point(c[0], c[1]);
  }
}
function Ld(e, t) {
  t = ni(t), t[0] -= e, Fl(t);
  var n = cA(-t[1]);
  return ((-t[2] < 0 ? -n : n) + Ee - Ot) % Ee;
}
function Ug() {
  var e = [], t;
  return {
    point: function(n, r, i) {
      t.push([n, r, i]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: Ae,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function ea(e, t) {
  return St(e[0] - t[0]) < Ot && St(e[1] - t[1]) < Ot;
}
function Is(e, t, n, r) {
  this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;
}
function Bg(e, t, n, r, i) {
  var s = [], a = [], o, l;
  if (e.forEach(function(f) {
    if (!((g = f.length - 1) <= 0)) {
      var g, m = f[0], v = f[g], b;
      if (ea(m, v)) {
        if (!m[2] && !v[2]) {
          for (i.lineStart(), o = 0; o < g; ++o) i.point((m = f[o])[0], m[1]);
          i.lineEnd();
          return;
        }
        v[0] += 2 * Ot;
      }
      s.push(b = new Is(m, f, null, !0)), a.push(b.o = new Is(m, null, b, !1)), s.push(b = new Is(v, f, null, !1)), a.push(b.o = new Is(v, null, b, !0));
    }
  }), !!s.length) {
    for (a.sort(t), Dd(s), Dd(a), o = 0, l = a.length; o < l; ++o)
      a[o].e = n = !n;
    for (var c = s[0], u, d; ; ) {
      for (var h = c, p = !0; h.v; ) if ((h = h.n) === c) return;
      u = h.z, i.lineStart();
      do {
        if (h.v = h.o.v = !0, h.e) {
          if (p)
            for (o = 0, l = u.length; o < l; ++o) i.point((d = u[o])[0], d[1]);
          else
            r(h.x, h.n.x, 1, i);
          h = h.n;
        } else {
          if (p)
            for (u = h.p.z, o = u.length - 1; o >= 0; --o) i.point((d = u[o])[0], d[1]);
          else
            r(h.x, h.p.x, -1, i);
          h = h.p;
        }
        h = h.o, u = h.z, p = !p;
      } while (!h.v);
      i.lineEnd();
    }
  }
}
function Dd(e) {
  if (t = e.length) {
    for (var t, n = 0, r = e[0], i; ++n < t; )
      r.n = i = e[n], i.p = r, r = i;
    r.n = i = e[0], i.p = r;
  }
}
function Xo(e) {
  return St(e[0]) <= ft ? e[0] : Un(e[0]) * ((St(e[0]) + ft) % Ee - ft);
}
function dA(e, t) {
  var n = Xo(t), r = t[1], i = xt(r), s = [xt(n), -Tt(n), 0], a = 0, o = 0, l = new or();
  i === 1 ? r = de + Ot : i === -1 && (r = -de - Ot);
  for (var c = 0, u = e.length; c < u; ++c)
    if (h = (d = e[c]).length)
      for (var d, h, p = d[h - 1], f = Xo(p), g = p[1] / 2 + Sd, m = xt(g), v = Tt(g), b = 0; b < h; ++b, f = E, m = S, v = $, p = _) {
        var _ = d[b], E = Xo(_), x = _[1] / 2 + Sd, S = xt(x), $ = Tt(x), D = E - f, C = D >= 0 ? 1 : -1, R = C * D, M = R > ft, H = m * S;
        if (l.add(lr(H * C * xt(R), v * $ + H * Tt(R))), a += M ? D + C * Ee : D, M ^ f >= n ^ E >= n) {
          var P = Ma(ni(p), ni(_));
          Fl(P);
          var B = Ma(s, P);
          Fl(B);
          var O = (M ^ D >= 0 ? -1 : 1) * Cn(B[2]);
          (r > O || r === O && (P[0] || P[1])) && (o += M ^ D >= 0 ? 1 : -1);
        }
      }
  return (a < -Ot || a < Ot && l < -Ig) ^ o & 1;
}
function Hg(e, t, n, r) {
  return function(i) {
    var s = t(i), a = Ug(), o = t(a), l = !1, c, u, d, h = {
      point: p,
      lineStart: g,
      lineEnd: m,
      polygonStart: function() {
        h.point = v, h.lineStart = b, h.lineEnd = _, u = [], c = [];
      },
      polygonEnd: function() {
        h.point = p, h.lineStart = g, h.lineEnd = m, u = Ag(u);
        var E = dA(c, r);
        u.length ? (l || (i.polygonStart(), l = !0), Bg(u, fA, E, n, i)) : E && (l || (i.polygonStart(), l = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), u = c = null;
      },
      sphere: function() {
        i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();
      }
    };
    function p(E, x) {
      e(E, x) && i.point(E, x);
    }
    function f(E, x) {
      s.point(E, x);
    }
    function g() {
      h.point = f, s.lineStart();
    }
    function m() {
      h.point = p, s.lineEnd();
    }
    function v(E, x) {
      d.push([E, x]), o.point(E, x);
    }
    function b() {
      o.lineStart(), d = [];
    }
    function _() {
      v(d[0][0], d[0][1]), o.lineEnd();
      var E = o.clean(), x = a.result(), S, $ = x.length, D, C, R;
      if (d.pop(), c.push(d), d = null, !!$) {
        if (E & 1) {
          if (C = x[0], (D = C.length - 1) > 0) {
            for (l || (i.polygonStart(), l = !0), i.lineStart(), S = 0; S < D; ++S) i.point((R = C[S])[0], R[1]);
            i.lineEnd();
          }
          return;
        }
        $ > 1 && E & 2 && x.push(x.pop().concat(x.shift())), u.push(x.filter(pA));
      }
    }
    return h;
  };
}
function pA(e) {
  return e.length > 1;
}
function fA(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - de - Ot : de - e[1]) - ((t = t.x)[0] < 0 ? t[1] - de - Ot : de - t[1]);
}
const kd = Hg(
  function() {
    return !0;
  },
  mA,
  vA,
  [-ft, -de]
);
function mA(e) {
  var t = NaN, n = NaN, r = NaN, i;
  return {
    lineStart: function() {
      e.lineStart(), i = 1;
    },
    point: function(s, a) {
      var o = s > 0 ? ft : -ft, l = St(s - t);
      St(l - ft) < Ot ? (e.point(t, n = (n + a) / 2 > 0 ? de : -de), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), i = 0) : r !== o && l >= ft && (St(t - r) < Ot && (t -= r * Ot), St(s - o) < Ot && (s -= o * Ot), n = gA(t, n, s, a), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), i = 0), e.point(t = s, n = a), r = o;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function gA(e, t, n, r) {
  var i, s, a = xt(e - n);
  return St(a) > Ot ? Ng((xt(t) * (s = Tt(r)) * xt(n) - xt(r) * (i = Tt(t)) * xt(e)) / (i * s * a)) : (t + r) / 2;
}
function vA(e, t, n, r) {
  var i;
  if (e == null)
    i = n * de, r.point(-ft, i), r.point(0, i), r.point(ft, i), r.point(ft, 0), r.point(ft, -i), r.point(0, -i), r.point(-ft, -i), r.point(-ft, 0), r.point(-ft, i);
  else if (St(e[0] - t[0]) > Ot) {
    var s = e[0] < t[0] ? ft : -ft;
    i = n * s / 2, r.point(-s, i), r.point(0, i), r.point(s, i);
  } else
    r.point(t[0], t[1]);
}
function yA(e) {
  var t = Tt(e), n = 2 * Bt, r = t > 0, i = St(t) > Ot;
  function s(u, d, h, p) {
    hA(p, e, n, h, u, d);
  }
  function a(u, d) {
    return Tt(u) * Tt(d) > t;
  }
  function o(u) {
    var d, h, p, f, g;
    return {
      lineStart: function() {
        f = p = !1, g = 1;
      },
      point: function(m, v) {
        var b = [m, v], _, E = a(m, v), x = r ? E ? 0 : c(m, v) : E ? c(m + (m < 0 ? ft : -ft), v) : 0;
        if (!d && (f = p = E) && u.lineStart(), E !== p && (_ = l(d, b), (!_ || ea(d, _) || ea(b, _)) && (b[2] = 1)), E !== p)
          g = 0, E ? (u.lineStart(), _ = l(b, d), u.point(_[0], _[1])) : (_ = l(d, b), u.point(_[0], _[1], 2), u.lineEnd()), d = _;
        else if (i && d && r ^ E) {
          var S;
          !(x & h) && (S = l(b, d, !0)) && (g = 0, r ? (u.lineStart(), u.point(S[0][0], S[0][1]), u.point(S[1][0], S[1][1]), u.lineEnd()) : (u.point(S[1][0], S[1][1]), u.lineEnd(), u.lineStart(), u.point(S[0][0], S[0][1], 3)));
        }
        E && (!d || !ea(d, b)) && u.point(b[0], b[1]), d = b, p = E, h = x;
      },
      lineEnd: function() {
        p && u.lineEnd(), d = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return g | (f && p) << 1;
      }
    };
  }
  function l(u, d, h) {
    var p = ni(u), f = ni(d), g = [1, 0, 0], m = Ma(p, f), v = ks(m, m), b = m[0], _ = v - b * b;
    if (!_) return !h && u;
    var E = t * v / _, x = -t * b / _, S = Ma(g, m), $ = Rs(g, E), D = Rs(m, x);
    Yo($, D);
    var C = S, R = ks($, C), M = ks(C, C), H = R * R - M * (ks($, $) - 1);
    if (!(H < 0)) {
      var P = je(H), B = Rs(C, (-R - P) / M);
      if (Yo(B, $), B = zl(B), !h) return B;
      var O = u[0], w = d[0], L = u[1], k = d[1], U;
      w < O && (U = O, O = w, w = U);
      var Z = w - O, j = St(Z - ft) < Ot, F = j || Z < Ot;
      if (!j && k < L && (U = L, L = k, k = U), F ? j ? L + k > 0 ^ B[1] < (St(B[0] - O) < Ot ? L : k) : L <= B[1] && B[1] <= k : Z > ft ^ (O <= B[0] && B[0] <= w)) {
        var Y = Rs(C, (-R + P) / M);
        return Yo(Y, $), [B, zl(Y)];
      }
    }
  }
  function c(u, d) {
    var h = r ? e : ft - e, p = 0;
    return u < -h ? p |= 1 : u > h && (p |= 2), d < -h ? p |= 4 : d > h && (p |= 8), p;
  }
  return Hg(a, o, s, r ? [0, -e] : [-ft, e - ft]);
}
function xA(e, t, n, r, i, s) {
  var a = e[0], o = e[1], l = t[0], c = t[1], u = 0, d = 1, h = l - a, p = c - o, f;
  if (f = n - a, !(!h && f > 0)) {
    if (f /= h, h < 0) {
      if (f < u) return;
      f < d && (d = f);
    } else if (h > 0) {
      if (f > d) return;
      f > u && (u = f);
    }
    if (f = i - a, !(!h && f < 0)) {
      if (f /= h, h < 0) {
        if (f > d) return;
        f > u && (u = f);
      } else if (h > 0) {
        if (f < u) return;
        f < d && (d = f);
      }
      if (f = r - o, !(!p && f > 0)) {
        if (f /= p, p < 0) {
          if (f < u) return;
          f < d && (d = f);
        } else if (p > 0) {
          if (f > d) return;
          f > u && (u = f);
        }
        if (f = s - o, !(!p && f < 0)) {
          if (f /= p, p < 0) {
            if (f > d) return;
            f > u && (u = f);
          } else if (p > 0) {
            if (f < u) return;
            f < d && (d = f);
          }
          return u > 0 && (e[0] = a + u * h, e[1] = o + u * p), d < 1 && (t[0] = a + d * h, t[1] = o + d * p), !0;
        }
      }
    }
  }
}
var Li = 1e9, Ns = -Li;
function bA(e, t, n, r) {
  function i(c, u) {
    return e <= c && c <= n && t <= u && u <= r;
  }
  function s(c, u, d, h) {
    var p = 0, f = 0;
    if (c == null || (p = a(c, d)) !== (f = a(u, d)) || l(c, u) < 0 ^ d > 0)
      do
        h.point(p === 0 || p === 3 ? e : n, p > 1 ? r : t);
      while ((p = (p + d + 4) % 4) !== f);
    else
      h.point(u[0], u[1]);
  }
  function a(c, u) {
    return St(c[0] - e) < Ot ? u > 0 ? 0 : 3 : St(c[0] - n) < Ot ? u > 0 ? 2 : 1 : St(c[1] - t) < Ot ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
  }
  function o(c, u) {
    return l(c.x, u.x);
  }
  function l(c, u) {
    var d = a(c, 1), h = a(u, 1);
    return d !== h ? d - h : d === 0 ? u[1] - c[1] : d === 1 ? c[0] - u[0] : d === 2 ? c[1] - u[1] : u[0] - c[0];
  }
  return function(c) {
    var u = c, d = Ug(), h, p, f, g, m, v, b, _, E, x, S, $ = {
      point: D,
      lineStart: H,
      lineEnd: P,
      polygonStart: R,
      polygonEnd: M
    };
    function D(O, w) {
      i(O, w) && u.point(O, w);
    }
    function C() {
      for (var O = 0, w = 0, L = p.length; w < L; ++w)
        for (var k = p[w], U = 1, Z = k.length, j = k[0], F, Y, ot = j[0], Q = j[1]; U < Z; ++U)
          F = ot, Y = Q, j = k[U], ot = j[0], Q = j[1], Y <= r ? Q > r && (ot - F) * (r - Y) > (Q - Y) * (e - F) && ++O : Q <= r && (ot - F) * (r - Y) < (Q - Y) * (e - F) && --O;
      return O;
    }
    function R() {
      u = d, h = [], p = [], S = !0;
    }
    function M() {
      var O = C(), w = S && O, L = (h = Ag(h)).length;
      (w || L) && (c.polygonStart(), w && (c.lineStart(), s(null, null, 1, c), c.lineEnd()), L && Bg(h, o, O, s, c), c.polygonEnd()), u = c, h = p = f = null;
    }
    function H() {
      $.point = B, p && p.push(f = []), x = !0, E = !1, b = _ = NaN;
    }
    function P() {
      h && (B(g, m), v && E && d.rejoin(), h.push(d.result())), $.point = D, E && u.lineEnd();
    }
    function B(O, w) {
      var L = i(O, w);
      if (p && f.push([O, w]), x)
        g = O, m = w, v = L, x = !1, L && (u.lineStart(), u.point(O, w));
      else if (L && E) u.point(O, w);
      else {
        var k = [b = Math.max(Ns, Math.min(Li, b)), _ = Math.max(Ns, Math.min(Li, _))], U = [O = Math.max(Ns, Math.min(Li, O)), w = Math.max(Ns, Math.min(Li, w))];
        xA(k, U, e, t, n, r) ? (E || (u.lineStart(), u.point(k[0], k[1])), u.point(U[0], U[1]), L || u.lineEnd(), S = !1) : L && (u.lineStart(), u.point(O, w), S = !1);
      }
      b = O, _ = w, E = L;
    }
    return $;
  };
}
const ql = (e) => e;
var Zo = new or(), Yl = new or(), Vg, Gg, Xl, Zl, xn = {
  point: Ae,
  lineStart: Ae,
  lineEnd: Ae,
  polygonStart: function() {
    xn.lineStart = _A, xn.lineEnd = OA;
  },
  polygonEnd: function() {
    xn.lineStart = xn.lineEnd = xn.point = Ae, Zo.add(St(Yl)), Yl = new or();
  },
  result: function() {
    var e = Zo / 2;
    return Zo = new or(), e;
  }
};
function _A() {
  xn.point = EA;
}
function EA(e, t) {
  xn.point = zg, Vg = Xl = e, Gg = Zl = t;
}
function zg(e, t) {
  Yl.add(Zl * e - Xl * t), Xl = e, Zl = t;
}
function OA() {
  zg(Vg, Gg);
}
var ri = 1 / 0, Ca = ri, ss = -ri, Aa = ss, La = {
  point: SA,
  lineStart: Ae,
  lineEnd: Ae,
  polygonStart: Ae,
  polygonEnd: Ae,
  result: function() {
    var e = [[ri, Ca], [ss, Aa]];
    return ss = Aa = -(Ca = ri = 1 / 0), e;
  }
};
function SA(e, t) {
  e < ri && (ri = e), e > ss && (ss = e), t < Ca && (Ca = t), t > Aa && (Aa = t);
}
var Kl = 0, Ql = 0, Di = 0, Da = 0, ka = 0, Vr = 0, Jl = 0, tc = 0, ki = 0, Fg, jg, Qe, Je, Me = {
  point: cr,
  lineStart: Rd,
  lineEnd: Id,
  polygonStart: function() {
    Me.lineStart = $A, Me.lineEnd = MA;
  },
  polygonEnd: function() {
    Me.point = cr, Me.lineStart = Rd, Me.lineEnd = Id;
  },
  result: function() {
    var e = ki ? [Jl / ki, tc / ki] : Vr ? [Da / Vr, ka / Vr] : Di ? [Kl / Di, Ql / Di] : [NaN, NaN];
    return Kl = Ql = Di = Da = ka = Vr = Jl = tc = ki = 0, e;
  }
};
function cr(e, t) {
  Kl += e, Ql += t, ++Di;
}
function Rd() {
  Me.point = TA;
}
function TA(e, t) {
  Me.point = wA, cr(Qe = e, Je = t);
}
function wA(e, t) {
  var n = e - Qe, r = t - Je, i = je(n * n + r * r);
  Da += i * (Qe + e) / 2, ka += i * (Je + t) / 2, Vr += i, cr(Qe = e, Je = t);
}
function Id() {
  Me.point = cr;
}
function $A() {
  Me.point = CA;
}
function MA() {
  Wg(Fg, jg);
}
function CA(e, t) {
  Me.point = Wg, cr(Fg = Qe = e, jg = Je = t);
}
function Wg(e, t) {
  var n = e - Qe, r = t - Je, i = je(n * n + r * r);
  Da += i * (Qe + e) / 2, ka += i * (Je + t) / 2, Vr += i, i = Je * e - Qe * t, Jl += i * (Qe + e), tc += i * (Je + t), ki += i * 3, cr(Qe = e, Je = t);
}
function qg(e) {
  this._context = e;
}
qg.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Ee);
        break;
      }
    }
  },
  result: Ae
};
var ec = new or(), Ko, Yg, Xg, Ri, Ii, as = {
  point: Ae,
  lineStart: function() {
    as.point = AA;
  },
  lineEnd: function() {
    Ko && Zg(Yg, Xg), as.point = Ae;
  },
  polygonStart: function() {
    Ko = !0;
  },
  polygonEnd: function() {
    Ko = null;
  },
  result: function() {
    var e = +ec;
    return ec = new or(), e;
  }
};
function AA(e, t) {
  as.point = Zg, Yg = Ri = e, Xg = Ii = t;
}
function Zg(e, t) {
  Ri -= e, Ii -= t, ec.add(je(Ri * Ri + Ii * Ii)), Ri = e, Ii = t;
}
let Nd, Ra, Pd, Ud;
class Bd {
  constructor(t) {
    this._append = t == null ? Kg : LA(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== Pd || this._append !== Ra) {
          const r = this._radius, i = this._;
          this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, Pd = r, Ra = this._append, Ud = this._, this._ = i;
        }
        this._ += Ud;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function Kg(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function LA(e) {
  const t = Math.floor(e);
  if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
  if (t > 15) return Kg;
  if (t !== Nd) {
    const n = 10 ** t;
    Nd = t, Ra = function(r) {
      let i = 1;
      this._ += r[0];
      for (const s = r.length; i < s; ++i)
        this._ += Math.round(arguments[i] * n) / n + r[i];
    };
  }
  return Ra;
}
function DA(e, t) {
  let n = 3, r = 4.5, i, s;
  function a(o) {
    return o && (typeof r == "function" && s.pointRadius(+r.apply(this, arguments)), Dr(o, i(s))), s.result();
  }
  return a.area = function(o) {
    return Dr(o, i(xn)), xn.result();
  }, a.measure = function(o) {
    return Dr(o, i(as)), as.result();
  }, a.bounds = function(o) {
    return Dr(o, i(La)), La.result();
  }, a.centroid = function(o) {
    return Dr(o, i(Me)), Me.result();
  }, a.projection = function(o) {
    return arguments.length ? (i = o == null ? (e = null, ql) : (e = o).stream, a) : e;
  }, a.context = function(o) {
    return arguments.length ? (s = o == null ? (t = null, new Bd(n)) : new qg(t = o), typeof r != "function" && s.pointRadius(r), a) : t;
  }, a.pointRadius = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : r;
  }, a.digits = function(o) {
    if (!arguments.length) return n;
    if (o == null) n = null;
    else {
      const l = Math.floor(o);
      if (!(l >= 0)) throw new RangeError(`invalid digits: ${o}`);
      n = l;
    }
    return t === null && (s = new Bd(n)), a;
  }, a.projection(e).digits(n).context(t);
}
function tu(e) {
  return function(t) {
    var n = new nc();
    for (var r in e) n[r] = e[r];
    return n.stream = t, n;
  };
}
function nc() {
}
nc.prototype = {
  constructor: nc,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function eu(e, t, n) {
  var r = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), Dr(n, e.stream(La)), t(La.result()), r != null && e.clipExtent(r), e;
}
function Qg(e, t, n) {
  return eu(e, function(r) {
    var i = t[1][0] - t[0][0], s = t[1][1] - t[0][1], a = Math.min(i / (r[1][0] - r[0][0]), s / (r[1][1] - r[0][1])), o = +t[0][0] + (i - a * (r[1][0] + r[0][0])) / 2, l = +t[0][1] + (s - a * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * a).translate([o, l]);
  }, n);
}
function kA(e, t, n) {
  return Qg(e, [[0, 0], t], n);
}
function RA(e, t, n) {
  return eu(e, function(r) {
    var i = +t, s = i / (r[1][0] - r[0][0]), a = (i - s * (r[1][0] + r[0][0])) / 2, o = -s * r[0][1];
    e.scale(150 * s).translate([a, o]);
  }, n);
}
function IA(e, t, n) {
  return eu(e, function(r) {
    var i = +t, s = i / (r[1][1] - r[0][1]), a = -s * r[0][0], o = (i - s * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * s).translate([a, o]);
  }, n);
}
var Hd = 16, NA = Tt(30 * Bt);
function Vd(e, t) {
  return +t ? UA(e, t) : PA(e);
}
function PA(e) {
  return tu({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function UA(e, t) {
  function n(r, i, s, a, o, l, c, u, d, h, p, f, g, m) {
    var v = c - r, b = u - i, _ = v * v + b * b;
    if (_ > 4 * t && g--) {
      var E = a + h, x = o + p, S = l + f, $ = je(E * E + x * x + S * S), D = Cn(S /= $), C = St(St(S) - 1) < Ot || St(s - d) < Ot ? (s + d) / 2 : lr(x, E), R = e(C, D), M = R[0], H = R[1], P = M - r, B = H - i, O = b * P - v * B;
      (O * O / _ > t || St((v * P + b * B) / _ - 0.5) > 0.3 || a * h + o * p + l * f < NA) && (n(r, i, s, a, o, l, M, H, C, E /= $, x /= $, S, g, m), m.point(M, H), n(M, H, C, E, x, S, c, u, d, h, p, f, g, m));
    }
  }
  return function(r) {
    var i, s, a, o, l, c, u, d, h, p, f, g, m = {
      point: v,
      lineStart: b,
      lineEnd: E,
      polygonStart: function() {
        r.polygonStart(), m.lineStart = x;
      },
      polygonEnd: function() {
        r.polygonEnd(), m.lineStart = b;
      }
    };
    function v(D, C) {
      D = e(D, C), r.point(D[0], D[1]);
    }
    function b() {
      d = NaN, m.point = _, r.lineStart();
    }
    function _(D, C) {
      var R = ni([D, C]), M = e(D, C);
      n(d, h, u, p, f, g, d = M[0], h = M[1], u = D, p = R[0], f = R[1], g = R[2], Hd, r), r.point(d, h);
    }
    function E() {
      m.point = v, r.lineEnd();
    }
    function x() {
      b(), m.point = S, m.lineEnd = $;
    }
    function S(D, C) {
      _(i = D, C), s = d, a = h, o = p, l = f, c = g, m.point = _;
    }
    function $() {
      n(d, h, u, p, f, g, s, a, i, o, l, c, Hd, r), m.lineEnd = E, E();
    }
    return m;
  };
}
var BA = tu({
  point: function(e, t) {
    this.stream.point(e * Bt, t * Bt);
  }
});
function HA(e) {
  return tu({
    point: function(t, n) {
      var r = e(t, n);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function VA(e, t, n, r, i) {
  function s(a, o) {
    return a *= r, o *= i, [t + e * a, n - e * o];
  }
  return s.invert = function(a, o) {
    return [(a - t) / e * r, (n - o) / e * i];
  }, s;
}
function Gd(e, t, n, r, i, s) {
  if (!s) return VA(e, t, n, r, i);
  var a = Tt(s), o = xt(s), l = a * e, c = o * e, u = a / e, d = o / e, h = (o * n - a * t) / e, p = (o * t + a * n) / e;
  function f(g, m) {
    return g *= r, m *= i, [l * g - c * m + t, n - c * g - l * m];
  }
  return f.invert = function(g, m) {
    return [r * (u * g - d * m + h), i * (p - d * g - u * m)];
  }, f;
}
function uo(e) {
  return Jg(function() {
    return e;
  })();
}
function Jg(e) {
  var t, n = 150, r = 480, i = 250, s = 0, a = 0, o = 0, l = 0, c = 0, u, d = 0, h = 1, p = 1, f = null, g = kd, m = null, v, b, _, E = ql, x = 0.5, S, $, D, C, R;
  function M(O) {
    return D(O[0] * Bt, O[1] * Bt);
  }
  function H(O) {
    return O = D.invert(O[0], O[1]), O && [O[0] * se, O[1] * se];
  }
  M.stream = function(O) {
    return C && R === O ? C : C = BA(HA(u)(g(S(E(R = O)))));
  }, M.preclip = function(O) {
    return arguments.length ? (g = O, f = void 0, B()) : g;
  }, M.postclip = function(O) {
    return arguments.length ? (E = O, m = v = b = _ = null, B()) : E;
  }, M.clipAngle = function(O) {
    return arguments.length ? (g = +O ? yA(f = O * Bt) : (f = null, kd), B()) : f * se;
  }, M.clipExtent = function(O) {
    return arguments.length ? (E = O == null ? (m = v = b = _ = null, ql) : bA(m = +O[0][0], v = +O[0][1], b = +O[1][0], _ = +O[1][1]), B()) : m == null ? null : [[m, v], [b, _]];
  }, M.scale = function(O) {
    return arguments.length ? (n = +O, P()) : n;
  }, M.translate = function(O) {
    return arguments.length ? (r = +O[0], i = +O[1], P()) : [r, i];
  }, M.center = function(O) {
    return arguments.length ? (s = O[0] % 360 * Bt, a = O[1] % 360 * Bt, P()) : [s * se, a * se];
  }, M.rotate = function(O) {
    return arguments.length ? (o = O[0] % 360 * Bt, l = O[1] % 360 * Bt, c = O.length > 2 ? O[2] % 360 * Bt : 0, P()) : [o * se, l * se, c * se];
  }, M.angle = function(O) {
    return arguments.length ? (d = O % 360 * Bt, P()) : d * se;
  }, M.reflectX = function(O) {
    return arguments.length ? (h = O ? -1 : 1, P()) : h < 0;
  }, M.reflectY = function(O) {
    return arguments.length ? (p = O ? -1 : 1, P()) : p < 0;
  }, M.precision = function(O) {
    return arguments.length ? (S = Vd($, x = O * O), B()) : je(x);
  }, M.fitExtent = function(O, w) {
    return Qg(M, O, w);
  }, M.fitSize = function(O, w) {
    return kA(M, O, w);
  }, M.fitWidth = function(O, w) {
    return RA(M, O, w);
  }, M.fitHeight = function(O, w) {
    return IA(M, O, w);
  };
  function P() {
    var O = Gd(n, 0, 0, h, p, d).apply(null, t(s, a)), w = Gd(n, r - O[0], i - O[1], h, p, d);
    return u = Pg(o, l, c), $ = jl(t, w), D = jl(u, $), S = Vd($, x), B();
  }
  function B() {
    return C = R = null, M;
  }
  return function() {
    return t = e.apply(this, arguments), M.invert = t.invert && H, P();
  };
}
function tv(e) {
  var t = 0, n = ft / 3, r = Jg(e), i = r(t, n);
  return i.parallels = function(s) {
    return arguments.length ? r(t = s[0] * Bt, n = s[1] * Bt) : [t * se, n * se];
  }, i;
}
function GA(e) {
  var t = Tt(e);
  function n(r, i) {
    return [r * t, xt(i) / t];
  }
  return n.invert = function(r, i) {
    return [r / t, Cn(i * t)];
  }, n;
}
function zA(e, t) {
  var n = xt(e), r = (n + xt(t)) / 2;
  if (St(r) < Ot) return GA(e);
  var i = 1 + n * (2 * r - n), s = je(i) / r;
  function a(o, l) {
    var c = je(i - 2 * r * xt(l)) / r;
    return [c * xt(o *= r), s - c * Tt(o)];
  }
  return a.invert = function(o, l) {
    var c = s - l, u = lr(o, St(c)) * Un(c);
    return c * r < 0 && (u -= ft * Un(o) * Un(c)), [u / r, Cn((i - (o * o + c * c) * r * r) / (2 * r))];
  }, a;
}
function ev() {
  return tv(zA).scale(155.424).center([0, 33.6442]);
}
function FA() {
  return ev().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function nu(e, t) {
  return [e, oA(lA((de + t) / 2))];
}
nu.invert = function(e, t) {
  return [e, 2 * Ng(aA(t)) - de];
};
function jA() {
  return WA(nu).scale(961 / Ee);
}
function WA(e) {
  var t = uo(e), n = t.center, r = t.scale, i = t.translate, s = t.clipExtent, a = null, o, l, c;
  t.scale = function(d) {
    return arguments.length ? (r(d), u()) : r();
  }, t.translate = function(d) {
    return arguments.length ? (i(d), u()) : i();
  }, t.center = function(d) {
    return arguments.length ? (n(d), u()) : n();
  }, t.clipExtent = function(d) {
    return arguments.length ? (d == null ? a = o = l = c = null : (a = +d[0][0], o = +d[0][1], l = +d[1][0], c = +d[1][1]), u()) : a == null ? null : [[a, o], [l, c]];
  };
  function u() {
    var d = ft * r(), h = t(uA(t.rotate()).invert([0, 0]));
    return s(a == null ? [[h[0] - d, h[1] - d], [h[0] + d, h[1] + d]] : e === nu ? [[Math.max(h[0] - d, a), o], [Math.min(h[0] + d, l), c]] : [[a, Math.max(h[1] - d, o)], [l, Math.min(h[1] + d, c)]]);
  }
  return u();
}
function Ia(e, t) {
  return [e, t];
}
Ia.invert = Ia;
function qA() {
  return uo(Ia).scale(152.63);
}
function YA(e, t) {
  var n = Tt(e), r = e === t ? xt(e) : (n - Tt(t)) / (t - e), i = n / r + e;
  if (St(r) < Ot) return Ia;
  function s(a, o) {
    var l = i - o, c = r * a;
    return [l * xt(c), i - l * Tt(c)];
  }
  return s.invert = function(a, o) {
    var l = i - o, c = lr(a, St(l)) * Un(l);
    return l * r < 0 && (c -= ft * Un(a) * Un(l)), [c / r, i - Un(r) * je(a * a + l * l)];
  }, s;
}
function XA() {
  return tv(YA).scale(131.154).center([0, 13.9389]);
}
var Gi = 1.340264, zi = -0.081106, Fi = 893e-6, ji = 3796e-6, Na = je(3) / 2, ZA = 12;
function nv(e, t) {
  var n = Cn(Na * xt(t)), r = n * n, i = r * r * r;
  return [
    e * Tt(n) / (Na * (Gi + 3 * zi * r + i * (7 * Fi + 9 * ji * r))),
    n * (Gi + zi * r + i * (Fi + ji * r))
  ];
}
nv.invert = function(e, t) {
  for (var n = t, r = n * n, i = r * r * r, s = 0, a, o, l; s < ZA && (o = n * (Gi + zi * r + i * (Fi + ji * r)) - t, l = Gi + 3 * zi * r + i * (7 * Fi + 9 * ji * r), n -= a = o / l, r = n * n, i = r * r * r, !(St(a) < Ig)); ++s)
    ;
  return [
    Na * e * (Gi + 3 * zi * r + i * (7 * Fi + 9 * ji * r)) / Tt(n),
    Cn(xt(n) / Na)
  ];
};
function KA() {
  return uo(nv).scale(177.158);
}
function rv(e, t) {
  var n = t * t, r = n * n;
  return [
    e * (0.8707 - 0.131979 * n + r * (-0.013791 + r * (3971e-6 * n - 1529e-6 * r))),
    t * (1.007226 + n * (0.015085 + r * (-0.044475 + 0.028874 * n - 5916e-6 * r)))
  ];
}
rv.invert = function(e, t) {
  var n = t, r = 25, i;
  do {
    var s = n * n, a = s * s;
    n -= i = (n * (1.007226 + s * (0.015085 + a * (-0.044475 + 0.028874 * s - 5916e-6 * a))) - t) / (1.007226 + s * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * s - 5916e-6 * 11 * a)));
  } while (St(i) > Ot && --r > 0);
  return [
    e / (0.8707 + (s = n * n) * (-0.131979 + s * (-0.013791 + s * s * s * (3971e-6 - 1529e-6 * s)))),
    n
  ];
};
function QA() {
  return uo(rv).scale(175.295);
}
function JA(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function tL(e) {
  return e.reduce(eL, 0) / e.length;
}
function eL(e, t) {
  return e + t.x;
}
function nL(e) {
  return 1 + e.reduce(rL, 0);
}
function rL(e, t) {
  return Math.max(e, t.y);
}
function iL(e) {
  for (var t; t = e.children; ) e = t[0];
  return e;
}
function sL(e) {
  for (var t; t = e.children; ) e = t[t.length - 1];
  return e;
}
function aL() {
  var e = JA, t = 1, n = 1, r = !1;
  function i(s) {
    var a, o = 0;
    s.eachAfter(function(h) {
      var p = h.children;
      p ? (h.x = tL(p), h.y = nL(p)) : (h.x = a ? o += e(h, a) : 0, h.y = 0, a = h);
    });
    var l = iL(s), c = sL(s), u = l.x - e(l, c) / 2, d = c.x + e(c, l) / 2;
    return s.eachAfter(r ? function(h) {
      h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n;
    } : function(h) {
      h.x = (h.x - u) / (d - u) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n;
    });
  }
  return i.separation = function(s) {
    return arguments.length ? (e = s, i) : e;
  }, i.size = function(s) {
    return arguments.length ? (r = !1, t = +s[0], n = +s[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(s) {
    return arguments.length ? (r = !0, t = +s[0], n = +s[1], i) : r ? [t, n] : null;
  }, i;
}
function oL(e) {
  var t = 0, n = e.children, r = n && n.length;
  if (!r) t = 1;
  else for (; --r >= 0; ) t += n[r].value;
  e.value = t;
}
function lL() {
  return this.eachAfter(oL);
}
function cL(e, t) {
  let n = -1;
  for (const r of this)
    e.call(t, r, ++n, this);
  return this;
}
function uL(e, t) {
  for (var n = this, r = [n], i, s, a = -1; n = r.pop(); )
    if (e.call(t, n, ++a, this), i = n.children)
      for (s = i.length - 1; s >= 0; --s)
        r.push(i[s]);
  return this;
}
function hL(e, t) {
  for (var n = this, r = [n], i = [], s, a, o, l = -1; n = r.pop(); )
    if (i.push(n), s = n.children)
      for (a = 0, o = s.length; a < o; ++a)
        r.push(s[a]);
  for (; n = i.pop(); )
    e.call(t, n, ++l, this);
  return this;
}
function dL(e, t) {
  let n = -1;
  for (const r of this)
    if (e.call(t, r, ++n, this))
      return r;
}
function pL(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; ) n += r[i].value;
    t.value = n;
  });
}
function fL(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function mL(e) {
  for (var t = this, n = gL(t, e), r = [t]; t !== n; )
    t = t.parent, r.push(t);
  for (var i = r.length; e !== n; )
    r.splice(i, 0, e), e = e.parent;
  return r;
}
function gL(e, t) {
  if (e === t) return e;
  var n = e.ancestors(), r = t.ancestors(), i = null;
  for (e = n.pop(), t = r.pop(); e === t; )
    i = e, e = n.pop(), t = r.pop();
  return i;
}
function vL() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function yL() {
  return Array.from(this);
}
function xL() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function bL() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* _L() {
  var e = this, t, n = [e], r, i, s;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, r = e.children)
        for (i = 0, s = r.length; i < s; ++i)
          n.push(r[i]);
  while (n.length);
}
function xs(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = SL)) : t === void 0 && (t = OL);
  for (var n = new os(e), r, i = [n], s, a, o, l; r = i.pop(); )
    if ((a = t(r.data)) && (l = (a = Array.from(a)).length))
      for (r.children = a, o = l - 1; o >= 0; --o)
        i.push(s = a[o] = new os(a[o])), s.parent = r, s.depth = r.depth + 1;
  return n.eachBefore(wL);
}
function EL() {
  return xs(this).eachBefore(TL);
}
function OL(e) {
  return e.children;
}
function SL(e) {
  return Array.isArray(e) ? e[1] : null;
}
function TL(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function wL(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function os(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
os.prototype = xs.prototype = {
  constructor: os,
  count: lL,
  each: cL,
  eachAfter: hL,
  eachBefore: uL,
  find: dL,
  sum: pL,
  sort: fL,
  path: mL,
  ancestors: vL,
  descendants: yL,
  leaves: xL,
  links: bL,
  copy: EL,
  [Symbol.iterator]: _L
};
function $L(e) {
  return e == null ? null : iv(e);
}
function iv(e) {
  if (typeof e != "function") throw new Error();
  return e;
}
function Kn() {
  return 0;
}
function kr(e) {
  return function() {
    return e;
  };
}
const ML = 1664525, CL = 1013904223, zd = 4294967296;
function AL() {
  let e = 1;
  return () => (e = (ML * e + CL) % zd) / zd;
}
function LL(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function DL(e, t) {
  let n = e.length, r, i;
  for (; n; )
    i = t() * n-- | 0, r = e[n], e[n] = e[i], e[i] = r;
  return e;
}
function kL(e, t) {
  for (var n = 0, r = (e = DL(Array.from(e), t)).length, i = [], s, a; n < r; )
    s = e[n], a && sv(a, s) ? ++n : (a = IL(i = RL(i, s)), n = 0);
  return a;
}
function RL(e, t) {
  var n, r;
  if (Qo(t, e)) return [t];
  for (n = 0; n < e.length; ++n)
    if (Ps(t, e[n]) && Qo(Ni(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (r = n + 1; r < e.length; ++r)
      if (Ps(Ni(e[n], e[r]), t) && Ps(Ni(e[n], t), e[r]) && Ps(Ni(e[r], t), e[n]) && Qo(av(e[n], e[r], t), e))
        return [e[n], e[r], t];
  throw new Error();
}
function Ps(e, t) {
  var n = e.r - t.r, r = t.x - e.x, i = t.y - e.y;
  return n < 0 || n * n < r * r + i * i;
}
function sv(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function Qo(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!sv(e, t[n]))
      return !1;
  return !0;
}
function IL(e) {
  switch (e.length) {
    case 1:
      return NL(e[0]);
    case 2:
      return Ni(e[0], e[1]);
    case 3:
      return av(e[0], e[1], e[2]);
  }
}
function NL(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function Ni(e, t) {
  var n = e.x, r = e.y, i = e.r, s = t.x, a = t.y, o = t.r, l = s - n, c = a - r, u = o - i, d = Math.sqrt(l * l + c * c);
  return {
    x: (n + s + l / d * u) / 2,
    y: (r + a + c / d * u) / 2,
    r: (d + i + o) / 2
  };
}
function av(e, t, n) {
  var r = e.x, i = e.y, s = e.r, a = t.x, o = t.y, l = t.r, c = n.x, u = n.y, d = n.r, h = r - a, p = r - c, f = i - o, g = i - u, m = l - s, v = d - s, b = r * r + i * i - s * s, _ = b - a * a - o * o + l * l, E = b - c * c - u * u + d * d, x = p * f - h * g, S = (f * E - g * _) / (x * 2) - r, $ = (g * m - f * v) / x, D = (p * _ - h * E) / (x * 2) - i, C = (h * v - p * m) / x, R = $ * $ + C * C - 1, M = 2 * (s + S * $ + D * C), H = S * S + D * D - s * s, P = -(Math.abs(R) > 1e-6 ? (M + Math.sqrt(M * M - 4 * R * H)) / (2 * R) : H / M);
  return {
    x: r + S + $ * P,
    y: i + D + C * P,
    r: P
  };
}
function Fd(e, t, n) {
  var r = e.x - t.x, i, s, a = e.y - t.y, o, l, c = r * r + a * a;
  c ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (i = (c + l - s) / (2 * c), o = Math.sqrt(Math.max(0, l / c - i * i)), n.x = e.x - i * r - o * a, n.y = e.y - i * a + o * r) : (i = (c + s - l) / (2 * c), o = Math.sqrt(Math.max(0, s / c - i * i)), n.x = t.x + i * r - o * a, n.y = t.y + i * a + o * r)) : (n.x = t.x + n.r, n.y = t.y);
}
function jd(e, t) {
  var n = e.r + t.r - 1e-6, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function Wd(e) {
  var t = e._, n = e.next._, r = t.r + n.r, i = (t.x * n.r + n.x * t.r) / r, s = (t.y * n.r + n.y * t.r) / r;
  return i * i + s * s;
}
function Us(e) {
  this._ = e, this.next = null, this.previous = null;
}
function PL(e, t) {
  if (!(s = (e = LL(e)).length)) return 0;
  var n, r, i, s, a, o, l, c, u, d, h;
  if (n = e[0], n.x = 0, n.y = 0, !(s > 1)) return n.r;
  if (r = e[1], n.x = -r.r, r.x = n.r, r.y = 0, !(s > 2)) return n.r + r.r;
  Fd(r, n, i = e[2]), n = new Us(n), r = new Us(r), i = new Us(i), n.next = i.previous = r, r.next = n.previous = i, i.next = r.previous = n;
  t: for (l = 3; l < s; ++l) {
    Fd(n._, r._, i = e[l]), i = new Us(i), c = r.next, u = n.previous, d = r._.r, h = n._.r;
    do
      if (d <= h) {
        if (jd(c._, i._)) {
          r = c, n.next = r, r.previous = n, --l;
          continue t;
        }
        d += c._.r, c = c.next;
      } else {
        if (jd(u._, i._)) {
          n = u, n.next = r, r.previous = n, --l;
          continue t;
        }
        h += u._.r, u = u.previous;
      }
    while (c !== u.next);
    for (i.previous = n, i.next = r, n.next = r.previous = r = i, a = Wd(n); (i = i.next) !== r; )
      (o = Wd(i)) < a && (n = i, a = o);
    r = n.next;
  }
  for (n = [r._], i = r; (i = i.next) !== r; ) n.push(i._);
  for (i = kL(n, t), l = 0; l < s; ++l) n = e[l], n.x -= i.x, n.y -= i.y;
  return i.r;
}
function UL(e) {
  return Math.sqrt(e.value);
}
function BL() {
  var e = null, t = 1, n = 1, r = Kn;
  function i(s) {
    const a = AL();
    return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(qd(e)).eachAfter(Jo(r, 0.5, a)).eachBefore(Yd(1)) : s.eachBefore(qd(UL)).eachAfter(Jo(Kn, 1, a)).eachAfter(Jo(r, s.r / Math.min(t, n), a)).eachBefore(Yd(Math.min(t, n) / (2 * s.r))), s;
  }
  return i.radius = function(s) {
    return arguments.length ? (e = $L(s), i) : e;
  }, i.size = function(s) {
    return arguments.length ? (t = +s[0], n = +s[1], i) : [t, n];
  }, i.padding = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : kr(+s), i) : r;
  }, i;
}
function qd(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function Jo(e, t, n) {
  return function(r) {
    if (i = r.children) {
      var i, s, a = i.length, o = e(r) * t || 0, l;
      if (o) for (s = 0; s < a; ++s) i[s].r += o;
      if (l = PL(i, n), o) for (s = 0; s < a; ++s) i[s].r -= o;
      r.r = l + o;
    }
  };
}
function Yd(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function HL(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function VL(e, t, n, r, i) {
  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (r - t) / e.value; ++o < l; )
    a = s[o], a.y0 = n, a.y1 = i, a.x0 = t, a.x1 = t += a.value * c;
}
function GL(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function tl(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function el(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function zL(e, t, n) {
  var r = n / (t.i - e.i);
  t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n;
}
function FL(e) {
  for (var t = 0, n = 0, r = e.children, i = r.length, s; --i >= 0; )
    s = r[i], s.z += t, s.m += t, t += s.s + (n += s.c);
}
function jL(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function na(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
na.prototype = Object.create(os.prototype);
function WL(e) {
  for (var t = new na(e, 0), n, r = [t], i, s, a, o; n = r.pop(); )
    if (s = n._.children)
      for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a)
        r.push(i = n.children[a] = new na(s[a], a)), i.parent = n;
  return (t.parent = new na(null, 0)).children = [t], t;
}
function qL() {
  var e = GL, t = 1, n = 1, r = null;
  function i(c) {
    var u = WL(c);
    if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(a), r) c.eachBefore(l);
    else {
      var d = c, h = c, p = c;
      c.eachBefore(function(b) {
        b.x < d.x && (d = b), b.x > h.x && (h = b), b.depth > p.depth && (p = b);
      });
      var f = d === h ? 1 : e(d, h) / 2, g = f - d.x, m = t / (h.x + f + g), v = n / (p.depth || 1);
      c.eachBefore(function(b) {
        b.x = (b.x + g) * m, b.y = b.depth * v;
      });
    }
    return c;
  }
  function s(c) {
    var u = c.children, d = c.parent.children, h = c.i ? d[c.i - 1] : null;
    if (u) {
      FL(c);
      var p = (u[0].z + u[u.length - 1].z) / 2;
      h ? (c.z = h.z + e(c._, h._), c.m = c.z - p) : c.z = p;
    } else h && (c.z = h.z + e(c._, h._));
    c.parent.A = o(c, h, c.parent.A || d[0]);
  }
  function a(c) {
    c._.x = c.z + c.parent.m, c.m += c.parent.m;
  }
  function o(c, u, d) {
    if (u) {
      for (var h = c, p = c, f = u, g = h.parent.children[0], m = h.m, v = p.m, b = f.m, _ = g.m, E; f = el(f), h = tl(h), f && h; )
        g = tl(g), p = el(p), p.a = c, E = f.z + b - h.z - m + e(f._, h._), E > 0 && (zL(jL(f, c, d), c, E), m += E, v += E), b += f.m, m += h.m, _ += g.m, v += p.m;
      f && !el(p) && (p.t = f, p.m += b - v), h && !tl(g) && (g.t = h, g.m += m - _, d = c);
    }
    return d;
  }
  function l(c) {
    c.x *= t, c.y = c.depth * n;
  }
  return i.separation = function(c) {
    return arguments.length ? (e = c, i) : e;
  }, i.size = function(c) {
    return arguments.length ? (r = !1, t = +c[0], n = +c[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(c) {
    return arguments.length ? (r = !0, t = +c[0], n = +c[1], i) : r ? [t, n] : null;
  }, i;
}
function YL(e, t, n, r, i) {
  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (i - n) / e.value; ++o < l; )
    a = s[o], a.x0 = t, a.x1 = r, a.y0 = n, a.y1 = n += a.value * c;
}
var XL = (1 + Math.sqrt(5)) / 2;
function ZL(e, t, n, r, i, s) {
  for (var a = [], o = t.children, l, c, u = 0, d = 0, h = o.length, p, f, g = t.value, m, v, b, _, E, x, S; u < h; ) {
    p = i - n, f = s - r;
    do
      m = o[d++].value;
    while (!m && d < h);
    for (v = b = m, x = Math.max(f / p, p / f) / (g * e), S = m * m * x, E = Math.max(b / S, S / v); d < h; ++d) {
      if (m += c = o[d].value, c < v && (v = c), c > b && (b = c), S = m * m * x, _ = Math.max(b / S, S / v), _ > E) {
        m -= c;
        break;
      }
      E = _;
    }
    a.push(l = { value: m, dice: p < f, children: o.slice(u, d) }), l.dice ? VL(l, n, r, i, g ? r += f * m / g : s) : YL(l, n, r, g ? n += p * m / g : i, s), g -= m, u = d;
  }
  return a;
}
const KL = function e(t) {
  function n(r, i, s, a, o) {
    ZL(t, r, i, s, a, o);
  }
  return n.ratio = function(r) {
    return e((r = +r) > 1 ? r : 1);
  }, n;
}(XL);
function QL() {
  var e = KL, t = !1, n = 1, r = 1, i = [0], s = Kn, a = Kn, o = Kn, l = Kn, c = Kn;
  function u(h) {
    return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = r, h.eachBefore(d), i = [0], t && h.eachBefore(HL), h;
  }
  function d(h) {
    var p = i[h.depth], f = h.x0 + p, g = h.y0 + p, m = h.x1 - p, v = h.y1 - p;
    m < f && (f = m = (f + m) / 2), v < g && (g = v = (g + v) / 2), h.x0 = f, h.y0 = g, h.x1 = m, h.y1 = v, h.children && (p = i[h.depth + 1] = s(h) / 2, f += c(h) - p, g += a(h) - p, m -= o(h) - p, v -= l(h) - p, m < f && (f = m = (f + m) / 2), v < g && (g = v = (g + v) / 2), e(h, f, g, m, v));
  }
  return u.round = function(h) {
    return arguments.length ? (t = !!h, u) : t;
  }, u.size = function(h) {
    return arguments.length ? (n = +h[0], r = +h[1], u) : [n, r];
  }, u.tile = function(h) {
    return arguments.length ? (e = iv(h), u) : e;
  }, u.padding = function(h) {
    return arguments.length ? u.paddingInner(h).paddingOuter(h) : u.paddingInner();
  }, u.paddingInner = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : kr(+h), u) : s;
  }, u.paddingOuter = function(h) {
    return arguments.length ? u.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : u.paddingTop();
  }, u.paddingTop = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : kr(+h), u) : a;
  }, u.paddingRight = function(h) {
    return arguments.length ? (o = typeof h == "function" ? h : kr(+h), u) : o;
  }, u.paddingBottom = function(h) {
    return arguments.length ? (l = typeof h == "function" ? h : kr(+h), u) : l;
  }, u.paddingLeft = function(h) {
    return arguments.length ? (c = typeof h == "function" ? h : kr(+h), u) : c;
  }, u;
}
function ho(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new Jc(t);
}
function JL(e) {
  return e.innerRadius;
}
function tD(e) {
  return e.outerRadius;
}
function eD(e) {
  return e.startAngle;
}
function nD(e) {
  return e.endAngle;
}
function rD(e) {
  return e && e.padAngle;
}
function iD(e, t, n, r, i, s, a, o) {
  var l = n - e, c = r - t, u = a - i, d = o - s, h = d * l - u * c;
  if (!(h * h < ne))
    return h = (u * (t - s) - d * (e - i)) / h, [e + h * l, t + h * c];
}
function Bs(e, t, n, r, i, s, a) {
  var o = e - n, l = t - r, c = (a ? s : -s) / Hr(o * o + l * l), u = c * l, d = -c * o, h = e + u, p = t + d, f = n + u, g = r + d, m = (h + f) / 2, v = (p + g) / 2, b = f - h, _ = g - p, E = b * b + _ * _, x = i - s, S = h * g - f * p, $ = (_ < 0 ? -1 : 1) * Hr(VM(0, x * x * E - S * S)), D = (S * _ - b * $) / E, C = (-S * b - _ * $) / E, R = (S * _ + b * $) / E, M = (-S * b + _ * $) / E, H = D - m, P = C - v, B = R - m, O = M - v;
  return H * H + P * P > B * B + O * O && (D = R, C = M), {
    cx: D,
    cy: C,
    x01: -u,
    y01: -d,
    x11: D * (i / x - 1),
    y11: C * (i / x - 1)
  };
}
function ls() {
  var e = JL, t = tD, n = dt(0), r = null, i = eD, s = nD, a = rD, o = null, l = ho(c);
  function c() {
    var u, d, h = +e.apply(this, arguments), p = +t.apply(this, arguments), f = i.apply(this, arguments) - Sa, g = s.apply(this, arguments) - Sa, m = rd(g - f), v = g > f;
    if (o || (o = u = l()), p < h && (d = p, p = h, h = d), !(p > ne)) o.moveTo(0, 0);
    else if (m > Ks - ne)
      o.moveTo(p * qn(f), p * Ze(f)), o.arc(0, 0, p, f, g, !v), h > ne && (o.moveTo(h * qn(g), h * Ze(g)), o.arc(0, 0, h, g, f, v));
    else {
      var b = f, _ = g, E = f, x = g, S = m, $ = m, D = a.apply(this, arguments) / 2, C = D > ne && (r ? +r.apply(this, arguments) : Hr(h * h + p * p)), R = Vo(rd(p - h) / 2, +n.apply(this, arguments)), M = R, H = R, P, B;
      if (C > ne) {
        var O = id(C / h * Ze(D)), w = id(C / p * Ze(D));
        (S -= O * 2) > ne ? (O *= v ? 1 : -1, E += O, x -= O) : (S = 0, E = x = (f + g) / 2), ($ -= w * 2) > ne ? (w *= v ? 1 : -1, b += w, _ -= w) : ($ = 0, b = _ = (f + g) / 2);
      }
      var L = p * qn(b), k = p * Ze(b), U = h * qn(x), Z = h * Ze(x);
      if (R > ne) {
        var j = p * qn(_), F = p * Ze(_), Y = h * qn(E), ot = h * Ze(E), Q;
        if (m < is)
          if (Q = iD(L, k, Y, ot, j, F, U, Z)) {
            var q = L - Q[0], tt = k - Q[1], lt = j - Q[0], z = F - Q[1], W = 1 / Ze(GM((q * lt + tt * z) / (Hr(q * q + tt * tt) * Hr(lt * lt + z * z))) / 2), X = Hr(Q[0] * Q[0] + Q[1] * Q[1]);
            M = Vo(R, (h - X) / (W - 1)), H = Vo(R, (p - X) / (W + 1));
          } else
            M = H = 0;
      }
      $ > ne ? H > ne ? (P = Bs(Y, ot, L, k, p, H, v), B = Bs(j, F, U, Z, p, H, v), o.moveTo(P.cx + P.x01, P.cy + P.y01), H < R ? o.arc(P.cx, P.cy, H, Jt(P.y01, P.x01), Jt(B.y01, B.x01), !v) : (o.arc(P.cx, P.cy, H, Jt(P.y01, P.x01), Jt(P.y11, P.x11), !v), o.arc(0, 0, p, Jt(P.cy + P.y11, P.cx + P.x11), Jt(B.cy + B.y11, B.cx + B.x11), !v), o.arc(B.cx, B.cy, H, Jt(B.y11, B.x11), Jt(B.y01, B.x01), !v))) : (o.moveTo(L, k), o.arc(0, 0, p, b, _, !v)) : o.moveTo(L, k), !(h > ne) || !(S > ne) ? o.lineTo(U, Z) : M > ne ? (P = Bs(U, Z, j, F, h, -M, v), B = Bs(L, k, Y, ot, h, -M, v), o.lineTo(P.cx + P.x01, P.cy + P.y01), M < R ? o.arc(P.cx, P.cy, M, Jt(P.y01, P.x01), Jt(B.y01, B.x01), !v) : (o.arc(P.cx, P.cy, M, Jt(P.y01, P.x01), Jt(P.y11, P.x11), !v), o.arc(0, 0, h, Jt(P.cy + P.y11, P.cx + P.x11), Jt(B.cy + B.y11, B.cx + B.x11), v), o.arc(B.cx, B.cy, M, Jt(B.y11, B.x11), Jt(B.y01, B.x01), !v))) : o.arc(0, 0, h, x, E, v);
    }
    if (o.closePath(), u) return o = null, u + "" || null;
  }
  return c.centroid = function() {
    var u = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - is / 2;
    return [qn(d) * u, Ze(d) * u];
  }, c.innerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : dt(+u), c) : e;
  }, c.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : dt(+u), c) : t;
  }, c.cornerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : dt(+u), c) : n;
  }, c.padRadius = function(u) {
    return arguments.length ? (r = u == null ? null : typeof u == "function" ? u : dt(+u), c) : r;
  }, c.startAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : dt(+u), c) : i;
  }, c.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : dt(+u), c) : s;
  }, c.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : dt(+u), c) : a;
  }, c.context = function(u) {
    return arguments.length ? (o = u ?? null, c) : o;
  }, c;
}
function ru(e) {
  return e[0];
}
function iu(e) {
  return e[1];
}
function bs(e, t) {
  var n = dt(!0), r = null, i = oo, s = null, a = ho(o);
  e = typeof e == "function" ? e : e === void 0 ? ru : dt(e), t = typeof t == "function" ? t : t === void 0 ? iu : dt(t);
  function o(l) {
    var c, u = (l = so(l)).length, d, h = !1, p;
    for (r == null && (s = i(p = a())), c = 0; c <= u; ++c)
      !(c < u && n(d = l[c], c, l)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(d, c, l), +t(d, c, l));
    if (p) return s = null, p + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : dt(+l), o) : e;
  }, o.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : dt(+l), o) : t;
  }, o.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : dt(!!l), o) : n;
  }, o.curve = function(l) {
    return arguments.length ? (i = l, r != null && (s = i(r)), o) : i;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? r = s = null : s = i(r = l), o) : r;
  }, o;
}
function su(e, t, n) {
  var r = null, i = dt(!0), s = null, a = oo, o = null, l = ho(c);
  e = typeof e == "function" ? e : e === void 0 ? ru : dt(+e), t = typeof t == "function" ? t : dt(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? iu : dt(+n);
  function c(d) {
    var h, p, f, g = (d = so(d)).length, m, v = !1, b, _ = new Array(g), E = new Array(g);
    for (s == null && (o = a(b = l())), h = 0; h <= g; ++h) {
      if (!(h < g && i(m = d[h], h, d)) === v)
        if (v = !v)
          p = h, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), f = h - 1; f >= p; --f)
            o.point(_[f], E[f]);
          o.lineEnd(), o.areaEnd();
        }
      v && (_[h] = +e(m, h, d), E[h] = +t(m, h, d), o.point(r ? +r(m, h, d) : _[h], n ? +n(m, h, d) : E[h]));
    }
    if (b) return o = null, b + "" || null;
  }
  function u() {
    return bs().defined(i).curve(a).context(s);
  }
  return c.x = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : dt(+d), r = null, c) : e;
  }, c.x0 = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : dt(+d), c) : e;
  }, c.x1 = function(d) {
    return arguments.length ? (r = d == null ? null : typeof d == "function" ? d : dt(+d), c) : r;
  }, c.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : dt(+d), n = null, c) : t;
  }, c.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : dt(+d), c) : t;
  }, c.y1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : dt(+d), c) : n;
  }, c.lineX0 = c.lineY0 = function() {
    return u().x(e).y(t);
  }, c.lineY1 = function() {
    return u().x(e).y(n);
  }, c.lineX1 = function() {
    return u().x(r).y(t);
  }, c.defined = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : dt(!!d), c) : i;
  }, c.curve = function(d) {
    return arguments.length ? (a = d, s != null && (o = a(s)), c) : a;
  }, c.context = function(d) {
    return arguments.length ? (d == null ? s = o = null : o = a(s = d), c) : s;
  }, c;
}
function sD(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function aD(e) {
  return e;
}
function oD() {
  var e = aD, t = sD, n = null, r = dt(0), i = dt(Ks), s = dt(0);
  function a(o) {
    var l, c = (o = so(o)).length, u, d, h = 0, p = new Array(c), f = new Array(c), g = +r.apply(this, arguments), m = Math.min(Ks, Math.max(-Ks, i.apply(this, arguments) - g)), v, b = Math.min(Math.abs(m) / c, s.apply(this, arguments)), _ = b * (m < 0 ? -1 : 1), E;
    for (l = 0; l < c; ++l)
      (E = f[p[l] = l] = +e(o[l], l, o)) > 0 && (h += E);
    for (t != null ? p.sort(function(x, S) {
      return t(f[x], f[S]);
    }) : n != null && p.sort(function(x, S) {
      return n(o[x], o[S]);
    }), l = 0, d = h ? (m - c * _) / h : 0; l < c; ++l, g = v)
      u = p[l], E = f[u], v = g + (E > 0 ? E * d : 0) + _, f[u] = {
        data: o[u],
        index: l,
        value: E,
        startAngle: g,
        endAngle: v,
        padAngle: b
      };
    return f;
  }
  return a.value = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : dt(+o), a) : e;
  }, a.sortValues = function(o) {
    return arguments.length ? (t = o, n = null, a) : t;
  }, a.sort = function(o) {
    return arguments.length ? (n = o, t = null, a) : n;
  }, a.startAngle = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : dt(+o), a) : r;
  }, a.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : dt(+o), a) : i;
  }, a.padAngle = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : dt(+o), a) : s;
  }, a;
}
var lD = lv(oo);
function ov(e) {
  this._curve = e;
}
ov.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(e, t) {
    this._curve.point(t * Math.sin(e), t * -Math.cos(e));
  }
};
function lv(e) {
  function t(n) {
    return new ov(e(n));
  }
  return t._curve = e, t;
}
function cD(e) {
  var t = e.curve;
  return e.angle = e.x, delete e.x, e.radius = e.y, delete e.y, e.curve = function(n) {
    return arguments.length ? t(lv(n)) : t()._curve;
  }, e;
}
function uD() {
  return cD(bs().curve(lD));
}
class hD {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function dD(e) {
  return new hD(e, !0);
}
function pD(e) {
  return e.source;
}
function fD(e) {
  return e.target;
}
function mD(e) {
  let t = pD, n = fD, r = ru, i = iu, s = null, a = null, o = ho(l);
  function l() {
    let c;
    const u = Lw.call(arguments), d = t.apply(this, u), h = n.apply(this, u);
    if (s == null && (a = e(c = o())), a.lineStart(), u[0] = d, a.point(+r.apply(this, u), +i.apply(this, u)), u[0] = h, a.point(+r.apply(this, u), +i.apply(this, u)), a.lineEnd(), c) return a = null, c + "" || null;
  }
  return l.source = function(c) {
    return arguments.length ? (t = c, l) : t;
  }, l.target = function(c) {
    return arguments.length ? (n = c, l) : n;
  }, l.x = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : dt(+c), l) : r;
  }, l.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : dt(+c), l) : i;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? s = a = null : a = e(s = c), l) : s;
  }, l;
}
function gD() {
  return mD(dD);
}
let mt = class {
  constructor(t, n, r) {
    if (this.type = "", this.renderType = rt.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = n, r && (this.configs = r, this.configs.id)) {
      const i = y(this.model.getOptions(), "style", "prefix");
      this.id = `${i}--${this.configs.id}`;
    }
    this.parent || this.setParent(
      I(
        this.services.domUtils.getMainContainer()
      )
    );
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down information to the components
  setServices(t) {
    this.services = t;
  }
  setParent(t) {
    const n = this.parent;
    if (this.parent = t, !(n && n.node() === t.node()) && this.type) {
      const r = y(this.model.getOptions(), "style", "prefix");
      this.parent?.classed(`${ue}--${r}--${this.type}`, !0), n && n.classed(`${ue}--${r}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(t = { ariaLabel: null, isPresentational: !1, withinChartClip: !1 }) {
    if (this.type) {
      const n = y(this.model.getOptions(), "style", "prefix"), r = this.id ? `#${this.id}` : "", i = N.appendOrSelect(
        this.parent,
        `${this.renderType === rt.SVG ? "svg" : "div"}${r}.${ue}--${n}--${this.type}`
      );
      if (t.ariaLabel && i.attr("aria-label", t.ariaLabel), t.isPresentational && i.attr("role", "presentation"), t.withinChartClip) {
        const s = this.model.get("chartClipId");
        if (s) {
          const a = I(`#${s}`).select("rect");
          if (a.size() !== 0) {
            const o = parseFloat(a.attr("height")), l = parseFloat(a.attr("width"));
            !isNaN(o) && !isNaN(l) && o > 0 && l > 0 && i.attr("clip-path", `url(#${s})`);
          }
        }
      }
      return i.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? at({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
};
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: cv,
  setPrototypeOf: Xd,
  isFrozen: vD,
  getPrototypeOf: yD,
  getOwnPropertyDescriptor: xD
} = Object;
let {
  freeze: oe,
  seal: Re,
  create: uv
} = Object, {
  apply: rc,
  construct: ic
} = typeof Reflect < "u" && Reflect;
oe || (oe = function(e) {
  return e;
});
Re || (Re = function(e) {
  return e;
});
rc || (rc = function(e, t, n) {
  return e.apply(t, n);
});
ic || (ic = function(e, t) {
  return new e(...t);
});
const Hs = le(Array.prototype.forEach), bD = le(Array.prototype.lastIndexOf), Zd = le(Array.prototype.pop), _i = le(Array.prototype.push), _D = le(Array.prototype.splice), ra = le(String.prototype.toLowerCase), nl = le(String.prototype.toString), Kd = le(String.prototype.match), Ei = le(String.prototype.replace), ED = le(String.prototype.indexOf), OD = le(String.prototype.trim), Ue = le(Object.prototype.hasOwnProperty), ie = le(RegExp.prototype.test), Oi = SD(TypeError);
function le(e) {
  return function(t) {
    t instanceof RegExp && (t.lastIndex = 0);
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    return rc(e, t, r);
  };
}
function SD(e) {
  return function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return ic(e, n);
  };
}
function pt(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ra;
  Xd && Xd(e, null);
  let r = t.length;
  for (; r--; ) {
    let i = t[r];
    if (typeof i == "string") {
      const s = n(i);
      s !== i && (vD(t) || (t[r] = s), i = s);
    }
    e[i] = !0;
  }
  return e;
}
function TD(e) {
  for (let t = 0; t < e.length; t++)
    Ue(e, t) || (e[t] = null);
  return e;
}
function mn(e) {
  const t = uv(null);
  for (const [n, r] of cv(e))
    Ue(e, n) && (Array.isArray(r) ? t[n] = TD(r) : r && typeof r == "object" && r.constructor === Object ? t[n] = mn(r) : t[n] = r);
  return t;
}
function Si(e, t) {
  for (; e !== null; ) {
    const r = xD(e, t);
    if (r) {
      if (r.get)
        return le(r.get);
      if (typeof r.value == "function")
        return le(r.value);
    }
    e = yD(e);
  }
  function n() {
    return null;
  }
  return n;
}
const Qd = oe(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), rl = oe(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), il = oe(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), wD = oe(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), sl = oe(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), $D = oe(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Jd = oe(["#text"]), tp = oe(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), al = oe(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), ep = oe(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Vs = oe(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MD = Re(/\{\{[\w\W]*|[\w\W]*\}\}/gm), CD = Re(/<%[\w\W]*|[\w\W]*%>/gm), AD = Re(/\$\{[\w\W]*/gm), LD = Re(/^data-[\-\w.\u00B7-\uFFFF]+$/), DD = Re(/^aria-[\-\w]+$/), hv = Re(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), kD = Re(/^(?:\w+script|data):/i), RD = Re(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), dv = Re(/^html$/i), ID = Re(/^[a-z][.\w]*(-[.\w]+)+$/i);
var np = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: DD,
  ATTR_WHITESPACE: RD,
  CUSTOM_ELEMENT: ID,
  DATA_ATTR: LD,
  DOCTYPE_NAME: dv,
  ERB_EXPR: CD,
  IS_ALLOWED_URI: hv,
  IS_SCRIPT_OR_DATA: kD,
  MUSTACHE_EXPR: MD,
  TMPLIT_EXPR: AD
});
const Ti = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, ND = function() {
  return typeof window > "u" ? null : window;
}, PD = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const r = "data-tt-policy-suffix";
  t && t.hasAttribute(r) && (n = t.getAttribute(r));
  const i = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(i, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + i + " could not be created."), null;
  }
}, rp = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function pv() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ND();
  const t = (A) => pv(A);
  if (t.version = "3.2.6", t.removed = [], !e || !e.document || e.document.nodeType !== Ti.document || !e.Element)
    return t.isSupported = !1, t;
  let {
    document: n
  } = e;
  const r = n, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: a,
    Node: o,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: u = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: h,
    trustedTypes: p
  } = e, f = l.prototype, g = Si(f, "cloneNode"), m = Si(f, "remove"), v = Si(f, "nextSibling"), b = Si(f, "childNodes"), _ = Si(f, "parentNode");
  if (typeof a == "function") {
    const A = n.createElement("template");
    A.content && A.content.ownerDocument && (n = A.content.ownerDocument);
  }
  let E, x = "";
  const {
    implementation: S,
    createNodeIterator: $,
    createDocumentFragment: D,
    getElementsByTagName: C
  } = n, {
    importNode: R
  } = r;
  let M = rp();
  t.isSupported = typeof cv == "function" && typeof _ == "function" && S && S.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: H,
    ERB_EXPR: P,
    TMPLIT_EXPR: B,
    DATA_ATTR: O,
    ARIA_ATTR: w,
    IS_SCRIPT_OR_DATA: L,
    ATTR_WHITESPACE: k,
    CUSTOM_ELEMENT: U
  } = np;
  let {
    IS_ALLOWED_URI: Z
  } = np, j = null;
  const F = pt({}, [...Qd, ...rl, ...il, ...sl, ...Jd]);
  let Y = null;
  const ot = pt({}, [...tp, ...al, ...ep, ...Vs]);
  let Q = Object.seal(uv(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), q = null, tt = null, lt = !0, z = !0, W = !1, X = !0, V = !1, ut = !0, st = !1, kt = !1, Nt = !1, nt = !1, yt = !1, Se = !1, ge = !0, ci = !1;
  const ui = "user-content-";
  let Fn = !0, Ie = !1, yr = {}, xr = null;
  const yu = pt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let xu = null;
  const bu = pt({}, ["audio", "video", "img", "source", "image", "track"]);
  let yo = null;
  const _u = pt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Es = "http://www.w3.org/1998/Math/MathML", Os = "http://www.w3.org/2000/svg", on = "http://www.w3.org/1999/xhtml";
  let br = on, xo = !1, bo = null;
  const r1 = pt({}, [Es, Os, on], nl);
  let Ss = pt({}, ["mi", "mo", "mn", "ms", "mtext"]), Ts = pt({}, ["annotation-xml"]);
  const i1 = pt({}, ["title", "style", "font", "a", "script"]);
  let hi = null;
  const s1 = ["application/xhtml+xml", "text/html"], a1 = "text/html";
  let qt = null, _r = null;
  const o1 = n.createElement("form"), Eu = function(A) {
    return A instanceof RegExp || A instanceof Function;
  }, _o = function() {
    let A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(_r && _r === A)) {
      if ((!A || typeof A != "object") && (A = {}), A = mn(A), hi = // eslint-disable-next-line unicorn/prefer-includes
      s1.indexOf(A.PARSER_MEDIA_TYPE) === -1 ? a1 : A.PARSER_MEDIA_TYPE, qt = hi === "application/xhtml+xml" ? nl : ra, j = Ue(A, "ALLOWED_TAGS") ? pt({}, A.ALLOWED_TAGS, qt) : F, Y = Ue(A, "ALLOWED_ATTR") ? pt({}, A.ALLOWED_ATTR, qt) : ot, bo = Ue(A, "ALLOWED_NAMESPACES") ? pt({}, A.ALLOWED_NAMESPACES, nl) : r1, yo = Ue(A, "ADD_URI_SAFE_ATTR") ? pt(mn(_u), A.ADD_URI_SAFE_ATTR, qt) : _u, xu = Ue(A, "ADD_DATA_URI_TAGS") ? pt(mn(bu), A.ADD_DATA_URI_TAGS, qt) : bu, xr = Ue(A, "FORBID_CONTENTS") ? pt({}, A.FORBID_CONTENTS, qt) : yu, q = Ue(A, "FORBID_TAGS") ? pt({}, A.FORBID_TAGS, qt) : mn({}), tt = Ue(A, "FORBID_ATTR") ? pt({}, A.FORBID_ATTR, qt) : mn({}), yr = Ue(A, "USE_PROFILES") ? A.USE_PROFILES : !1, lt = A.ALLOW_ARIA_ATTR !== !1, z = A.ALLOW_DATA_ATTR !== !1, W = A.ALLOW_UNKNOWN_PROTOCOLS || !1, X = A.ALLOW_SELF_CLOSE_IN_ATTR !== !1, V = A.SAFE_FOR_TEMPLATES || !1, ut = A.SAFE_FOR_XML !== !1, st = A.WHOLE_DOCUMENT || !1, nt = A.RETURN_DOM || !1, yt = A.RETURN_DOM_FRAGMENT || !1, Se = A.RETURN_TRUSTED_TYPE || !1, Nt = A.FORCE_BODY || !1, ge = A.SANITIZE_DOM !== !1, ci = A.SANITIZE_NAMED_PROPS || !1, Fn = A.KEEP_CONTENT !== !1, Ie = A.IN_PLACE || !1, Z = A.ALLOWED_URI_REGEXP || hv, br = A.NAMESPACE || on, Ss = A.MATHML_TEXT_INTEGRATION_POINTS || Ss, Ts = A.HTML_INTEGRATION_POINTS || Ts, Q = A.CUSTOM_ELEMENT_HANDLING || {}, A.CUSTOM_ELEMENT_HANDLING && Eu(A.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Q.tagNameCheck = A.CUSTOM_ELEMENT_HANDLING.tagNameCheck), A.CUSTOM_ELEMENT_HANDLING && Eu(A.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Q.attributeNameCheck = A.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), A.CUSTOM_ELEMENT_HANDLING && typeof A.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Q.allowCustomizedBuiltInElements = A.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), V && (z = !1), yt && (nt = !0), yr && (j = pt({}, Jd), Y = [], yr.html === !0 && (pt(j, Qd), pt(Y, tp)), yr.svg === !0 && (pt(j, rl), pt(Y, al), pt(Y, Vs)), yr.svgFilters === !0 && (pt(j, il), pt(Y, al), pt(Y, Vs)), yr.mathMl === !0 && (pt(j, sl), pt(Y, ep), pt(Y, Vs))), A.ADD_TAGS && (j === F && (j = mn(j)), pt(j, A.ADD_TAGS, qt)), A.ADD_ATTR && (Y === ot && (Y = mn(Y)), pt(Y, A.ADD_ATTR, qt)), A.ADD_URI_SAFE_ATTR && pt(yo, A.ADD_URI_SAFE_ATTR, qt), A.FORBID_CONTENTS && (xr === yu && (xr = mn(xr)), pt(xr, A.FORBID_CONTENTS, qt)), Fn && (j["#text"] = !0), st && pt(j, ["html", "head", "body"]), j.table && (pt(j, ["tbody"]), delete q.tbody), A.TRUSTED_TYPES_POLICY) {
        if (typeof A.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Oi('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof A.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Oi('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        E = A.TRUSTED_TYPES_POLICY, x = E.createHTML("");
      } else
        E === void 0 && (E = PD(p, i)), E !== null && typeof x == "string" && (x = E.createHTML(""));
      oe && oe(A), _r = A;
    }
  }, Ou = pt({}, [...rl, ...il, ...wD]), Su = pt({}, [...sl, ...$D]), l1 = function(A) {
    let J = _(A);
    (!J || !J.tagName) && (J = {
      namespaceURI: br,
      tagName: "template"
    });
    const K = ra(A.tagName), bt = ra(J.tagName);
    return bo[A.namespaceURI] ? A.namespaceURI === Os ? J.namespaceURI === on ? K === "svg" : J.namespaceURI === Es ? K === "svg" && (bt === "annotation-xml" || Ss[bt]) : !!Ou[K] : A.namespaceURI === Es ? J.namespaceURI === on ? K === "math" : J.namespaceURI === Os ? K === "math" && Ts[bt] : !!Su[K] : A.namespaceURI === on ? J.namespaceURI === Os && !Ts[bt] || J.namespaceURI === Es && !Ss[bt] ? !1 : !Su[K] && (i1[K] || !Ou[K]) : !!(hi === "application/xhtml+xml" && bo[A.namespaceURI]) : !1;
  }, jn = function(A) {
    _i(t.removed, {
      element: A
    });
    try {
      _(A).removeChild(A);
    } catch {
      m(A);
    }
  }, Er = function(A, J) {
    try {
      _i(t.removed, {
        attribute: J.getAttributeNode(A),
        from: J
      });
    } catch {
      _i(t.removed, {
        attribute: null,
        from: J
      });
    }
    if (J.removeAttribute(A), A === "is")
      if (nt || yt)
        try {
          jn(J);
        } catch {
        }
      else
        try {
          J.setAttribute(A, "");
        } catch {
        }
  }, Tu = function(A) {
    let J = null, K = null;
    if (Nt)
      A = "<remove></remove>" + A;
    else {
      const Pt = Kd(A, /^[\r\n\t ]+/);
      K = Pt && Pt[0];
    }
    hi === "application/xhtml+xml" && br === on && (A = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + A + "</body></html>");
    const bt = E ? E.createHTML(A) : A;
    if (br === on)
      try {
        J = new h().parseFromString(bt, hi);
      } catch {
      }
    if (!J || !J.documentElement) {
      J = S.createDocument(br, "template", null);
      try {
        J.documentElement.innerHTML = xo ? x : bt;
      } catch {
      }
    }
    const Xt = J.body || J.documentElement;
    return A && K && Xt.insertBefore(n.createTextNode(K), Xt.childNodes[0] || null), br === on ? C.call(J, st ? "html" : "body")[0] : st ? J.documentElement : Xt;
  }, wu = function(A) {
    return $.call(
      A.ownerDocument || A,
      A,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Eo = function(A) {
    return A instanceof d && (typeof A.nodeName != "string" || typeof A.textContent != "string" || typeof A.removeChild != "function" || !(A.attributes instanceof u) || typeof A.removeAttribute != "function" || typeof A.setAttribute != "function" || typeof A.namespaceURI != "string" || typeof A.insertBefore != "function" || typeof A.hasChildNodes != "function");
  }, $u = function(A) {
    return typeof o == "function" && A instanceof o;
  };
  function ln(A, J, K) {
    Hs(A, (bt) => {
      bt.call(t, J, K, _r);
    });
  }
  const Mu = function(A) {
    let J = null;
    if (ln(M.beforeSanitizeElements, A, null), Eo(A))
      return jn(A), !0;
    const K = qt(A.nodeName);
    if (ln(M.uponSanitizeElement, A, {
      tagName: K,
      allowedTags: j
    }), ut && A.hasChildNodes() && !$u(A.firstElementChild) && ie(/<[/\w!]/g, A.innerHTML) && ie(/<[/\w!]/g, A.textContent) || A.nodeType === Ti.progressingInstruction || ut && A.nodeType === Ti.comment && ie(/<[/\w]/g, A.data))
      return jn(A), !0;
    if (!j[K] || q[K]) {
      if (!q[K] && Au(K) && (Q.tagNameCheck instanceof RegExp && ie(Q.tagNameCheck, K) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(K)))
        return !1;
      if (Fn && !xr[K]) {
        const bt = _(A) || A.parentNode, Xt = b(A) || A.childNodes;
        if (Xt && bt) {
          const Pt = Xt.length;
          for (let cn = Pt - 1; cn >= 0; --cn) {
            const Ne = g(Xt[cn], !0);
            Ne.__removalCount = (A.__removalCount || 0) + 1, bt.insertBefore(Ne, v(A));
          }
        }
      }
      return jn(A), !0;
    }
    return A instanceof l && !l1(A) || (K === "noscript" || K === "noembed" || K === "noframes") && ie(/<\/no(script|embed|frames)/i, A.innerHTML) ? (jn(A), !0) : (V && A.nodeType === Ti.text && (J = A.textContent, Hs([H, P, B], (bt) => {
      J = Ei(J, bt, " ");
    }), A.textContent !== J && (_i(t.removed, {
      element: A.cloneNode()
    }), A.textContent = J)), ln(M.afterSanitizeElements, A, null), !1);
  }, Cu = function(A, J, K) {
    if (ge && (J === "id" || J === "name") && (K in n || K in o1))
      return !1;
    if (!(z && !tt[J] && ie(O, J)) && !(lt && ie(w, J))) {
      if (!Y[J] || tt[J]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          !(Au(A) && (Q.tagNameCheck instanceof RegExp && ie(Q.tagNameCheck, A) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(A)) && (Q.attributeNameCheck instanceof RegExp && ie(Q.attributeNameCheck, J) || Q.attributeNameCheck instanceof Function && Q.attributeNameCheck(J)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          J === "is" && Q.allowCustomizedBuiltInElements && (Q.tagNameCheck instanceof RegExp && ie(Q.tagNameCheck, K) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(K)))
        ) return !1;
      } else if (!yo[J] && !ie(Z, Ei(K, k, "")) && !((J === "src" || J === "xlink:href" || J === "href") && A !== "script" && ED(K, "data:") === 0 && xu[A]) && !(W && !ie(L, Ei(K, k, ""))) && K)
        return !1;
    }
    return !0;
  }, Au = function(A) {
    return A !== "annotation-xml" && Kd(A, U);
  }, Lu = function(A) {
    ln(M.beforeSanitizeAttributes, A, null);
    const {
      attributes: J
    } = A;
    if (!J || Eo(A))
      return;
    const K = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: Y,
      forceKeepAttr: void 0
    };
    let bt = J.length;
    for (; bt--; ) {
      const Xt = J[bt], {
        name: Pt,
        namespaceURI: cn,
        value: Ne
      } = Xt, Xe = qt(Pt), Oo = Ne;
      let Qt = Pt === "value" ? Oo : OD(Oo);
      if (K.attrName = Xe, K.attrValue = Qt, K.keepAttr = !0, K.forceKeepAttr = void 0, ln(M.uponSanitizeAttribute, A, K), Qt = K.attrValue, ci && (Xe === "id" || Xe === "name") && (Er(Pt, A), Qt = ui + Qt), ut && ie(/((--!?|])>)|<\/(style|title)/i, Qt)) {
        Er(Pt, A);
        continue;
      }
      if (K.forceKeepAttr)
        continue;
      if (!K.keepAttr) {
        Er(Pt, A);
        continue;
      }
      if (!X && ie(/\/>/i, Qt)) {
        Er(Pt, A);
        continue;
      }
      V && Hs([H, P, B], (u1) => {
        Qt = Ei(Qt, u1, " ");
      });
      const Du = qt(A.nodeName);
      if (!Cu(Du, Xe, Qt)) {
        Er(Pt, A);
        continue;
      }
      if (E && typeof p == "object" && typeof p.getAttributeType == "function" && !cn)
        switch (p.getAttributeType(Du, Xe)) {
          case "TrustedHTML": {
            Qt = E.createHTML(Qt);
            break;
          }
          case "TrustedScriptURL": {
            Qt = E.createScriptURL(Qt);
            break;
          }
        }
      if (Qt !== Oo)
        try {
          cn ? A.setAttributeNS(cn, Pt, Qt) : A.setAttribute(Pt, Qt), Eo(A) ? jn(A) : Zd(t.removed);
        } catch {
          Er(Pt, A);
        }
    }
    ln(M.afterSanitizeAttributes, A, null);
  }, c1 = function A(J) {
    let K = null;
    const bt = wu(J);
    for (ln(M.beforeSanitizeShadowDOM, J, null); K = bt.nextNode(); )
      ln(M.uponSanitizeShadowNode, K, null), Mu(K), Lu(K), K.content instanceof s && A(K.content);
    ln(M.afterSanitizeShadowDOM, J, null);
  };
  return t.sanitize = function(A) {
    let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, K = null, bt = null, Xt = null, Pt = null;
    if (xo = !A, xo && (A = "<!-->"), typeof A != "string" && !$u(A))
      if (typeof A.toString == "function") {
        if (A = A.toString(), typeof A != "string")
          throw Oi("dirty is not a string, aborting");
      } else
        throw Oi("toString is not a function");
    if (!t.isSupported)
      return A;
    if (kt || _o(J), t.removed = [], typeof A == "string" && (Ie = !1), Ie) {
      if (A.nodeName) {
        const Xe = qt(A.nodeName);
        if (!j[Xe] || q[Xe])
          throw Oi("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (A instanceof o)
      K = Tu("<!---->"), bt = K.ownerDocument.importNode(A, !0), bt.nodeType === Ti.element && bt.nodeName === "BODY" || bt.nodeName === "HTML" ? K = bt : K.appendChild(bt);
    else {
      if (!nt && !V && !st && // eslint-disable-next-line unicorn/prefer-includes
      A.indexOf("<") === -1)
        return E && Se ? E.createHTML(A) : A;
      if (K = Tu(A), !K)
        return nt ? null : Se ? x : "";
    }
    K && Nt && jn(K.firstChild);
    const cn = wu(Ie ? A : K);
    for (; Xt = cn.nextNode(); )
      Mu(Xt), Lu(Xt), Xt.content instanceof s && c1(Xt.content);
    if (Ie)
      return A;
    if (nt) {
      if (yt)
        for (Pt = D.call(K.ownerDocument); K.firstChild; )
          Pt.appendChild(K.firstChild);
      else
        Pt = K;
      return (Y.shadowroot || Y.shadowrootmode) && (Pt = R.call(r, Pt, !0)), Pt;
    }
    let Ne = st ? K.outerHTML : K.innerHTML;
    return st && j["!doctype"] && K.ownerDocument && K.ownerDocument.doctype && K.ownerDocument.doctype.name && ie(dv, K.ownerDocument.doctype.name) && (Ne = "<!DOCTYPE " + K.ownerDocument.doctype.name + `>
` + Ne), V && Hs([H, P, B], (Xe) => {
      Ne = Ei(Ne, Xe, " ");
    }), E && Se ? E.createHTML(Ne) : Ne;
  }, t.setConfig = function() {
    let A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _o(A), kt = !0;
  }, t.clearConfig = function() {
    _r = null, kt = !1;
  }, t.isValidAttribute = function(A, J, K) {
    _r || _o({});
    const bt = qt(A), Xt = qt(J);
    return Cu(bt, Xt, K);
  }, t.addHook = function(A, J) {
    typeof J == "function" && _i(M[A], J);
  }, t.removeHook = function(A, J) {
    if (J !== void 0) {
      const K = bD(M[A], J);
      return K === -1 ? void 0 : _D(M[A], K, 1)[0];
    }
    return Zd(M[A]);
  }, t.removeHooks = function(A) {
    M[A] = [];
  }, t.removeAllHooks = function() {
    M = rp();
  }, t;
}
var au = pv();
const Gs = (e) => au.sanitize(e, {
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), UD = (e) => au.sanitize(e, {
  NAMESPACE: "http://www.w3.org/2000/svg",
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), en = (e) => au.sanitize(e, { ALLOWED_TAGS: [] }), fv = class mv extends mt {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = rt.HTML;
  }
  init() {
    const t = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(T.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", t);
    }), this.services.events.addEventListener(T.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", t);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "toolbar"
    }).attr("role", "group");
    if (y(this.getOptions(), "data", "loading"))
      n.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = n.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: r, overflowMenuItemList: i } = this.getControlConfigs();
      i && r.push(this.getOverflowButtonConfig());
      const s = n.selectAll("div.toolbar-control").data(r, (l) => l.id);
      s.exit().remove();
      const a = s.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), o = this;
      a.merge(s).classed("disabled", (l) => l.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html((l) => `
			<button
	 			type="button"
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
        `control-${en(l.id)}`
      )}" aria-label="${en(l.title)}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${UD(l.iconSVG.content)}
				</svg>
			</button>`).each(function(l, c) {
        I(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), I(this).select("button").on("mouseover focus", function(u) {
          const d = I(this);
          d.classed("hovered", !0), o.services.events.dispatchEvent(T.Toolbar.SHOW_TOOLTIP, {
            event: u,
            hoveredElement: d,
            content: l.title,
            noWrap: !0,
            placements: ["top", "bottom"]
          });
        }).on("mouseout blur", function() {
          o.services.events.dispatchEvent(T.Toolbar.HIDE_TOOLTIP);
        }).on("click", (u) => {
          l.shouldBeDisabled() || o.triggerFunctionAndEvent(l, u, this);
        }).on("keydown", (u) => {
          u.key && u.key === "Enter" || u.key === " " ? (u.preventDefault(), o.triggerFunctionAndEvent(l, u, this)) : u.key && u.key === "ArrowLeft" ? o.focusOnPreviousEnabledToolbarItem(c) : u.key && u.key === "ArrowRight" && o.focusOnNextEnabledToolbarItem(c);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: t } = this.getControlConfigs(), n = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (i) => y(i, "id"));
    n.exit().remove();
    const r = n.enter().append("li").attr("id", (i) => this.services.domUtils.generateElementIDString(`control-${i.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    r.append("button").attr("type", "button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), r.merge(n).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).attr("aria-disabled", (i) => i.shouldBeDisabled()).selectAll("button").text((i) => i.title);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(t) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), I(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(T.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(T.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(t) {
    const n = this.getToolbarButtonItems();
    let r = n.length;
    for (let i = t - 1; i >= 0; i--)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r < n.length) {
      const i = I(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledToolbarItem(t) {
    const n = this.getToolbarButtonItems();
    let r = -1;
    for (let i = t + 1; i < n.length; i++)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r > -1) {
      const i = I(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(t) {
    const n = this.getOverflowMenuItems();
    let r = n.length;
    for (let i = t - 1; i >= 0; i--)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r < n.length) {
      const i = I(
        `#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledMenuItem(t) {
    const n = this.getOverflowMenuItems();
    let r = -1;
    for (let i = t + 1; i < n.length; i++)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r > -1) {
      const i = I(
        `#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  toggleOverflowMenu(t) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const n = this;
      this.getOverflowMenuItems().forEach((r, i) => {
        const s = I(
          `#${this.services.domUtils.generateElementIDString(`control-${r.id}`)}`
        );
        s !== null && (s.on("click", () => {
          n.triggerFunctionAndEvent(r, t, s.node()), n.updateOverflowMenu(!1);
        }), s.on("keydown", (a) => {
          a && a.key === "Enter" ? n.triggerFunctionAndEvent(r, t, s.node()) : a && a.key === "ArrowUp" ? n.focusOnPreviousEnabledMenuItem(i) : a && a.key === "ArrowDown" ? n.focusOnNextEnabledMenuItem(i) : a && a.key === "Escape" && n.updateOverflowMenu(!1), a.preventDefault();
        }));
      }), n.focusOnNextEnabledMenuItem(-1);
    }
    t && t.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(t, n, r) {
    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(n), this.services.events.dispatchEvent(T.Toolbar.BUTTON_CLICK, {
      control: t,
      event: n,
      element: r
    }));
  }
  getControlConfigs() {
    const t = y(this.getOptions(), "toolbar", "numberOfIcons") - 1, n = y(this.getOptions(), "toolbar", "controls"), r = [], i = [], s = [];
    return n.forEach((a) => {
      let o = null;
      if (a.type === _t.CUSTOM)
        y(a, "id") === null && (a.id = `toolbar-button-${mv.buttonID++}`), y(a, "shouldBeDisabled") === null && (a.shouldBeDisabled = () => !1), o = a;
      else {
        const l = this.services.domUtils.isFullScreenMode();
        a.type === _t.MAKE_FULLSCREEN && l ? a.type = _t.EXIT_FULLSCREEN : a.type === _t.EXIT_FULLSCREEN && !l && (a.type = _t.MAKE_FULLSCREEN), o = this.getControlConfigByType(a.type);
      }
      o && (o.text = a.text ? a.text : a.type, o.id.indexOf("toolbar-export") !== -1 ? r.push(o) : i.length < t ? y(o, "iconSVG", "content") === null ? s.push(o) : i.push(o) : s.push(o));
    }), s.push(...r), s.length ? {
      buttonList: i,
      overflowMenuItemList: s
    } : {
      buttonList: i
    };
  }
  getToolbarButtonItems() {
    const { buttonList: t, overflowMenuItemList: n } = this.getControlConfigs();
    return n && t.push(this.getOverflowButtonConfig()), t || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: t } = this.getControlConfigs();
    return t || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    const { moreOptions: t } = y(
      this.model.getOptions(),
      "locale",
      "translations",
      "toolbar"
    );
    return {
      id: "toolbar-overflow-menu",
      title: t,
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (n) => this.toggleOverflowMenu(n)
    };
  }
  getControlConfigByType(t) {
    const n = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), r = this.model.getDisplayData(), i = this.model.getOptions(), {
      exportAsCSV: s,
      exportAsJPG: a,
      exportAsPNG: o,
      zoomIn: l,
      zoomOut: c,
      resetZoom: u,
      makeFullScreen: d,
      exitFullScreen: h,
      showAsTable: p
    } = y(i, "locale", "translations", "toolbar");
    let f;
    switch (t) {
      case _t.ZOOM_IN:
        n && (f = {
          id: "toolbar-zoomIn",
          title: l,
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case _t.ZOOM_OUT:
        n && (f = {
          id: "toolbar-zoomOut",
          title: c,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case _t.RESET_ZOOM:
        n && (f = {
          id: "toolbar-resetZoom",
          title: u,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case _t.MAKE_FULLSCREEN:
        f = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: d,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case _t.EXIT_FULLSCREEN:
        f = {
          id: "toolbar-exitfullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: h,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case _t.SHOW_AS_DATATABLE:
        f = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          title: p,
          shouldBeDisabled: () => r.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(T.Modal.SHOW)
        };
        break;
      case _t.EXPORT_CSV:
        f = {
          id: "toolbar-export-CSV",
          title: s,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case _t.EXPORT_PNG:
        f = {
          id: "toolbar-export-PNG",
          title: o,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case _t.EXPORT_JPG:
        f = {
          id: "toolbar-export-JPG",
          title: a,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      // add more toolbar control configuration here
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
    return f;
  }
  getControlIconByType(t) {
    switch (t) {
      case _t.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case _t.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case _t.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case _t.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case _t.EXIT_FULLSCREEN:
        return '<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>';
      case _t.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case _t.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case _t.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case _t.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      // add more icons here
      // svg icon must be with 32x32 viewBox
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
  }
};
fv.buttonID = 0;
let po = fv;
const gv = class vv extends mt {
  constructor(t, n, r, i) {
    super(t, n, i), this.type = "layout", this.configs = i, this.children = r, this._instanceID = vv.instanceID++, this.init();
  }
  init() {
    this.children.forEach((t) => {
      t.components.forEach((n) => {
        n.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const t = this.parent;
    let n = 0;
    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((r) => {
      const i = y(r, "growth");
      return i === ct.PREFERRED || i === ct.FIXED;
    }).each(function(r) {
      n += r.size;
    }), n;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((t) => y(t, "growth") === ct.STRETCH).size();
  }
  render(t = !0) {
    const n = this.model.getOptions(), r = this.parent, { width: i, height: s } = N.getHTMLElementSize(r.node()), a = this.configs.direction === At.ROW || this.configs.direction === At.ROW_REVERSE, o = y(this.model.getOptions(), "style", "prefix"), l = r.classed(
      `${ue}--${o}--layout-row`,
      this.configs.direction === At.ROW
    ).classed(
      `${ue}--${o}--layout-row-reverse`,
      this.configs.direction === At.ROW_REVERSE
    ).classed(
      `${ue}--${o}--layout-column`,
      this.configs.direction === At.COLUMN
    ).classed(
      `${ue}--${o}--layout-column-reverse`,
      this.configs.direction === At.COLUMN_REVERSE
    ).classed(
      `${ue}--${o}--layout-alignitems-center`,
      this.configs.alignItems === ii.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (u) => u.id);
    l.enter().append("div").merge(r.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (u) => `layout-child layout-child-${this._instanceID} ${u.id}`).each(function(u) {
      u.components.forEach((d) => {
        const h = I(this), p = y(u, "renderType") === rt.SVG;
        d.setParent(
          p ? N.appendOrSelect(h, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : h
        ), p && !h.select("svg.layout-svg-wrapper").attr("aria-label") && h.select("svg.layout-svg-wrapper").attr("aria-label", n?.accessibility?.svgAriaLabel || n?.title);
        const f = y(u, "growth");
        (f === ct.PREFERRED || f === ct.FIXED) && d.render(t);
      });
    }), r.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(u) {
      const d = y(u, "growth"), h = y(u, "renderType") === rt.SVG ? N.getSVGElementSize(I(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : N.getHTMLElementSize(this);
      if (d === ct.PREFERRED) {
        const p = a ? h.width : h.height, f = a ? i : s;
        u.size = p / f * 100;
      }
    }), l.exit().remove(), this.children.filter((u) => y(u, "growth") === ct.STRETCH).forEach((u) => {
      u.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const c = r.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (u) => u.id);
    a ? c.style("width", (u) => `${u.size / 100 * i}px`).style("height", "100%") : c.style("height", (u) => `${u.size / 100 * s}px`).style("width", "100%"), c.each(function(u) {
      u.components.forEach((d) => {
        y(u, "growth") === ct.STRETCH && d.render(t);
      });
    });
  }
  // Pass on model to children as well
  setModel(t) {
    super.setModel(t), this.children.forEach((n) => {
      n.components.forEach((r) => r.setModel(t));
    });
  }
  // Pass on essentials to children as well
  setServices(t) {
    super.setServices(t), this.children.forEach((n) => {
      n.components.forEach((r) => r.setServices(t));
    });
  }
  destroy() {
    this.children.forEach((t) => {
      t.components.forEach((n) => n.destroy());
    });
  }
};
gv.instanceID = Math.floor(Math.random() * 99999999999);
let be = gv;
class An extends mt {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    this.getComponentContainer({
      isPresentational: !0
    }).style("width", `${this.configs.size || kh.default.size}px`).style("height", `${this.configs.size || kh.default.size}px`).attr("opacity", 0);
  }
}
class fo extends mt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      const i = this.services.domUtils.getChartID();
      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${i}__modal-title`).attr("aria-describedby", `${i}__modal-description`).attr("tabindex", -1).style("opacity", 1).style("visibility", "visible"), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), this.modal.on("click", this.handleHideModal), this.modal.select(".cds--modal-container").on("click", (s) => {
        s.stopPropagation();
      }), this.modal.select(".cds--modal-close").on("click", this.handleHideModal), typeof window < "u" && window.addEventListener("keydown", this.handleEscapeKey);
    }, this.handleEscapeKey = (i) => {
      i.key === "Escape" && this.handleHideModal();
    }, this.handleHideModal = () => {
      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null).style("opacity", 0).style("visibility", "hidden"), this.modal.on("click", null), this.modal.select(".cds--modal-container").on("click", null), this.modal.select(".cds--modal-close").on("click", null), typeof window < "u" && window.removeEventListener("keydown", this.handleEscapeKey);
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(T.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(T.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const t = this.services.domUtils.getChartID(), n = this.model.getOptions(), { title: r, downloadAsCSV: i } = y(n, "locale", "translations", "tabularRep"), s = y(n, "style", "prefix"), a = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container">
			<div class="cds--modal-header">

				<p class="cds--modal-header__label cds--type-delta" id="${t}__modal-title">${r}</p>

				<p class="cds--modal-header__heading cds--type-beta" id="${t}__modal-description">${en(
      n.title
    )}</p>

				<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${gt(a, 0).map(
      (o) => `<th scope="col">
								<div class="cds--table-header-label">${en(o)}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${a.slice(1).map(
      (o) => `
							<tr>
								${o.map((l) => `<td>${en(l)}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer">
			  <div class="${ue}--${s}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${i}</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const r = I(this.services.domUtils.getHolder()), i = y(n, "style", "prefix");
      this.modal = N.appendOrSelect(r, `div.${ue}--${i}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class _s extends mt {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = rt.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getComponentContainer(), r = y(this.getOptions(), "title"), i = n.selectAll("p.title").data([r]);
    if (i.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(i).html((s) => en(s)), i.node() && i.node().offsetWidth < i.node().scrollWidth) {
      const s = this;
      i.on("mouseover", function(a) {
        s.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: a,
          hoveredElement: i,
          content: i.text()
        });
      }).on("mousemove", function(a) {
        s.services.events.dispatchEvent(T.Tooltip.MOVE, {
          event: a
        });
      }).on("mouseout", function() {
        s.services.events.dispatchEvent(T.Tooltip.HIDE);
      });
    }
    i.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(t, n) {
    if (n <= 0)
      return;
    const r = t.text();
    if (t.node().getComputedTextLength() > n) {
      t.append("tspan").text("...");
      const i = N.appendOrSelect(t, "tspan").node().getComputedTextLength(), s = t.text(), a = this.getSubstringIndex(
        t.node(),
        0,
        s.length - 1,
        n - i
      );
      t.html(s.substring(0, a - 1)).append("tspan").text("...");
      const o = this;
      t.on("mouseover", function(l) {
        o.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: l,
          hoveredElement: t,
          content: r
        });
      }).on("mousemove", function(l) {
        o.services.events.dispatchEvent(T.Tooltip.MOVE, {
          event: l
        });
      }).on("mouseout", function() {
        o.services.events.dispatchEvent(T.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return N.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(t, n, r, i) {
    const s = Math.floor((r + n) / 2);
    return t.getSubStringLength(0, s) > i ? this.getSubstringIndex(t, n, s, i) : t.getSubStringLength(0, s) < i ? t.getSubStringLength(0, s + 1) > i ? s : this.getSubstringIndex(t, s, r, i) : s;
  }
}
class ou extends mt {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = rt.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = y(n, "legend"), i = y(r, "alignment"), s = y(n, "legend", "orientation");
    let a = this.model.getDataGroups();
    const { DISABLED: o } = It.items.status, l = a.some((b) => b.status === o), c = y(r, "order"), u = this.getComponentContainer().classed("center-aligned", i === jt.CENTER).classed("right-aligned", i === jt.RIGHT).classed(s || "horizontal", !0).classed("has-deactivated-items", l).attr("role", ht.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    c && (a = this.sortDataGroups(a, c));
    const d = u.selectAll("div.legend-item").data(a, (b) => b.name), h = d.enter().append("div").attr("class", "legend-item");
    h.merge(u.selectAll("div.legend-item")).classed("active", function(b) {
      return b.status === It.items.status.ACTIVE;
    });
    const p = y(this.getOptions(), "legend", "clickable");
    u.classed("clickable", p && a.length > 1);
    const f = It.checkbox.radius, g = h.append("div").classed("checkbox", !0), m = g.merge(d.select("div.checkbox")).attr("role", ht.CHECKBOX).attr("tabindex", p ? 0 : -1).attr(
      "aria-labelledby",
      (b, _) => this.services.domUtils.generateElementIDString(`legend-datagroup-${_}-title`)
    ).attr("aria-checked", ({ status: b }) => b === It.items.status.ACTIVE).attr("width", f * 2).attr("height", f * 2).attr(
      "class",
      (b) => this.model.getColorClassName({
        classNameTypes: [it.BACKGROUND],
        dataGroupName: b.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (b) => b.status === It.items.status.ACTIVE ? this.model.getFillColor(b.name) || this.model.getStrokeColor(b.name) : null
    ).classed("active", function(b) {
      return b.status === It.items.status.ACTIVE;
    });
    g.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), h.append("p").merge(d.select("p"));
    const v = y(n, "legend", "additionalItems");
    if (v && a.length) {
      const b = this, _ = u.selectAll("div.additional-item").data(v);
      _.exit().remove();
      const E = _.enter().append("div").merge(_).classed("legend-item", !0).classed("additional", !0).attr("role", "img").attr(
        "aria-labelledby",
        ($, D) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${m.size() + D}-title`
        )
      );
      E.selectAll("*").remove();
      let x, S = 1;
      E.append("svg").classed("icon", !0).each(function($) {
        const D = I(this);
        !x || x != $.type ? (x = $.type, S = 1) : S++, b.addAdditionalItem(D, $, S);
      }), E.append("p").merge(E.select("p")), this.truncateLegendText();
    }
    d.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), p && h.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(t, n) {
    if (t.sort(
      (r, i) => n.indexOf(r.name) - n.indexOf(i.name)
    ), n.length < t.length) {
      const r = t.length - n.length;
      return t.slice(r).concat(t.slice(0, r));
    }
    return t;
  }
  addAdditionalItem(t, n, r) {
    const { width: i, height: s } = It.area;
    if (n.type === Gt.RADIUS ? t.style("width", `${s}px`).style("height", `${s}px`) : t.style("width", `${i}px`).style("height", `${s}px`), n.type === Gt.RADIUS) {
      const { iconData: a, fill: o, stroke: l } = It.radius;
      t.attr("fill", "none").selectAll("circle").data(a).enter().append("circle").classed("radius", !0).attr("role", ht.IMG).attr("aria-label", "radius").attr("cx", (c) => c.cx).attr("cy", (c) => c.cy).attr("r", (c) => c.r).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l);
    } else if (n.type === Gt.LINE) {
      const a = It.line;
      t.select("line.line").empty() && t.append("line").classed(`line-${r}`, !0).attr("role", ht.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", a.yPosition).attr("x2", i).attr("y2", a.yPosition).style("stroke", n.stroke ? n.stroke : a.stroke).style("stroke-width", a.strokeWidth);
    } else if (n.type === Gt.AREA)
      t.select("rect.area").empty() && t.append("rect").classed(`area-${r}`, !0).attr("role", ht.IMG).attr("aria-label", "area").attr("width", i).attr("height", s).style(
        "fill",
        r > 3 && !n.fill ? It.area.fill : n.fill
      ).style("stroke", n.stroke);
    else if (n.type === Gt.SIZE) {
      const { iconData: a, fill: o, stroke: l } = It.size;
      t.attr("fill", "none").attr("role", ht.IMG).attr("aria-label", "size").selectAll("rect").data(a).enter().append("rect").classed("size", !0).attr("width", (c) => c.width).attr("height", (c) => c.height).attr("y", () => 0).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l).style("stroke-width", 1);
    } else if (n.type === Gt.QUARTILE) {
      const { iconData: a } = It.quartile;
      t.selectAll("rect").attr("role", ht.IMG).attr("aria-label", "quartile").data(a).enter().append("rect").attr("class", (o, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (o) => o.x).attr("y", (o) => o.y).attr("width", (o) => o.width).attr("height", (o) => o.height);
    } else if (n.type === Gt.ZOOM) {
      const { iconData: a, color: o } = y(It, "zoom"), l = t.attr("role", ht.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(a).enter();
      l.append("g").attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => n.color ? n.color : o), l.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => n.color ? n.color : o);
    }
  }
  truncateLegendText() {
    const t = this.getComponentContainer(), n = y(this.getOptions(), "legend", "truncation"), r = y(n, "type"), i = y(n, "threshold"), s = y(n, "numCharacter"), a = t.selectAll("div.legend-item p");
    a.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), r !== Ve.NONE ? a.html(function(o) {
      const l = en(o.name);
      return l.length > i && l.length !== s ? rs(l, r, s) : l;
    }) : a.html((o) => en(o.name));
  }
  addEventListeners() {
    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = y(r, "legend"), s = y(i, "truncation");
    n.selectAll("div.legend-item").on("mouseover", function(a) {
      t.services.events.dispatchEvent(T.Legend.ITEM_HOVER, {
        hoveredElement: I(this)
      });
      const o = I(this);
      o.select("div.checkbox").classed("hovered", !0);
      const l = o.datum();
      l.name.length > s.threshold && s.numCharacter < l.name.length && s.type !== Ve.NONE && t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: l.name
      });
    }).on("mousemove", function(a) {
      I(this).datum().name.length > s.threshold && s.type !== Ve.NONE && t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function() {
      t.services.events.dispatchEvent(T.Legend.ITEM_CLICK, {
        clickedElement: I(this)
      });
      const a = I(this).datum();
      t.model.toggleDataLabel(a.name);
    }).on("mouseout", function() {
      const a = I(this);
      a.select("div.checkbox").classed("hovered", !1), a.datum().name.length > s.threshold && s.type !== Ve.NONE && t.services.events.dispatchEvent(T.Tooltip.HIDE), t.services.events.dispatchEvent(T.Legend.ITEM_MOUSEOUT, {
        hoveredElement: a
      });
    }), n.selectAll("div.legend-item div.checkbox").on("keyup", function(a) {
      a.key && a.key === "Tab" && t.services.events.dispatchEvent(T.Legend.ITEM_HOVER, {
        hoveredElement: I(this)
      });
    }), n.selectAll("div.legend-item div.checkbox").on("keydown", function(a, o) {
      a.key && a.key === " " ? (a.preventDefault(), t.model.toggleDataLabel(o.name)) : a.key && a.key === "Tab" && t.services.events.dispatchEvent(T.Legend.ITEM_MOUSEOUT, {
        hoveredElement: I(this)
      });
    }), n.selectAll("g.additional-item").on("mouseover", function(a) {
      const o = I(this), l = o.datum();
      l.name.length > s.threshold && t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: l.name
      });
    });
  }
}
class yv extends mt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "chart-clip", this.renderType = rt.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const t = this.parent, { cartesianScales: n } = this.services;
    if (!n) throw new Error("Service cartesianScales was undefined");
    const r = n.getMainXScale(), i = n.getMainYScale(), [s, a] = r.range(), [o, l] = i.range();
    if (!t)
      throw new Error("svg is undefined");
    this.chartClipPath = N.appendOrSelect(
      t,
      `clipPath.${this.type}`
    ).attr("id", this.chartClipId);
    const c = N.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    a - s > 0 && c.attr("x", s).attr("y", l).attr("width", a - s).attr("height", o - l), this.chartClipPath.merge(c).lower();
  }
}
class BD extends yv {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const t = this.parent, { width: n, height: r } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = N.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const i = N.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    i.attr("x", 0).attr("y", 0).attr("width", n).attr("height", r), this.chartClipPath.merge(i).lower();
  }
}
var Mr, Vt;
(function(e) {
  e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom";
})(Vt || (Vt = {}));
var ip = (Mr = {}, Mr[Vt.LEFT] = function(e, t, n) {
  return {
    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),
    left: Math.round(e.left - t.offsetWidth)
  };
}, Mr[Vt.RIGHT] = function(e, t, n) {
  return {
    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),
    left: Math.round(e.left + n.width)
  };
}, Mr[Vt.TOP] = function(e, t, n) {
  return {
    top: Math.round(e.top - t.offsetHeight),
    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)
  };
}, Mr[Vt.BOTTOM] = function(e, t, n) {
  return {
    top: Math.round(e.top + n.height),
    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)
  };
}, Mr), sp = typeof window < "u" ? window : {
  innerHeight: 0,
  innerWidth: 0
}, mo = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.positions = ip, this.positions = Object.assign({}, ip, t);
    }
    return e.prototype.getRelativeOffset = function(t) {
      for (var n = {
        left: t.offsetLeft,
        top: t.offsetTop
      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )
        n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent;
      return n;
    }, e.prototype.getAbsoluteOffset = function(t) {
      for (var n = t, r = {
        top: 0,
        left: 0
      }; n.offsetParent; ) {
        var i = getComputedStyle(n.offsetParent);
        i.position === "static" && i.marginLeft && i.marginTop && (parseInt(i.marginTop, 10) && (r.top += parseInt(i.marginTop, 10)), parseInt(i.marginLeft, 10) && (r.left += parseInt(i.marginLeft, 10))), n = n.offsetParent;
      }
      var s = t.getBoundingClientRect(), a = document.body.getBoundingClientRect();
      return {
        top: s.top - a.top + r.top,
        left: s.left - a.left + r.left
      };
    }, e.prototype.findRelative = function(t, n, r) {
      var i = this.getRelativeOffset(t), s = t.getBoundingClientRect();
      return this.calculatePosition(i, s, n, r);
    }, e.prototype.findAbsolute = function(t, n, r) {
      var i = this.getAbsoluteOffset(t), s = t.getBoundingClientRect();
      return this.calculatePosition(i, s, n, r);
    }, e.prototype.findPosition = function(t, n, r, i) {
      i === void 0 && (i = this.getAbsoluteOffset.bind(this));
      var s = i(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, n, r);
    }, e.prototype.findPositionAt = function(t, n, r) {
      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, n, r);
    }, e.prototype.getPlacementBox = function(t, n) {
      var r = t.offsetHeight + n.top, i = t.offsetWidth + n.left;
      return {
        top: n.top,
        bottom: r,
        left: n.left,
        right: i
      };
    }, e.prototype.addOffset = function(t, n, r) {
      return n === void 0 && (n = 0), r === void 0 && (r = 0), Object.assign({}, t, {
        top: t.top + n,
        left: t.left + r
      });
    }, e.prototype.setElement = function(t, n) {
      t.style.top = n.top + "px", t.style.left = n.left + "px";
    }, e.prototype.findBestPlacement = function(t, n, r, i, s) {
      var a = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this)), s === void 0 && (s = this.findPosition.bind(this));
      var o = r.map(function(l) {
        var c = s(t, n, l), u = a.getPlacementBox(n, c), d = 0, h = 0, p = i();
        u.top < p.top ? d = p.top - u.top : u.bottom > p.height && (d = u.bottom - p.height), u.left < p.left ? h = p.left - u.left : u.right > p.width && (h = u.right - p.width), d && !h ? h = 1 : h && !d && (d = 1);
        var f = n.offsetHeight * n.offsetWidth, g = d * h, m = f - g, v = m / f;
        return {
          placement: l,
          weight: v
        };
      });
      return o.sort(function(l, c) {
        return c.weight - l.weight;
      }), o[0].placement;
    }, e.prototype.findBestPlacementAt = function(t, n, r, i) {
      var s = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this));
      var a = function(o, l, c) {
        return s.findPositionAt(t, l, c);
      };
      return this.findBestPlacement(null, n, r, i, a);
    }, e.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: sp.innerHeight,
        width: sp.innerWidth
      };
    }, e.prototype.calculatePosition = function(t, n, r, i) {
      return this.positions[i] ? this.positions[i](t, r, n) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, e;
  }()
);
new mo();
class lu extends mt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "tooltip", this.renderType = rt.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new mo(), this.handleShowTooltip = (i) => {
      const s = i.detail.data || i.detail.items, a = I(i.detail.event.target).datum();
      let o;
      const l = this.formatItems(this.getItems(i));
      i.detail.content ? o = `<div class="title-tooltip"><p>${Gs(i.detail.content)}</p></div>` : o = Gs(this.getTooltipHTML(l));
      const c = N.appendOrSelect(this.tooltip, "div.content-box");
      if (y(this.getOptions(), "tooltip", "customHTML"))
        if (i.detail.content) {
          const u = `<div class="title-tooltip"><p>${Gs(
            i.detail.content
          )}</p></div>`;
          c.html(u);
        } else
          c.html(
            `<div class="title-tooltip"><p>${Gs(
              this.model.getOptions().tooltip.customHTML(s, o, a)
            )}</p></div>`
          );
      else
        c.html(o);
      c.selectAll(".datapoint-tooltip").each(function(u, d) {
        const h = l[d];
        l[d] && l[d].color && I(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", h.color);
      }), this.positionTooltip(i), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = i.type;
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(T.Tooltip.MOVE, (t) => {
      this.lastTriggeredEventType !== T.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);
    }), this.services.events.addEventListener(T.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(T.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(T.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(T.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(T.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(T.Tooltip.MOVE, null), this.services.events.removeEventListener(T.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(T.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(T.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(T.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(T.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  getItems(t) {
    return t.detail.items ? t.detail.items : [];
  }
  formatItems(t) {
    const n = this.getOptions(), r = y(n, "tooltip", "truncation", "type"), i = y(n, "tooltip", "truncation", "threshold"), s = y(n, "tooltip", "truncation", "numCharacter");
    return r !== Ve.NONE ? t.map((a) => {
      const o = a.labelIcon ? 12 : 0;
      return a.value = this.valueFormatter(a.value, a.label), a.label && a.label.length + o > i && (a.label = rs(a.label, r, s)), a.value && a.value.length > i && (a.value = rs(a.value, r, s)), a;
    }) : t.map((a) => (a.value = this.valueFormatter(a.value, a.label), a));
  }
  getTooltipHTML(t) {
    return '<ul class="multi-tooltip">' + t.map(
      (n) => `<li>
					<div class="datapoint-tooltip${n.bold ? " bold" : ""}">
						${n.class || n.color ? `<div class="tooltip-color ${n.class}"></div>` : ""}
						<div class="label">
						<p>${n.label || ""}</p>
						${n.labelIcon ? `<span class="label-icon"/>${n.labelIcon}</span>` : ""}
						</div>
						${n.value === void 0 || n.value === null ? "" : `<p class="value"/>${n.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  isDate(t) {
    return t instanceof Date;
  }
  valueFormatter(t, n) {
    const r = this.getOptions(), i = y(r, "tooltip", "valueFormatter"), {
      code: s,
      number: a,
      date: o
    } = y(r, "locale");
    if (i)
      return i(t, n);
    if (this.isDate(t))
      return o(t, s, { month: "short", day: "numeric", year: "numeric" });
    try {
      if (typeof t == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(t)) {
        const l = new Date(t);
        return o(l, s, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }
    } catch {
    }
    return a(t, s);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = y(n, "tooltip", "enabled");
    if (r) {
      const i = I(this.services.domUtils.getHolder()), s = y(n, "style", "prefix");
      this.tooltip = N.appendOrSelect(i, `div.${ue}--${s}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else !r && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  addOffsetByPlacement(t, n, r) {
    const i = Object.assign({}, t);
    return n == Vt.LEFT ? i.left -= r : n == Vt.RIGHT ? i.left += r : n == Vt.TOP ? i.top -= r : n == Vt.BOTTOM && (i.top += r), i;
  }
  positionTooltip(t) {
    const n = this.services.domUtils.getHolder(), r = n.offsetWidth, i = n.offsetHeight, s = this.tooltip.node(), a = this.getOptions(), o = y(a, "zoomBar", "top", "enabled"), l = !!y(t, "detail", "noWrap"), c = Array.isArray(y(t, "detail", "placements")), u = c ? y(t, "detail", "placements") : [Vt.RIGHT, Vt.LEFT, Vt.TOP, Vt.BOTTOM];
    let d, { horizontalOffset: h } = Rh;
    const { defaultOffset: p } = Rh;
    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", l), c) {
      const m = y(t, "detail", "event", "target"), v = this.services.domUtils.getElementOffset(m, !0);
      d = this.positionService.findBestPlacementAt(
        v,
        s,
        u,
        () => ({
          top: 0,
          left: 0,
          width: r,
          height: i
        })
      );
      let b = this.positionService.findPosition(
        m,
        s,
        d,
        () => this.services.domUtils.getElementOffset(m)
      );
      b = this.addOffsetByPlacement(b, d, p), this.positionService.setElement(s, b);
      return;
    }
    let f = y(t, "detail", "mousePosition");
    if (!f)
      f = rr(y(t, "detail", "event"), n);
    else {
      const m = y(a, "zoomBar", "top", "type"), v = ye.height[m];
      o && (f[1] += v + ye.spacerHeight);
    }
    f[0] / r > 0.9 ? d = Vt.LEFT : f[0] / r < 0.1 ? d = Vt.RIGHT : d = this.positionService.findBestPlacementAt(
      {
        left: f[0],
        top: f[1]
      },
      s,
      u,
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: r,
        height: i
      })
    ), d === Vt.LEFT && (h *= -1);
    const g = this.positionService.findPositionAt(
      {
        left: f[0] + h,
        top: f[1]
      },
      s,
      d
    );
    this.positionService.setElement(s, g);
  }
}
const xv = class ia extends mt {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = rt.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.parent, r = this.getComponentContainer({
      isPresentational: !0
    });
    if (!n) throw new Error("SVG was not defined");
    const i = N.appendOrSelect(
      n,
      "svg.chart-grid-backdrop"
    ), s = N.appendOrSelect(i, `g.${this.type}`), a = N.appendOrSelect(s, this.selectionSelector), { width: o, height: l } = N.getSVGElementSize(i, {
      useAttrs: !0
    }), { cartesianScales: c } = this.services, u = c.getMainXScaleType(), d = c.getMainXScale(), [h] = d.range();
    r.attr("transform", `translate(${h},0)`);
    const p = N.appendOrSelect(r, this.frontSelectionSelector);
    if (d && u === et.TIME) {
      let f = this.model.get("zoomDomain");
      f === void 0 && (f = this.services.zoom.getDefaultZoomBarDomain(), f && this.model.set({ zoomDomain: f }, { animate: !1 }));
      const g = (x) => {
        const S = x[1] - x[0];
        let $ = "0," + S.toString();
        const D = Math.floor(l / ia.DASH_LENGTH), C = D * ia.DASH_LENGTH;
        for (let R = 0; R < D; R++)
          $ += "," + ia.DASH_LENGTH;
        $ += "," + (l - C), D % 2 === 1 && ($ += ",0"), $ += "," + S.toString(), $ += "," + l.toString(), p.attr("stroke-dasharray", $);
      }, m = (x) => {
        const S = x.selection;
        S === null || S[0] === S[1] || (p.attr("x", parseFloat(a.attr("x")) + parseFloat(i.attr("x"))).attr("y", a.attr("y")).attr("width", a.attr("width")).attr("height", a.attr("height")).style("cursor", "pointer").style("display", null), g(S));
      }, v = (x, S) => {
        const $ = eg().range([0, o]).domain(f);
        let D = [$.invert(x), $.invert(S)], C = "manual";
        D[0].valueOf() === D[1].valueOf() ? (D = this.services.zoom.getDefaultZoomBarDomain(), C = "reset") : C = "manual", (f[0].valueOf() !== D[0].valueOf() || f[1].valueOf() !== D[1].valueOf()) && this.services.zoom.handleDomainChange(D, { dispatchEvent: !0, type: C });
      };
      let b;
      const _ = (x) => {
        const S = x.selection;
        S !== null && (v(S[0], S[1]), s.call(b.move, null), p.style("display", "none"));
      };
      l != 0 && o != 0 && (b = Dg().extent([
        [0, 0],
        [o - 1, l]
      ]).on("start brush end", m).on("end.brushed", _), s.call(b));
      const E = this.services.zoom.getZoomRatio();
      i.on("click", function(x) {
        if (x.shiftKey) {
          const S = this.services.domUtils.getHolder(), $ = rr(s.node(), S)[0];
          let D = $ - o * E / 2;
          D < 0 && (D = 0);
          let C = $ + o * E / 2;
          C > o && (C = o), v(D, C);
        }
      });
    }
  }
};
xv.DASH_LENGTH = 4;
let HD = xv;
class VD extends mt {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = rt.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = Dg(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(T.ZoomBar.UPDATE, this.render.bind(this));
    const t = y(this.getOptions(), "zoomBar", G.TOP, "data");
    this.model.setZoomBarData(t);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "zoom bar"
    }), r = this.services.zoom.isZoomBarLoading(G.TOP), i = this.services.zoom.isZoomBarLocked(G.TOP), s = y(this.getOptions(), "zoomBar", G.TOP, "type"), a = y(this.getOptions(), "axes", G.BOTTOM, "highlights"), o = ye.height[s], { width: l } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (l === 0)
      return;
    let c = 0;
    const u = this.model.get("axesMargins");
    u && u.left && (c = u.left);
    const d = N.appendOrSelect(n, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1).attr("role", "presentation");
    if (N.appendOrSelect(n, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", ye.spacerHeight).attr("opacity", 1).attr("fill", "none"), s === Ke.GRAPH_VIEW ? N.appendOrSelect(d, "rect.zoom-bg").attr("x", c).attr("y", 0).attr("width", l - c).attr("height", "100%").classed("zoom-bg-skeleton", r).style(
      "stroke",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : s === Ke.SLIDER_VIEW && N.appendOrSelect(d, "rect.zoom-slider-bg").attr("x", c).attr("y", o / 2 - 1).attr("width", l - c).attr("height", 2).classed("zoom-slider-bg-skeleton", r).style(
      "stroke",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), r) {
      this.renderSkeleton(d, c, l);
      return;
    }
    const { cartesianScales: h } = this.services, p = h.getMainXScale(), f = h.getMainYScale(), g = h.getMainXScaleType();
    if (p && g === et.TIME) {
      let m = this.services.zoom.getZoomBarData();
      if (Be(m) || m.length === 1)
        return;
      this.xScale = p.copy(), this.yScale = f.copy();
      const v = this.services.zoom.getDefaultZoomBarDomain(m);
      m = this.compensateDataForDefaultDomain(m, v);
      const b = this.model.get("initialZoomDomain"), _ = y(
        this.getOptions(),
        "zoomBar",
        G.TOP,
        "initialZoomDomain"
      );
      _ && _[0] && _[1] && (_[0] = new Date(_[0]), _[1] = new Date(_[1])), _ && !(b && b[0].valueOf() === _[0].valueOf() && b[1].valueOf() === _[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: at([], _),
          zoomDomain: _ ? at([], _) : v
        },
        { skipUpdate: !0 }
      ) : _ === null && b !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: at([], v)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([c, l]).domain(v), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(ze(m, (S) => S.value));
      const E = this.model.get("zoomDomain");
      if (s === Ke.GRAPH_VIEW && (this.renderZoomBarArea(d, "path.zoom-graph-area-unselected", m, null), this.updateClipPath(n, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(d, "path.zoom-graph-area", m, this.clipId), this.renderZoomBarBaseline(d, c, l), a)) {
        const S = a.highlightStartMapsTo, $ = a.highlightEndMapsTo, D = a.color, C = a.labelMapsTo;
        a.data.forEach((R, M) => {
          N.appendOrSelect(d, `rect.highlight-${M}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(R[S])).attr(
            "width",
            this.xScale(R[$]) - this.xScale(R[S])
          ).style(
            "fill",
            D && D.scale[R[C]] ? D.scale[R[C]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            D && D.scale[R[C]] ? D.scale[R[C]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(E, c, l);
      const x = N.appendOrSelect(n, this.brushSelector).call(this.brush);
      if (E !== void 0) if (E[0].valueOf() === E[1].valueOf())
        x.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
      else {
        const S = E.map(($) => this.xScale($));
        S[1] - S[0] < this.MIN_SELECTION_DIFF || (x.call(this.brush.move, S), this.updateBrushHandle(this.getComponentContainer(), S));
      }
      i && (this.brush.filter(() => !1), x.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(t, n, r) {
    const i = (o) => {
      const l = o.selection;
      l === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : l[0] === l[1] || this.handleBrushedEvent(o, t, this.xScale, l);
    }, s = y(this.getOptions(), "zoomBar", G.TOP, "type"), a = ye.height[s];
    this.brush.extent([
      [n, 0],
      [r, a]
    ]).on("start brush end", null).on("start brush end", i);
  }
  // brush event listener
  handleBrushedEvent(t, n, r, i) {
    const s = [r.invert(i[0]), r.invert(i[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), i), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {
      let a = "manual";
      if (n && n[0] && n[1]) {
        const l = this.services.zoom.getDefaultZoomBarDomain();
        s[0].valueOf() === l[0].valueOf() && s[1].valueOf() === l[1].valueOf() ? a = "reset" : a = "manual";
      }
      (n === void 0 || n[0] !== s[0] || n[1] !== s[1]) && this.services.zoom.handleDomainChange(s, {
        dispatchEvent: !1,
        type: a
      });
      let o;
      t.type === "start" ? o = T.ZoomBar.SELECTION_START : t.type === "brush" ? o = T.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (o = T.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(T.ZoomDomain.CHANGE, {
        newDomain: s,
        type: a
      })), this.services.events.dispatchEvent(o, {
        selection: i,
        newDomain: s
      });
    }
  }
  updateBrushHandle(t, n) {
    const r = this, i = ye.handleWidth, s = y(this.getOptions(), "zoomBar", G.TOP, "type"), a = ye.height[s], o = -i / 2, l = ye.handleBarWidth, c = s === Ke.GRAPH_VIEW ? ye.handleBarHeight : 6, u = -l / 2, d = (a - c) / 2;
    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(p) {
      if (p.type === "w")
        return Math.max(n[0] + o, r.maxSelectionRange[0]);
      if (p.type === "e")
        return Math.min(n[1] + o, r.maxSelectionRange[1] - i);
    }).attr("y", 0).attr("width", i).attr("height", a).attr("cursor", "ew-resize").style("display", null);
    const h = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    h.enter().append("rect").attr("class", function(p) {
      return "handle-bar handle-bar--" + p.type;
    }), h.attr("x", function(p) {
      if (p.type === "w")
        return Math.max(
          n[0] + u,
          r.maxSelectionRange[0] - o + u
        );
      if (p.type === "e")
        return Math.min(
          n[1] + u,
          r.maxSelectionRange[1] + o + u
        );
    }).attr("y", d).attr("width", l).attr("height", c).attr("cursor", "ew-resize"), s === Ke.SLIDER_VIEW && this.updateSliderSelectedArea(n), this.updateClipPath(
      t,
      this.clipId,
      n[0],
      0,
      n[1] - n[0],
      a
    );
  }
  updateSliderSelectedArea(t) {
    const n = y(this.getOptions(), "zoomBar", G.TOP, "type"), r = ye.height[n], i = this.getComponentContainer().select("svg.zoom-container");
    N.appendOrSelect(i, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", r / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);
  }
  renderZoomBarArea(t, n, r, i) {
    const { cartesianScales: s } = this.services, a = s.getMainXAxisPosition(), o = s.getMainYAxisPosition(), l = s.getMainXScaleType(), c = s.getMainYScaleType(), u = (v, b, _) => (E) => s.getValueFromScale(v, b, _, E), d = u(this.xScale, l, a), h = u(this.yScale, c, o), p = y(this.getOptions(), "zoomBar", G.TOP, "type"), f = ye.height[p], g = su().x((v) => d(v)).y0(f).y1((v) => f - h(v)), m = N.appendOrSelect(t, n).datum(r).attr("d", g);
    i && m.attr("clip-path", `url(#${i})`);
  }
  updateClipPath(t, n, r, i, s, a) {
    const o = N.appendOrSelect(t, "clipPath").attr("id", n);
    N.appendOrSelect(o, "rect").attr("x", r).attr("y", i).attr("width", s).attr("height", a);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(t, n) {
    if (!t || t.length < 2)
      return;
    const r = Sn(t), i = this.services.cartesianScales.getDomainIdentifier(), s = this.services.cartesianScales.getRangeIdentifier();
    if (Number(n[0]) < Number(r[0][i])) {
      const a = {};
      a[i] = n[0], a[s] = 0, r.unshift(a);
    }
    if (Number(n[1]) > Number(r[r.length - 1][i])) {
      const a = {};
      a[i] = n[1], a[s] = 0, r.push(a);
    }
    return r;
  }
  renderZoomBarBaseline(t, n, r, i = !1) {
    const s = y(
      this.model.getOptions(),
      "zoomBar",
      G.TOP,
      "type"
    ), a = ye.height[s], o = bs()([
      [n, a],
      [r, a]
    ]);
    N.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", i).style(
      "stroke",
      i ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(t, n, r) {
    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), N.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), y(this.getOptions(), "zoomBar", G.TOP, "type") === Ke.GRAPH_VIEW && this.renderZoomBarBaseline(t, n, r, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(T.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class GD extends mt {
  constructor(t, n) {
    super(t, n), this.type = "threshold", this.renderType = rt.SVG, this.positionService = new mo();
  }
  render(t = !1) {
    const n = y(this.getOptions(), "axes"), r = [];
    Object.keys(n).forEach((c) => {
      if (Object.values(G).includes(c)) {
        const u = n[c];
        u.thresholds && u.thresholds.length > 0 && r.push({
          axisPosition: c,
          thresholds: u.thresholds,
          correspondingDatasets: u?.correspondingDatasets,
          mapsTo: u?.mapsTo
        });
      }
    });
    const i = this.getComponentContainer({
      ariaLabel: "threshold lines",
      withinChartClip: !0
    }).selectAll("g.axis-thresholds").data(r, (c) => c.axisPosition);
    i.exit().attr("opacity", 0).remove();
    const s = i.enter().append("g").merge(i);
    s.attr("class", (c) => `axis-thresholds ${c.axisPosition}`);
    const a = s.selectAll("g.threshold-group").data(
      (c) => c.thresholds.map((u) => (u.axisPosition = c.axisPosition, u.datum = this.constructDatumObj(c, u), u))
    );
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g");
    o.append("line").attr("class", "threshold-line"), o.append("rect").attr("class", "threshold-hoverable-area"), o.merge(a).attr("class", "threshold-group");
    const l = this;
    s.each(function({ axisPosition: c }) {
      const u = l.services.cartesianScales.getScaleByPosition(
        c
      ), d = l.services.cartesianScales.getScaleTypeByPosition(c);
      let h = null, p = null;
      c === G.LEFT || c === G.RIGHT ? (p = u, h = l.services.cartesianScales.getMainXScale()) : (h = u, p = l.services.cartesianScales.getMainYScale());
      const f = d === et.LABELS, [g, m] = h.range(), [v, b] = p.range(), { cartesianScales: _ } = l.services, E = _.getOrientation(), x = (R) => _.getDomainValue(R), S = (R) => _.getRangeValue(R), [$, D] = En(
        x,
        S,
        E
      ), C = I(this);
      c === G.TOP || c === G.BOTTOM ? (C.selectAll("line.threshold-line").transition().call(
        (R) => l.services.transitions.setupTransition({
          transition: R,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("y1", b).attr("y2", v).attr(
        "x1",
        ({ datum: R }) => $(R) + (f ? u.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: R }) => $(R) + (f ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: R }) => R), C.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: R }) => -$(R)).attr("width", Math.abs(v - b)).classed("rotate", !0)) : (C.selectAll("line.threshold-line").transition().call(
        (R) => l.services.transitions.setupTransition({
          transition: R,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("x1", g).attr("x2", m).attr(
        "y1",
        ({ datum: R }) => D(R) + (f ? u.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: R }) => D(R) + (f ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: R }) => R), C.selectAll("rect.threshold-hoverable-area").attr("x", g).attr("y", ({ datum: R }) => D(R)).attr("width", Math.abs(m - g)).classed("rotate", !1));
    }), this.services.events.addEventListener(T.Threshold.SHOW, (c) => {
      this.setThresholdLabelPosition(c.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(T.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(t) {
    const { value: n, axisPosition: r } = t, i = this.getOptions(), s = this.services.cartesianScales.getScaleTypeByPosition(r), { code: a, number: o } = y(i, "locale");
    if (s === et.TIME) {
      const l = [G.LEFT, G.RIGHT].includes(r), c = this.services.cartesianScales.getMainXScale(), u = this.services.cartesianScales.getMainYScale(), d = l ? u : c, h = y(i, "timeScale"), p = Dl(
        d.ticks(),
        y(h, "timeInterval")
      );
      return Ll(n, 0, d.ticks(), p, h, i.locale);
    }
    return o(n, a);
  }
  appendThresholdLabel() {
    const t = I(this.services.domUtils.getHolder()), n = y(this.getOptions(), "style", "prefix");
    this.label = N.appendOrSelect(
      t,
      `div.${ue}--${n}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: t, datum: n }) {
    const r = this.services.domUtils.getHolder(), i = rr(t, r), s = n.valueFormatter ? n.valueFormatter(n.value) : this.getFormattedValue(n);
    this.label.html(en(`${n.label || "Threshold"}: ${s}`)).style("background-color", n.fillColor);
    const a = this.label.node(), o = this.positionService.findBestPlacementAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      [Vt.RIGHT, Vt.LEFT, Vt.TOP, Vt.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: r.offsetWidth,
        height: r.offsetHeight
      })
    ), l = this.positionService.findPositionAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      o
    );
    this.positionService.setElement(a, l);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(t, n) {
    const r = {};
    return t.correspondingDatasets && (r.group = y(t, "correspondingDatasets", 0)), r[t.mapsTo] = n.value, r;
  }
  addEventListeners() {
    const t = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      I(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(T.Threshold.SHOW, {
        event: n,
        hoveredElement: I(this),
        datum: I(this).datum()
      });
    }).on("mouseout", function(n) {
      I(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(T.Threshold.HIDE, {
        event: n,
        hoveredElement: I(this),
        datum: I(this).datum()
      });
    });
  }
}
class zD extends mt {
  constructor(t, n) {
    super(t, n), this.type = "highlight", this.renderType = rt.SVG, this.positionService = new mo(), this.highlightStrokeWidth = 1;
  }
  render(t = !1) {
    const n = y(this.getOptions(), "axes"), r = [];
    Object.keys(n).forEach((c) => {
      if (Object.values(G).includes(c)) {
        const u = n[c];
        u.highlights && u.highlights.data.length > 0 && r.push({
          axisPosition: c,
          highlightStartMapsTo: u.highlights.highlightStartMapsTo,
          highlightEndMapsTo: u.highlights.highlightEndMapsTo,
          labelMapsTo: u.highlights.labelMapsTo,
          highlight: u.highlights.data,
          color: u.highlights.color
        });
      }
    });
    const i = this.getComponentContainer({
      ariaLabel: "highlight areas",
      withinChartClip: !0
    }).selectAll("g.axis-highlight").data(r, (c) => c.axisPosition);
    i.exit().attr("opacity", 0).remove();
    const s = i.enter().append("g").merge(i);
    s.attr("class", (c) => `axis-highlight ${c.axisPosition}`);
    const a = s.selectAll("g.highlight-group").data(
      (c) => c.highlight.map((u) => (u.axisPosition = c.axisPosition, u.highlightStartMapsTo = c.highlightStartMapsTo, u.labelMapsTo = c.labelMapsTo, u.color = c.color, u.highlightEndMapsTo = c.highlightEndMapsTo, u))
    );
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g");
    o.append("rect").attr("class", "highlight-bar"), o.append("line").attr("class", "highlight-line"), o.merge(a).attr("class", "highlight-group");
    const l = this;
    s.each(function({ axisPosition: c }) {
      const u = l.services.cartesianScales.getMainXScale(), d = l.services.cartesianScales.getMainYScale(), [h, p] = u.range(), [f, g] = d.range(), { cartesianScales: m } = l.services, v = m.getOrientation(), b = ($) => m.getDomainValue($), _ = ($) => m.getRangeValue($), [E, x] = En(
        b,
        _,
        v
      ), S = I(this);
      c === G.TOP || c === G.BOTTOM ? S.selectAll("rect.highlight-bar").transition().call(
        ($) => l.services.transitions.setupTransition({
          transition: $,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("y", Math.max(g + l.highlightStrokeWidth, 0)).attr("height", Math.max(f - 2 * l.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: $, ...D }) => E(D[$])).attr(
        "width",
        ({ highlightStartMapsTo: $, highlightEndMapsTo: D, ...C }) => Math.max(E(C[D]) - E(C[$]), 0)
      ).style("stroke", ({ color: $, labelMapsTo: D, ...C }) => $ && $.scale[C[D]] ? $.scale[C[D]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: $, labelMapsTo: D, ...C }) => $ && $.scale[C[D]] ? $.scale[C[D]] : null) : S.selectAll("rect.highlight-bar").transition().call(
        ($) => l.services.transitions.setupTransition({
          transition: $,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("x", h).attr("width", Math.max(p - h, 0)).attr("y", ({ highlightEndMapsTo: $, ...D }) => x(D[$])).attr(
        "height",
        ({ highlightStartMapsTo: $, highlightEndMapsTo: D, ...C }) => Math.max(x(C[$]) - x(C[D]), 0)
      ).style("stroke", ({ color: $, labelMapsTo: D, ...C }) => $ && $.scale[C[D]] ? $.scale[C[D]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: $, labelMapsTo: D, ...C }) => $ && $.scale[C[D]] ? $.scale[C[D]] : null);
    });
  }
}
class bv extends lu {
  getItems(t) {
    if (t.detail.items)
      return t.detail.items;
    const { data: n } = t.detail;
    if (!n || !n.length || !n[0])
      return [];
    const r = this.getOptions(), { cartesianScales: i } = this.services, s = i.getDomainIdentifier(), a = i.isDualAxes(), { groupMapsTo: o } = r.data, l = i.getDomainLabel();
    let c = i.getRangeLabel();
    const u = n[0][s];
    let d;
    if (n.length === 1) {
      const h = n[0], p = i.getRangeIdentifier(h);
      if (a) {
        const g = i.getRangeAxisPosition({
          datum: h,
          groups: [h[o]]
        });
        c = i.getScaleLabel(g);
      }
      const f = h[p];
      d = [
        {
          label: l,
          value: u
        },
        ...Array.isArray(f) && f.length === 2 ? [
          {
            label: "Start",
            value: f[0]
          },
          {
            label: "End",
            value: f[1]
          }
        ] : [
          {
            label: c,
            value: h[p]
          }
        ]
      ], t.detail.additionalItems && t.detail.additionalItems.forEach(
        (g) => d.push({
          label: g.label,
          value: g.value
        })
      ), d.push({
        label: gt(r, "locale.translations.group") || gt(r, "tooltip.groupLabel"),
        value: h[o],
        color: this.model.getFillColor(h[o]),
        class: this.model.getColorClassName({
          classNameTypes: [it.TOOLTIP],
          dataGroupName: h[o]
        })
      });
    } else if (n.length > 1 && (d = [
      {
        label: l,
        value: u
      }
    ], d = d.concat(
      n.map((h) => {
        const p = h[i.getRangeIdentifier(h)];
        return {
          label: h[o],
          value: Array.isArray(p) && p.length === 2 ? `${p[0]} - ${p[1]}` : p,
          color: this.model.getFillColor(h[o]),
          class: this.model.getColorClassName({
            classNameTypes: [it.TOOLTIP],
            dataGroupName: h[o]
          })
        };
      }).sort((h, p) => p.value - h.value)
    ), !a && y(r, "tooltip", "showTotal") === !0)) {
      const h = i.getRangeIdentifier(), p = y(r, "tooltip", "customTotalCalculation");
      let f;
      p ? f = p(n) : f = n.reduce(
        (g, m) => g + m[h],
        0
      ), d.push({
        label: gt(r, "tooltip.totalLabel") || gt(r, "locale.translations.total") || "Total",
        value: f,
        bold: !0
      });
    }
    return d;
  }
}
function ap(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function FD(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function ol(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function jD(e) {
  return e.depth;
}
function WD(e, t) {
  return t - 1 - e.height;
}
function _v(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function zs(e) {
  return function() {
    return e;
  };
}
function op(e, t) {
  return Pa(e.source, t.source) || e.index - t.index;
}
function lp(e, t) {
  return Pa(e.target, t.target) || e.index - t.index;
}
function Pa(e, t) {
  return e.y0 - t.y0;
}
function ll(e) {
  return e.value;
}
function qD(e) {
  return e.index;
}
function YD(e) {
  return e.nodes;
}
function XD(e) {
  return e.links;
}
function cp(e, t) {
  const n = e.get(t);
  if (!n) throw new Error("missing: " + t);
  return n;
}
function up({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = r + i.width / 2, r += i.width;
  }
}
function ZD() {
  let e = 0, t = 0, n = 1, r = 1, i = 24, s = 8, a, o = qD, l = _v, c, u, d = YD, h = XD, p = 6;
  function f() {
    const O = { nodes: d.apply(null, arguments), links: h.apply(null, arguments) };
    return g(O), m(O), v(O), b(O), x(O), up(O), O;
  }
  f.update = function(O) {
    return up(O), O;
  }, f.nodeId = function(O) {
    return arguments.length ? (o = typeof O == "function" ? O : zs(O), f) : o;
  }, f.nodeAlign = function(O) {
    return arguments.length ? (l = typeof O == "function" ? O : zs(O), f) : l;
  }, f.nodeSort = function(O) {
    return arguments.length ? (c = O, f) : c;
  }, f.nodeWidth = function(O) {
    return arguments.length ? (i = +O, f) : i;
  }, f.nodePadding = function(O) {
    return arguments.length ? (s = a = +O, f) : s;
  }, f.nodes = function(O) {
    return arguments.length ? (d = typeof O == "function" ? O : zs(O), f) : d;
  }, f.links = function(O) {
    return arguments.length ? (h = typeof O == "function" ? O : zs(O), f) : h;
  }, f.linkSort = function(O) {
    return arguments.length ? (u = O, f) : u;
  }, f.size = function(O) {
    return arguments.length ? (e = t = 0, n = +O[0], r = +O[1], f) : [n - e, r - t];
  }, f.extent = function(O) {
    return arguments.length ? (e = +O[0][0], n = +O[1][0], t = +O[0][1], r = +O[1][1], f) : [[e, t], [n, r]];
  }, f.iterations = function(O) {
    return arguments.length ? (p = +O, f) : p;
  };
  function g({ nodes: O, links: w }) {
    for (const [k, U] of O.entries())
      U.index = k, U.sourceLinks = [], U.targetLinks = [];
    const L = new Map(O.map((k, U) => [o(k, U, O), k]));
    for (const [k, U] of w.entries()) {
      U.index = k;
      let { source: Z, target: j } = U;
      typeof Z != "object" && (Z = U.source = cp(L, Z)), typeof j != "object" && (j = U.target = cp(L, j)), Z.sourceLinks.push(U), j.targetLinks.push(U);
    }
    if (u != null)
      for (const { sourceLinks: k, targetLinks: U } of O)
        k.sort(u), U.sort(u);
  }
  function m({ nodes: O }) {
    for (const w of O)
      w.value = w.fixedValue === void 0 ? Math.max(ol(w.sourceLinks, ll), ol(w.targetLinks, ll)) : w.fixedValue;
  }
  function v({ nodes: O }) {
    const w = O.length;
    let L = new Set(O), k = /* @__PURE__ */ new Set(), U = 0;
    for (; L.size; ) {
      for (const Z of L) {
        Z.depth = U;
        for (const { target: j } of Z.sourceLinks)
          k.add(j);
      }
      if (++U > w) throw new Error("circular link");
      L = k, k = /* @__PURE__ */ new Set();
    }
  }
  function b({ nodes: O }) {
    const w = O.length;
    let L = new Set(O), k = /* @__PURE__ */ new Set(), U = 0;
    for (; L.size; ) {
      for (const Z of L) {
        Z.height = U;
        for (const { source: j } of Z.targetLinks)
          k.add(j);
      }
      if (++U > w) throw new Error("circular link");
      L = k, k = /* @__PURE__ */ new Set();
    }
  }
  function _({ nodes: O }) {
    const w = ap(O, (U) => U.depth) + 1, L = (n - e - i) / (w - 1), k = new Array(w);
    for (const U of O) {
      const Z = Math.max(0, Math.min(w - 1, Math.floor(l.call(null, U, w))));
      U.layer = Z, U.x0 = e + Z * L, U.x1 = U.x0 + i, k[Z] ? k[Z].push(U) : k[Z] = [U];
    }
    if (c) for (const U of k)
      U.sort(c);
    return k;
  }
  function E(O) {
    const w = FD(O, (L) => (r - t - (L.length - 1) * a) / ol(L, ll));
    for (const L of O) {
      let k = t;
      for (const U of L) {
        U.y0 = k, U.y1 = k + U.value * w, k = U.y1 + a;
        for (const Z of U.sourceLinks)
          Z.width = Z.value * w;
      }
      k = (r - k + a) / (L.length + 1);
      for (let U = 0; U < L.length; ++U) {
        const Z = L[U];
        Z.y0 += k * (U + 1), Z.y1 += k * (U + 1);
      }
      H(L);
    }
  }
  function x(O) {
    const w = _(O);
    a = Math.min(s, (r - t) / (ap(w, (L) => L.length) - 1)), E(w);
    for (let L = 0; L < p; ++L) {
      const k = Math.pow(0.99, L), U = Math.max(1 - k, (L + 1) / p);
      $(w, k, U), S(w, k, U);
    }
  }
  function S(O, w, L) {
    for (let k = 1, U = O.length; k < U; ++k) {
      const Z = O[k];
      for (const j of Z) {
        let F = 0, Y = 0;
        for (const { source: Q, value: q } of j.targetLinks) {
          let tt = q * (j.layer - Q.layer);
          F += P(Q, j) * tt, Y += tt;
        }
        if (!(Y > 0)) continue;
        let ot = (F / Y - j.y0) * w;
        j.y0 += ot, j.y1 += ot, M(j);
      }
      c === void 0 && Z.sort(Pa), D(Z, L);
    }
  }
  function $(O, w, L) {
    for (let k = O.length, U = k - 2; U >= 0; --U) {
      const Z = O[U];
      for (const j of Z) {
        let F = 0, Y = 0;
        for (const { target: Q, value: q } of j.sourceLinks) {
          let tt = q * (Q.layer - j.layer);
          F += B(j, Q) * tt, Y += tt;
        }
        if (!(Y > 0)) continue;
        let ot = (F / Y - j.y0) * w;
        j.y0 += ot, j.y1 += ot, M(j);
      }
      c === void 0 && Z.sort(Pa), D(Z, L);
    }
  }
  function D(O, w) {
    const L = O.length >> 1, k = O[L];
    R(O, k.y0 - a, L - 1, w), C(O, k.y1 + a, L + 1, w), R(O, r, O.length - 1, w), C(O, t, 0, w);
  }
  function C(O, w, L, k) {
    for (; L < O.length; ++L) {
      const U = O[L], Z = (w - U.y0) * k;
      Z > 1e-6 && (U.y0 += Z, U.y1 += Z), w = U.y1 + a;
    }
  }
  function R(O, w, L, k) {
    for (; L >= 0; --L) {
      const U = O[L], Z = (U.y1 - w) * k;
      Z > 1e-6 && (U.y0 -= Z, U.y1 -= Z), w = U.y0 - a;
    }
  }
  function M({ sourceLinks: O, targetLinks: w }) {
    if (u === void 0) {
      for (const { source: { sourceLinks: L } } of w)
        L.sort(lp);
      for (const { target: { targetLinks: L } } of O)
        L.sort(op);
    }
  }
  function H(O) {
    if (u === void 0)
      for (const { sourceLinks: w, targetLinks: L } of O)
        w.sort(lp), L.sort(op);
  }
  function P(O, w) {
    let L = O.y0 - (O.sourceLinks.length - 1) * a / 2;
    for (const { target: k, width: U } of O.sourceLinks) {
      if (k === w) break;
      L += U + a;
    }
    for (const { source: k, width: U } of w.targetLinks) {
      if (k === O) break;
      L -= U;
    }
    return L;
  }
  function B(O, w) {
    let L = w.y0 - (w.targetLinks.length - 1) * a / 2;
    for (const { source: k, width: U } of w.targetLinks) {
      if (k === O) break;
      L += U + a;
    }
    for (const { target: k, width: U } of O.sourceLinks) {
      if (k === w) break;
      L -= U;
    }
    return L;
  }
  return f;
}
var sc = Math.PI, ac = 2 * sc, Zn = 1e-6, KD = ac - Zn;
function oc() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Ev() {
  return new oc();
}
oc.prototype = Ev.prototype = {
  constructor: oc,
  moveTo: function(e, t) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(e, t) {
    this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(e, t, n, r) {
    this._ += "Q" + +e + "," + +t + "," + (this._x1 = +n) + "," + (this._y1 = +r);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._ += "C" + +e + "," + +t + "," + +n + "," + +r + "," + (this._x1 = +i) + "," + (this._y1 = +s);
  },
  arcTo: function(e, t, n, r, i) {
    e = +e, t = +t, n = +n, r = +r, i = +i;
    var s = this._x1, a = this._y1, o = n - e, l = r - t, c = s - e, u = a - t, d = c * c + u * u;
    if (i < 0) throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
    else if (d > Zn) if (!(Math.abs(u * o - l * c) > Zn) || !i)
      this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
    else {
      var h = n - s, p = r - a, f = o * o + l * l, g = h * h + p * p, m = Math.sqrt(f), v = Math.sqrt(d), b = i * Math.tan((sc - Math.acos((f + d - g) / (2 * m * v))) / 2), _ = b / v, E = b / m;
      Math.abs(_ - 1) > Zn && (this._ += "L" + (e + _ * c) + "," + (t + _ * u)), this._ += "A" + i + "," + i + ",0,0," + +(u * h > c * p) + "," + (this._x1 = e + E * o) + "," + (this._y1 = t + E * l);
    }
  },
  arc: function(e, t, n, r, i, s) {
    e = +e, t = +t, n = +n, s = !!s;
    var a = n * Math.cos(r), o = n * Math.sin(r), l = e + a, c = t + o, u = 1 ^ s, d = s ? r - i : i - r;
    if (n < 0) throw new Error("negative radius: " + n);
    this._x1 === null ? this._ += "M" + l + "," + c : (Math.abs(this._x1 - l) > Zn || Math.abs(this._y1 - c) > Zn) && (this._ += "L" + l + "," + c), n && (d < 0 && (d = d % ac + ac), d > KD ? this._ += "A" + n + "," + n + ",0,1," + u + "," + (e - a) + "," + (t - o) + "A" + n + "," + n + ",0,1," + u + "," + (this._x1 = l) + "," + (this._y1 = c) : d > Zn && (this._ += "A" + n + "," + n + ",0," + +(d >= sc) + "," + u + "," + (this._x1 = e + n * Math.cos(i)) + "," + (this._y1 = t + n * Math.sin(i))));
  },
  rect: function(e, t, n, r) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +n + "v" + +r + "h" + -n + "Z";
  },
  toString: function() {
    return this._;
  }
};
function hp(e) {
  return function() {
    return e;
  };
}
function QD(e) {
  return e[0];
}
function JD(e) {
  return e[1];
}
var tk = Array.prototype.slice;
function ek(e) {
  return e.source;
}
function nk(e) {
  return e.target;
}
function rk(e) {
  var t = ek, n = nk, r = QD, i = JD, s = null;
  function a() {
    var o, l = tk.call(arguments), c = t.apply(this, l), u = n.apply(this, l);
    if (s || (s = o = Ev()), e(s, +r.apply(this, (l[0] = c, l)), +i.apply(this, l), +r.apply(this, (l[0] = u, l)), +i.apply(this, l)), o) return s = null, o + "" || null;
  }
  return a.source = function(o) {
    return arguments.length ? (t = o, a) : t;
  }, a.target = function(o) {
    return arguments.length ? (n = o, a) : n;
  }, a.x = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : hp(+o), a) : r;
  }, a.y = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : hp(+o), a) : i;
  }, a.context = function(o) {
    return arguments.length ? (s = o ?? null, a) : s;
  }, a;
}
function ik(e, t, n, r, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);
}
function sk() {
  return rk(ik);
}
function ak(e) {
  return [e.source.x1, e.y0];
}
function ok(e) {
  return [e.target.x0, e.y1];
}
function lk() {
  return sk().source(ak).target(ok);
}
class ck extends mt {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = rt.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ ariaLabel: "alluvial graphs", withinChartClip: !0 });
    n.html("");
    const { width: r, height: i } = N.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = y(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let l = Pe.minNodePadding;
    s.alluvial.nodePadding > Pe.minNodePadding && (l = s.alluvial.nodePadding);
    const c = y(s, "alluvial", "nodeAlignment");
    let u = _v;
    c === jt.LEFT ? u = jD : c === jt.RIGHT && (u = WD);
    const d = ZD().nodeId((b) => b.name).nodeWidth(Pe.nodeWidth).nodePadding(l).nodeAlign(u).extent([
      [2, 30],
      [r - 2, i]
    ]);
    this.graph = d({
      nodes: s.alluvial.nodes.map((b) => Object.assign({}, b)),
      links: a.map((b) => Object.assign({}, b))
    }), this.graph.nodes = this.graph.nodes.filter((b) => b.value !== 0);
    const h = {};
    this.graph.nodes.forEach((b) => {
      const _ = b.x0;
      b.category && (h[_] = b?.category);
    }), n.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(h)).join("g").attr("transform", (b) => `translate(${b}, 0)`).append("text").attr(
      "id",
      (b, _) => this.services.domUtils.generateElementIDString(`alluvial-category-${_}`)
    ).style("font-size", "14px").text((b) => h[b] ? h[b] : "").attr("y", 20).attr("x", (b, _) => {
      const E = this.services.domUtils.generateElementIDString(
        `alluvial-category-${_}`
      ), { width: x } = N.getSVGElementSize(I(`text#${E}`), {
        useBBox: !0
      });
      let S = 0;
      return b + S >= x && (S = -x + 4), S;
    });
    const p = n.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (p.exit().remove(), o) {
      const b = y(this.getOptions(), "color", "scale");
      b && p.enter().append("linearGradient").attr("id", (_) => `${this.gradient_id}-link-${_.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (_) => _.append("stop").attr("offset", "0%").attr("stop-color", (E) => b[E.source.name])
      ).call(
        (_) => _.append("stop").attr("offset", "100%").attr("stop-color", (E) => b[E.target.name])
      ), p.exit().remove();
    }
    p.enter().append("path").classed("link", !0).attr("d", lk()).attr(
      "id",
      (b) => this.services.domUtils.generateElementIDString(`alluvial-line-${b.index}`)
    ).attr("class", (b) => s.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [it.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [it.STROKE],
      dataGroupName: b.source.index,
      originalClassName: "link"
    })).style("stroke", (b) => o ? `url(#${this.gradient_id}-link-${b.index})` : this.model.getFillColor(b.source.name, null, {
      ...b,
      source: b.source.name,
      target: b.target.name
    })).attr("stroke-width", (b) => Math.max(1, b.width)).style("stroke-opacity", Pe.opacity.default).attr(
      "aria-label",
      (b) => `${b.source.name}  ${b.target.name} (${b.value}${s.alluvial.units ? " " + s.alluvial.units : ""})`
    );
    const f = n.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (b) => this.services.domUtils.generateElementIDString(`alluvial-node-${b.index}`)
    ).classed("node-group", !0).attr("transform", (b) => `translate(${b.x0}, ${b.y0})`);
    f.append("rect").classed("node", !0).attr("height", (b) => b.y1 - b.y0).attr("width", (b) => b.x1 - b.x0).attr("fill", "black");
    const g = f.append("g").attr(
      "id",
      (b) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${b.index}`)
    ), { code: m, number: v } = y(s, "locale");
    g.append("text").attr(
      "id",
      (b) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${b.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((b) => `${b.name} (${v(b.value, m)})`).attr("aria-label", (b) => `${b.name} (${b.value})`), g.append("rect").classed("node-text-bg", !0).attr("width", (b, _) => {
      const E = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${_}`
      ), { width: x } = N.getSVGElementSize(I(`text#${E}`), {
        useBBox: !0
      });
      return x + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), g.attr("transform", (b, _) => {
      const E = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${_}`
      ), { width: x } = N.getSVGElementSize(I(`text#${E}`), {
        useBBox: !0
      }), S = (b.y1 - b.y0) / 2 - 9;
      let $ = b.x1 - b.x0;
      return b.x1 >= x ? $ = $ - (x + 16) : $ += 4, `translate(${$}, ${S})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const t = this.getOptions(), n = this, { number: r, code: i } = y(this.getOptions(), "locale"), s = ba((a, o = "mouseover") => {
      const l = n.parent.selectAll("path.link").transition().call(
        (c) => n.services.transitions.setupTransition({
          transition: c,
          name: "alluvial-links-mouse-highlight"
        })
      );
      o === "mouseout" ? (I(a).lower(), l.style("stroke-opacity", Pe.opacity.default)) : l.style("stroke-opacity", function() {
        return a === this ? (I(this).raise(), Pe.opacity.selected) : Pe.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(a, o) {
      const l = I(this);
      s(this, "mouseover"), l.classed("link-hovered", !0);
      const c = getComputedStyle(this).getPropertyValue("stroke");
      n.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEOVER, {
        event: a,
        element: l,
        datum: o
      }), n.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: l,
        items: [
          {
            label: o.target.name,
            value: (r(o.value, i) ? `${r(o.value, i)}` : "-") + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),
            color: c,
            labelIcon: n.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(a, o) {
      n.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEMOVE, {
        event: a,
        element: I(this),
        datum: o
      }), n.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, o) {
      n.services.events.dispatchEvent(T.Alluvial.LINE_CLICK, {
        event: a,
        element: I(this),
        datum: o
      });
    }).on("mouseout", function(a, o) {
      const l = I(this);
      s(this, "mouseout"), l.classed("link-hovered", !1), n.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEOUT, {
        event: a,
        element: l,
        datum: o
      }), n.services.events.dispatchEvent(T.Tooltip.HIDE, {
        event: a,
        hoveredElement: l
      });
    });
  }
  addNodeEventListener() {
    const t = this, n = ba((r = [], i = "mouseover") => {
      if (i === "mouseout" || r.length === 0) {
        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (s) => s.index).order().style("stroke-opacity", Pe.opacity.default);
        return;
      }
      t.parent.selectAll("path.link").transition().call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(s) {
        return r.some((a) => a === s.index) ? (I(this).classed("link-hovered", !0).raise(), Pe.opacity.selected) : Pe.opacity.unfocus;
      });
    }, 66);
    t.parent.selectAll(".node-group").on("mouseover", function(r, i) {
      const s = I(this), a = [];
      if (t.traverse({ link: "sourceLinks", node: "target" }, i, a), t.traverse({ link: "targetLinks", node: "source" }, i, a), a.length) {
        const o = Ci(s.attr("transform"));
        if (s.attr("transform", `translate(${o.x - 2}, ${o.y})`), s.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), i.x0 - 2 === 0) {
          const c = t.services.domUtils.generateElementIDString(
            `alluvial-node-title-${i.index}`
          ), u = t.parent.select(`g#${c}`), d = Ci(u.attr("transform"));
          u.attr("transform", `translate(${d.x + 4},${d.y})`);
        }
        const l = t.services.domUtils.generateElementIDString(
          `alluvial-node-text-${i.index}`
        );
        t.parent.select(`text#${l}`).style("font-weight", "bold"), n(a, "mouseover"), t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEOVER, {
          event: r,
          element: s,
          datum: i
        });
      }
    }).on("mousemove", function(r, i) {
      t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEMOVE, {
        event: r,
        element: I(this),
        datum: i
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(T.Alluvial.NODE_CLICK, {
        event: r,
        element: I(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      const s = I(this), a = Ci(s.attr("transform"));
      if (s.classed("node-hovered", !1).attr("transform", `translate(${a.x + 2}, ${a.y})`).select("rect.node").attr("width", Pe.nodeWidth), i.x0 - 2 === 0) {
        const l = t.services.domUtils.generateElementIDString(
          `alluvial-node-title-${i.index}`
        ), c = t.parent.select(`g#${l}`), u = Ci(c.attr("transform"));
        c.attr("transform", `translate(${u.x - 4},${u.y})`);
      }
      const o = t.services.domUtils.generateElementIDString(
        `alluvial-node-text-${i.index}`
      );
      t.parent.select(`text#${o}`).style("font-weight", "normal"), n([], "mouseout"), t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEOUT, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(t, n, r = []) {
    n[t.link].map((i) => (r.push(i.index), i[t.node])).forEach((i) => this.traverse(t, i, r));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class Oe extends mt {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = rt.SVG;
  }
  render(t = !0) {
    const n = y(this.getOptions(), "grid", "x", "enabled"), r = y(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(n, r), !(!n && !r) && (n && (N.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), r && (N.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));
  }
  drawXGrid(t) {
    const n = this.parent, r = this.backdrop.attr("height"), i = this.services.cartesianScales.getMainXScale(), s = Qc(i).tickSizeInner(-r).tickSizeOuter(0);
    if (y(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const o = this.services.cartesianScales.getDomainAxisPosition(), l = y(this.getOptions(), "axes", o, "ticks", "values");
      l && s.tickValues(l);
    } else {
      const o = y(this.getOptions(), "grid", "x", "numberOfTicks");
      s.ticks(o);
    }
    const a = n.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${r})`);
    t ? a.transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "grid-update",
        animate: t
      })
    ).call(s) : a.call(s), this.cleanGrid(a);
  }
  drawYGrid(t) {
    const n = this.parent, r = this.backdrop.attr("width"), i = this.services.cartesianScales.getMainYScale(), s = Lg(i).tickSizeInner(-r).tickSizeOuter(0);
    if (y(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const o = this.services.cartesianScales.getRangeAxisPosition(), l = y(this.getOptions(), "axes", o, "ticks", "values");
      l && s.tickValues(l);
    } else {
      const o = y(this.getOptions(), "grid", "y", "numberOfTicks");
      s.ticks(o);
    }
    const a = n.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    t ? a.transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "grid-update",
        animate: t
      })
    ).call(s) : a.call(s), this.cleanGrid(a);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(t) {
    const n = this.parent, r = n.selectAll(".x.grid .tick").nodes().sort((u, d) => Number(fn(u).tx) - Number(fn(d).tx));
    let i = -1;
    if (!r.length)
      return;
    r.forEach((u) => {
      t[0] >= +fn(u).tx && i++;
    });
    const s = i + 1 < r.length ? i + 1 : r.length, a = r[i], o = r[s];
    let l;
    if (!a)
      l = +fn(o).tx;
    else if (o)
      l = +fn(o).tx - +fn(a).tx;
    else {
      const u = n.select("rect.chart-grid-backdrop").node();
      l = N.getSVGElementSize(u).width - +fn(a).tx;
    }
    const { threshold: c } = this.getOptions().tooltip.gridline;
    return l * c;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(t) {
    const n = y(this.getOptions, "tooltip", "gridline", "threshold"), r = n || this.getGridlineThreshold(t);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const i = fn(this), s = {
        min: Number(i.tx) - r,
        max: Number(i.tx) + r
      };
      return s.min <= t[0] && t[0] <= s.max;
    });
  }
  drawBackdrop(t, n) {
    const r = this.parent, i = this.services.cartesianScales.getMainXScale(), s = this.services.cartesianScales.getMainYScale(), [a, o] = i.range(), [l, c] = s.range();
    this.backdrop = N.appendOrSelect(r, "svg.chart-grid-backdrop").attr(
      "role",
      "presentation"
    );
    const u = N.appendOrSelect(
      this.backdrop,
      t || n ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(u).attr("x", a).attr("y", c).attr("width", Math.abs(o - a)).attr("height", Math.abs(l - c)).lower(), u.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(t) {
    t.selectAll("text").remove(), t.select(".domain").remove();
  }
}
class Ov extends mt {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = rt.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-area"
        })
      ).attr("opacity", (r) => r.name !== n.datum().name ? yn.opacity.unselected : yn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", yn.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ ariaLabel: "area graphs", withinChartClip: !0 }), r = this.getOptions();
    let i = [0, 0];
    const { cartesianScales: s } = this.services, a = s.getOrientation(), o = su().curve(this.services.curves.getD3Curve()).defined((x) => {
      const S = s.getRangeIdentifier();
      return x[S] != null;
    }), l = this.model.getGroupedData(this.configs.groups), c = y(r, "bounds"), u = c && l && l.length === 1;
    !u && c && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${l.length}`
    );
    let d = 0;
    const h = (x, S) => {
      y(r, "axes", x, "includeZero") === !1 && S[0] > 0 && S[1] > 0 && (d = S[0]);
    }, p = (x) => u ? s.getBoundedScaledValues(x)[0] : s.getRangeValue(d), f = (x) => u ? s.getBoundedScaledValues(x)[1] : s.getRangeValue(x);
    a === Ft.VERTICAL ? (i = s.getMainYScale().domain(), h(s.getMainYAxisPosition(), i), o.x((x) => s.getDomainValue(x)).y0((x) => p(x)).y1((x) => f(x))) : (i = s.getMainXScale().domain(), h(s.getMainXAxisPosition(), i), o.x0((x) => p(x)).x1((x) => f(x)).y((x) => s.getDomainValue(x)));
    const g = y(r, "color", "gradient", "enabled"), m = l && l.length === 1 && g;
    l.length > 1 && g && console.error("Gradients can only be enabled when having 1 single dataset");
    const v = n.selectAll("path.area").data(l, (x) => x.name), b = I(this.services.domUtils.getMainContainer());
    if (v.exit().attr("opacity", 0).remove(), !l.length)
      return;
    if (m) {
      const x = b.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [it.STROKE],
          dataGroupName: l[0].name
        })}`
      ).node();
      let S;
      if (x)
        S = getComputedStyle(x, null).getPropertyValue(
          "stroke"
        );
      else {
        const $ = y(this.model.getOptions(), "color", "scale");
        if ($ !== null) {
          const D = Object.keys($);
          S = $[D[0]];
        }
      }
      Il.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${l[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: Il.getStops(i, S)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const _ = this, E = v.enter().append("path");
    m ? E.merge(v).style(
      "fill",
      (x) => `url(#${this.services.domUtils.generateElementIDString(
        `${x.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: x.name,
        originalClassName: "area"
      })
    ).attr("d", (x) => {
      const { data: S } = x;
      return o(S);
    }) : (E.attr("opacity", 0).merge(v).attr("class", "area").attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [it.FILL, it.STROKE],
        dataGroupName: x.name,
        originalClassName: "area"
      })
    ).style("fill", (x) => _.model.getFillColor(x.name, null, x.data)).transition().call(
      (x) => this.services.transitions.setupTransition({
        transition: x,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", u ? 1 : yn.opacity.selected).attr("d", (x) => {
      const { data: S } = x;
      return o(S);
    }), u && E.attr("fill-opacity", yn.opacity.selected).style("stroke", (x) => _.model.getStrokeColor(x.name, null, x.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class jr extends mt {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-line"
        })
      ).attr("opacity", (r) => r.name !== n.datum().name ? vn.opacity.unselected : vn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", vn.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = navigator.userAgent.toLowerCase().indexOf("firefox") > -1, r = this.model.get("zoomDomain") !== void 0, i = n && r ? this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !1 }) : this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), { cartesianScales: s, curves: a } = this.services, o = (m) => s.getDomainValue(m), l = (m) => s.getRangeValue(m), [c, u] = En(
      o,
      l,
      s.getOrientation()
    ), d = this.getOptions(), h = bs().x(c).y(u).curve(a.getD3Curve()).defined((m) => {
      const v = s.getRangeIdentifier(m);
      return m[v] != null;
    });
    let p = [];
    if (this.configs.stacked) {
      const m = Object.keys(d.axes).some((b) => d.axes[b].percentage), { groupMapsTo: v } = d.data;
      p = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: m
      }).map((b) => {
        const _ = this.services.cartesianScales.getDomainIdentifier(b), E = this.services.cartesianScales.getRangeIdentifier(b);
        return {
          name: y(b, 0, v),
          data: b.map((x) => ({
            [_]: x.data.sharedStackKey,
            [v]: x[v],
            [E]: x[1]
          })),
          hidden: !IC(b, (x) => x[0] !== x[1])
        };
      });
    } else
      p = this.model.getGroupedData(this.configs.groups);
    const f = i.selectAll("path.line").data(p, (m) => m.name);
    f.exit().attr("opacity", 0).remove();
    const g = f.enter().append("path").classed("line", !0).attr("opacity", 0).merge(f).data(p, (m) => m.name).attr(
      "class",
      (m) => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        dataGroupName: m.name,
        originalClassName: "line"
      })
    ).style("stroke", (m) => this.model.getStrokeColor(m.name, null, m.data)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (m) => {
      const { data: v } = m;
      return v.map((b) => {
        const _ = this.services.cartesianScales.getRangeIdentifier(b);
        return b[_];
      }).join(",");
    });
    if (n && r) {
      const m = s.getMainXScale(), v = s.getMainYScale();
      if (m && v) {
        const [b, _] = m.range(), [E, x] = v.range();
        i.style("overflow", "hidden").style("clip", `rect(${x}px, ${_}px, ${E}px, ${b}px)`);
      }
    }
    g.transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "line-update-enter",
        animate: t
      })
    ).attr("opacity", (m) => m.hidden ? 0 : 1).attr("d", (m) => {
      const { data: v } = m;
      return h(v);
    });
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const dp = 5;
function uk(e, t) {
  return e > t - dp && e < t + dp;
}
class Vn extends mt {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = rt.SVG, this.isXGridEnabled = y(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = y(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = y(this.getOptions(), "ruler", "enabled"), r = y(this.getOptions(), "tooltip", "alwaysShowRulerTooltip"), i = n || r;
    this.drawBackdrop(), i && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !i && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(t) {
    return t;
  }
  showRuler(t, [n, r]) {
    const i = this.parent, s = this.services.cartesianScales.getOrientation(), a = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [l, c] = o.range(), u = s === Ft.HORIZONTAL ? r : n, d = N.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), h = N.appendOrSelect(d, "line.ruler-line"), p = i.selectAll("[role=graphics-symbol]"), f = a.map((m) => ({
      domainValue: this.services.cartesianScales.getDomainValue(m),
      originalData: m
    })).filter((m) => uk(m.domainValue, u));
    if (this.pointsWithinLine && f.length === this.pointsWithinLine.length && f.map((m) => m.domainValue).join() === this.pointsWithinLine.map((m) => m.domainValue).join())
      return this.pointsWithinLine = f, this.services.events.dispatchEvent(T.Tooltip.MOVE, {
        mousePosition: [n, r]
      });
    this.pointsWithinLine = f;
    const g = this.pointsWithinLine.reduce((m, v) => {
      if (m.length === 0)
        return m.push(v), m;
      const b = m[0].domainValue, _ = Math.abs(u - v.domainValue), E = Math.abs(u - b);
      return _ > E || (_ < E ? m = [v] : m.push(v)), m;
    }, []);
    if (g.length > 0) {
      const m = g.map((E) => E.originalData).filter((E) => {
        const x = this.services.cartesianScales.getRangeIdentifier(E);
        return E[x] != null;
      }), v = g.map(
        (E) => E.domainValue
      ), b = p.filter((E) => {
        const x = this.services.cartesianScales.getDomainValue(E);
        return v.includes(x);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Cg(this.elementsToHighlight, b) && this.hideRuler(), b.dispatch("mouseover"), this.elementsToHighlight = b, this.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: t,
        mousePosition: [n, r],
        hoveredElement: h,
        data: this.formatTooltipData(m)
      }), d.attr("opacity", 1);
      const _ = g[0];
      s === "horizontal" ? h.attr("x1", c).attr("x2", l).attr("y1", _.domainValue).attr("y2", _.domainValue) : h.attr("y1", c).attr("y2", l).attr("x1", _.domainValue).attr("x2", _.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const t = this.parent, n = N.appendOrSelect(t, "g.ruler");
    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(T.Tooltip.HIDE), n.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const t = this, n = this.services.domUtils.getHolder(), r = this.model.getDisplayData();
    let i = function(s) {
      const a = rr(s, t.parent.node());
      t.showRuler(s, a);
    };
    if (r.length > 100) {
      const s = r.length % 50 * 12.5;
      i = rw(
        function(a) {
          const { mousePosition: o } = this;
          t.showRuler(a, o);
        },
        s,
        n
      );
    }
    this.backdrop.on("mousemove mouseover", i).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const t = this.parent;
    this.backdrop = N.appendOrSelect(t, "svg.chart-grid-backdrop");
  }
}
let nn = class extends mt {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = rt.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (t) => this.services.transitions?.setupTransition({
          transition: t,
          name: "chart-holder-hover-scatter"
        })
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (t) => this.services.transitions?.setupTransition({
          transition: t,
          name: "chart-holder-mouseout-scatter"
        })
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (i) => this.services.transitions?.setupTransition({
          transition: i,
          name: "legend-hover-scatter"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (t) => this.services.transitions?.setupTransition({
          transition: t,
          name: "legend-mouseout-scatter"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    if (!t) throw new Error("Services events are undefined.");
    t.addEventListener(
      T.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: n } = this.configs;
    n && (t.addEventListener(T.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(T.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(t) {
    const { cartesianScales: n } = this.services;
    if (!n) throw new Error("Services cartesianScales are undefined.");
    const r = n.getDomainIdentifier(t), i = this.model.get("zoomDomain");
    return i !== void 0 ? t.filter(
      (s) => s[r].getTime() >= i[0].getTime() && s[r].getTime() <= i[1].getTime()
    ) : t;
  }
  getScatterData() {
    const t = this.getOptions(), { stacked: n } = this.configs;
    let r;
    if (n) {
      const i = Object.keys(t.axes).some((s) => t.axes[s].percentage);
      r = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: i
      });
    } else {
      const { cartesianScales: i } = this.services;
      if (!i) throw new Error("Services cartesianScales are undefined.");
      r = this.model.getDisplayData(this.configs.groups).filter((s) => {
        const a = i.getRangeIdentifier(s);
        return s[a] !== void 0 && s[a] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(r);
  }
  render(t) {
    if (!(y(this.getOptions(), "points", "enabled") || y(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.services.zoom?.isZoomBarEnabled() || !1, r = this.getComponentContainer({
      ariaLabel: "scatter points",
      withinChartClip: n
    }), i = this.getOptions(), { groupMapsTo: s } = i.data, { cartesianScales: a } = this.services;
    if (!a) throw new Error("Services cartesianScales are undefined.");
    const o = a.getDomainIdentifier(), l = r.selectAll("circle.dot").data(
      this.getScatterData(),
      (u) => `${u[s]}-${u[o]}`
    );
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l);
    this.styleCircles(c, t), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(t) {
    const { handleThresholds: n } = this.configs;
    if (!n)
      return !1;
    const { cartesianScales: r } = this.services;
    if (!r) throw new Error("Cartesian scales service is undefined");
    const i = r.getOrientation(), [s, a] = En(
      r.getHighestDomainThreshold(),
      r.getHighestRangeThreshold(),
      i
    ), [o, l] = En(
      (d) => r.getDomainValue(d),
      (d) => r.getRangeValue(d),
      i
    ), c = o(t), u = l(t);
    return a && s ? u <= a.scaleValue && c >= s.scaleValue : a ? u <= a.scaleValue : s ? c >= s.scaleValue : !1;
  }
  styleCircles(t, n) {
    const r = this.getOptions(), { filled: i, fillOpacity: s } = r.points, { cartesianScales: a } = this.services;
    if (!a) throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: o } = r.data, l = (p) => a.getDomainValue(p), c = (p) => a.getRangeValue(p), [u, d] = En(
      l,
      c,
      a.getOrientation()
    ), { fadeInOnChartHolderMouseover: h } = this.configs;
    t.raise().classed("dot", !0).attr("class", (p) => {
      const f = a.getDomainIdentifier(p), g = this.model.getIsFilled(p[o], p[f], p, i) ? [it.FILL, it.STROKE] : [it.STROKE];
      return this.model.getColorClassName({
        classNameTypes: g,
        dataGroupName: p[o],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (p) => this.isDatapointThresholdAnomaly(p)).classed("filled", (p) => {
      const f = a.getDomainIdentifier(p);
      return this.model.getIsFilled(p[o], p[f], p, i);
    }).classed("unfilled", (p) => {
      const f = a.getDomainIdentifier(p);
      return !this.model.getIsFilled(p[o], p[f], p, i);
    }).transition().call(
      (p) => this.services.transitions?.setupTransition({
        transition: p,
        name: "scatter-update-enter",
        animate: n
      })
    ).attr("cx", u).attr("cy", d).attr("r", r.points.radius).style("fill", (p) => {
      const f = a.getDomainIdentifier(p);
      if (this.model.getIsFilled(p[o], p[f], p, i))
        return this.model.getFillColor(p[o], p[f], p);
    }).style("stroke", (p) => {
      const f = a.getDomainIdentifier(p);
      return this.model.getStrokeColor(p[o], p[f], p);
    }).attr("fill-opacity", i ? s : 1).attr("opacity", h ? 0 : 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (p) => {
      const f = a.getRangeIdentifier(p);
      return p[f];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(t) {
    return null;
  }
  addEventListeners() {
    const t = this, { groupMapsTo: n } = t.getOptions().data, r = y(
      this.getOptions(),
      "tooltip",
      "alwaysShowRulerTooltip"
    );
    if (!this.parent) throw new Error("Parent not defined");
    const i = this.parent.selectAll("circle");
    r ? i.style("pointer-events", "none") : i.style("pointer-events", null), i.on("mouseover", function(s, a) {
      const o = I(this);
      o.classed("hovered", !0).attr(
        "class",
        (l) => t.model.getColorClassName({
          classNameTypes: [it.FILL],
          dataGroupName: l[n],
          originalClassName: o.attr("class")
        })
      ).style("fill", (l) => {
        const c = t.services.cartesianScales?.getDomainIdentifier(l);
        return t.model.getFillColor(l[n], l[c], l);
      }).classed("unfilled", !1), r || t.services.events?.dispatchEvent(T.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        data: [a],
        additionalItems: t.getTooltipAdditionalItems(a)
      }), t.services.events?.dispatchEvent(T.Scatter.SCATTER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const o = I(this);
      t.services.events?.dispatchEvent(T.Scatter.SCATTER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), t.services.events?.dispatchEvent(T.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events?.dispatchEvent(T.Scatter.SCATTER_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      if (o.classed("hovered", !1), !t.configs.filled) {
        const { filled: l } = t.getOptions().points, c = t.services.cartesianScales?.getDomainIdentifier(a), u = t.model.getIsFilled(
          a[n],
          a[c],
          a,
          l
        );
        o.classed("unfilled", !u).style("fill", (d) => u || l ? t.model.getFillColor(d[n], d[c], d) : null);
      }
      t.services.events?.dispatchEvent(T.Scatter.SCATTER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), t.services.events?.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
  destroy() {
    this.parent?.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: t } = this.services;
    if (!t) throw new Error("Services events undefined");
    t.removeEventListener(
      T.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(T.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.removeEventListener(T.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
};
class Sv extends mt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "axes", this.renderType = rt.SVG, this.truncation = {
      [G.LEFT]: !1,
      [G.RIGHT]: !1,
      [G.TOP]: !1,
      [G.BOTTOM]: !1
    }, r && (this.configs = r), this.margins = this.configs.margins;
  }
  render(t = !0) {
    const { position: n } = this.configs, r = this.getOptions(), i = y(r, "axes", n, "visible"), s = this.getComponentContainer({
      ariaLabel: "axes"
    }), { width: a, height: o } = N.getSVGElementSize(s, {
      useAttrs: !0
    }), l = N.appendOrSelect(s, `g.axis.${n}`);
    let c, u;
    if (n === G.BOTTOM || n === G.TOP ? (c = this.configs.axes[G.LEFT] ? this.margins.left : 0, u = this.configs.axes[G.RIGHT] ? a - this.margins.right : a) : (c = o - this.margins.bottom, u = this.margins.top), !this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const d = this.services.cartesianScales.getScaleByPosition(n);
    this.scaleType === et.LABELS || this.scaleType === et.LABELS_RATIO ? d.rangeRound([c, u]) : d.range([c, u]);
    let h;
    switch (n) {
      case G.LEFT:
        h = Lg;
        break;
      case G.BOTTOM:
        h = Qc;
        break;
      case G.RIGHT:
        h = FC;
        break;
      case G.TOP:
        h = zC;
        break;
    }
    l.attr("aria-label", `${n} axis`);
    const p = !l.select("g.ticks").empty();
    let f = N.appendOrSelect(l, "g.ticks");
    p || (f.attr("role", `${ht.GRAPHICS_OBJECT} ${ht.GROUP}`), f.attr("aria-label", `${n} ticks`));
    const g = N.appendOrSelect(l, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${n} ticks`), m = y(r, "axes", n), v = this.scaleType === et.TIME || m.scaleType === et.TIME, b = n === G.LEFT || n === G.RIGHT, _ = this.model.get("zoomDomain");
    if (_ && v && !b && d.domain(_), !i) {
      f.attr("aria-hidden", !0);
      return;
    }
    const E = y(m, "scaleType"), x = y(r, "data", "loading"), S = y(m, "ticks", "number"), $ = y(m, "ticks", "values"), D = y(m, "truncation", "type"), C = y(m, "truncation", "threshold"), R = y(m, "truncation", "numCharacter"), M = S !== null, H = y(r, "timeScale"), P = N.appendOrSelect(g, "g.tick"), B = N.appendOrSelect(P, "text").text("0"), O = N.getSVGElementSize(B.node(), {
      useBBox: !0
    }).height;
    P.remove();
    const w = this.scaleType || m.scaleType || et.LINEAR, L = h(d).tickSizeOuter(0);
    if (d.ticks) {
      let q;
      if (M ? q = S : (q = Pn.ticks.number, b && (q = this.getNumberOfFittingTicks(
        o,
        O,
        Pn.ticks.verticalSpaceRatio
      ))), d.ticks().length === 1 && d.ticks()[0] === 0 && (q = 0), L.ticks(q), v)
        if (!d.ticks(q).length)
          L.tickValues([]);
        else {
          const tt = y(r, "timeScale", "addSpaceOnEdges"), lt = y(r, "axes", n, "domain"), z = d.copy();
          tt && !lt && z.nice(q);
          const W = z.ticks(q);
          tt && W.length > 2 && !lt && (W.splice(W.length - 1, 1), W.splice(0, 1)), L.tickValues(W);
        }
    }
    let k;
    const U = y(m, "ticks", "formatter"), { code: Z, number: j } = y(r, "locale");
    if (v) {
      const q = Dl(
        L.tickValues(),
        y(r, "timeScale", "timeInterval")
      );
      U === null ? k = (tt, lt) => Ll(tt, lt, L.tickValues(), q, H, r.locale) : k = (tt, lt) => {
        const z = Ll(
          tt,
          lt,
          L.tickValues(),
          q,
          H,
          r.locale
        );
        return U(tt, lt, z);
      };
    } else
      U === null ? w === et.LINEAR && (k = (q) => j(q, Z)) : k = U;
    L.tickFormat(k);
    const [F, Y] = this.services.cartesianScales.getScaleByPosition(n).domain();
    let ot;
    if ($) {
      if (v)
        $.forEach((q, tt) => {
          q.getTime === void 0 && ($[tt] = new Date(q));
        }), ot = $.filter((q) => {
          const tt = q.getTime();
          return tt >= new Date(F).getTime() && tt <= new Date(Y).getTime();
        });
      else if (E === et.LABELS) {
        const q = this.services.cartesianScales.getScaleByPosition(n).domain();
        ot = $.filter((tt) => q.includes(tt));
      } else
        ot = $.filter(
          (q) => q >= F && q <= Y
        );
      L.tickValues(ot);
    }
    switch (n) {
      case G.LEFT:
        f.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case G.BOTTOM:
        f.attr("transform", `translate(0, ${o - this.margins.bottom})`);
        break;
      case G.RIGHT:
        f.attr("transform", `translate(${a - this.margins.right}, 0)`);
        break;
      case G.TOP:
        f.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const Q = this.model.isDataEmpty();
    if (m.title) {
      const q = N.appendOrSelect(l, "text.axis-title").html(
        Q || x ? "" : en(m.title)
      ), tt = y(m, "titleOrientation");
      let lt;
      switch (n) {
        case G.LEFT:
          tt === pl.RIGHT ? q.attr("transform", "rotate(90)").attr("y", 0).attr("x", d.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : q.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(d.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case G.BOTTOM:
          const z = o - Mm;
          q.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${z})`
          );
          break;
        case G.RIGHT:
          tt === pl.LEFT ? q.attr("transform", "rotate(-90)").attr("y", a).attr("x", -(d.range()[0] / 2)).style("text-anchor", "middle") : q.attr("transform", "rotate(90)").attr("y", -a).attr("x", d.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case G.TOP:
          lt = N.getSVGElementSize(q, {
            useBBox: !0
          }).height, q.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${lt / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (v) {
      const q = Dl(
        L.tickValues(),
        y(r, "timeScale", "timeInterval")
      ), tt = H.showDayName, lt = f;
      t && (f = f.transition().call(
        (z) => this.services.transitions.setupTransition({
          transition: z,
          name: "axis-update",
          animate: t
        })
      )), f = f.call(L), lt.selectAll(".tick").data(L.tickValues(), d).order().select("text").attr(
        "class",
        (z, W) => Gm(z, W, L.tickValues(), q, tt) ? "tick-label--primary" : "tick-label"
      );
    } else
      !t || !p ? f = f.call(L) : f = f.transition().call(
        (q) => this.services.transitions.setupTransition({
          transition: q,
          name: "axis-update",
          animate: t
        })
      ).call(L);
    if (g.call(L), n === G.BOTTOM || n === G.TOP) {
      let q = !1;
      const tt = y(m, "ticks", "rotation");
      if (tt === Ws.ALWAYS)
        q = !0;
      else if (tt === Ws.NEVER)
        q = !1;
      else if (!tt || tt === Ws.AUTO)
        if (d.step)
          q = g.selectAll("g.tick text").nodes().some(
            (lt) => N.getSVGElementSize(lt, {
              useBBox: !0
            }).width >= d.step()
          );
        else {
          q = !1;
          const lt = g.append("text").text("A"), z = N.getSVGElementSize(lt.node(), {
            useBBox: !0
          }).width;
          let W;
          g.selectAll("g.tick").each(function() {
            const X = I(this), V = parseFloat(y(fn(this), "tx"));
            V !== null && W + X.text().length * z * 0.8 >= V && (q = !0), W = V;
          }), lt.remove();
        }
      q ? (M || (L.ticks(
        this.getNumberOfFittingTicks(a, O, Pn.ticks.horizontalSpaceRatio)
      ), g.call(L), f.call(L)), l.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", n === G.TOP ? "start" : "end")) : l.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (x ? l.attr("opacity", 0) : l.attr("opacity", 1), f.selectAll("g.tick").attr("aria-label", (q) => q), g.selectAll("g.tick").attr("aria-label", (q) => q), D !== Ve.NONE && E === et.LABELS && !$) {
      const q = this.services.cartesianScales.getScaleDomain(n);
      if (q.length > 0) {
        const tt = s.select(`g.axis.${n} g.ticks g.tick`).html();
        l.selectAll("g.ticks g.tick").html(tt);
        const lt = this;
        l.selectAll("g.tick text").data(q).text(function(z) {
          return z.length > C ? (lt.truncation[n] = !0, rs(z, D, R)) : z;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(q).text(function(z) {
          return z.length > C ? rs(z, D, R) : z;
        }), l.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), l.selectAll("g.tick text").data(q);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: n } = this.configs, r = N.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = y(i, "axes", n), a = y(s, "scaleType"), o = y(s, "truncation", "threshold"), l = this;
    r.selectAll("g.tick text").on("mouseover", function(c, u) {
      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: I(this),
        datum: u
      }), a === et.LABELS && u.length > o && l.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: c,
        hoveredElement: I(this),
        content: u
      });
    }).on("mousemove", function(c, u) {
      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: I(this),
        datum: u
      }), a === et.LABELS && u.length > o && l.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, u) {
      l.services.events.dispatchEvent(T.Axis.LABEL_CLICK, {
        event: c,
        element: I(this),
        datum: u
      });
    }).on("mouseout", function(c, u) {
      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: I(this),
        datum: u
      }), a === et.LABELS && l.services.events.dispatchEvent(T.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);
  }
  getNumberOfFittingTicks(t, n, r) {
    const i = Math.floor(t / (n * r));
    return Mg(i, 2, Pn.ticks.number);
  }
  destroy() {
    const t = this.getComponentContainer(), { position: n } = this.configs;
    N.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class hk extends Sv {
  constructor(t, n, r) {
    super(t, n, r);
  }
  render(t = !0) {
    super.render(t), super.destroy();
    const n = this.configs.position, r = this.getComponentContainer({
      ariaLabel: "axes"
    }), i = N.appendOrSelect(r, `g.axis.${n}`), s = this;
    i.selectAll("g.tick").each(function(a, o) {
      const l = I(this);
      l.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);
      const c = l.select("text"), { width: u, height: d } = N.getSVGElementSize(c, {
        useBBox: !0
      }), h = N.appendOrSelect(l, "rect.axis-holder");
      let p = 0, f = 0;
      switch (n) {
        case G.LEFT:
          p = -u + Number(c.attr("x")), f = -(d / 2);
          break;
        case G.RIGHT:
          p = Math.abs(Number(c.attr("x"))), f = -(d / 2);
          break;
        case G.TOP:
          p = -(u / 2), f = -d + Number(c.attr("y")) / 2, s.truncation[n] && (p = 0, h.attr("transform", "rotate(-45)"));
          break;
        case G.BOTTOM:
          p = -(u / 2), f = d / 2 - 2, s.truncation[n] && (p = -u, h.attr("transform", "rotate(-45)"));
          break;
      }
      h.attr("x", p - Pn.hover.rectanglePadding).attr("y", f).attr("width", u + Pn.hover.rectanglePadding * 2).attr("height", d).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: n } = this.configs, r = N.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = y(i, "axes", n), a = y(s, "scaleType"), o = y(s, "truncation", "threshold"), l = this;
    r.selectAll("g.tick.tick-hover").on("mouseover", function(c) {
      const u = I(this).select("text"), d = u.datum();
      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: u,
        datum: d
      }), a === et.LABELS && d.length > o && l.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: c,
        element: u,
        datum: d
      });
    }).on("mousemove", function(c) {
      const u = I(this).select("text"), d = u.datum();
      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: u,
        datum: d
      }), l.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c) {
      l.services.events.dispatchEvent(T.Axis.LABEL_CLICK, {
        event: c,
        element: I(this).select("text"),
        datum: I(this).select("text").datum()
      });
    }).on("mouseout", function(c) {
      l.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: I(this).select("text"),
        datum: I(this).select("text").datum()
      }), a === et.LABELS && l.services.events.dispatchEvent(T.Tooltip.HIDE);
    }).on("focus", function(c) {
      const u = { clientX: 0, clientY: 0 };
      if (c.target) {
        c.target.focus();
        const d = c.target.getBoundingClientRect();
        u.clientX = d.x, u.clientY = d.y;
      }
      l.services.events.dispatchEvent(T.Axis.LABEL_FOCUS, {
        event: { ...c, ...u },
        element: I(this),
        datum: I(this).select("text").datum()
      });
    }).on("blur", function(c) {
      l.services.events.dispatchEvent(T.Axis.LABEL_BLUR, {
        event: c,
        element: I(this),
        datum: I(this).select("text").datum()
      });
    }).on("keydown", function(c) {
      c.key && c.key === "Escape" && (l.services.events.dispatchEvent(T.Tooltip.HIDE), l.services.events.dispatchEvent(T.Axis.LABEL_BLUR, {
        event: c,
        element: I(this),
        datum: I(this).select("text").datum()
      })), n === G.LEFT || n === G.RIGHT ? c.key && c.key === "ArrowUp" ? l.goNext(this, c) : c.key && c.key === "ArrowDown" && l.goPrevious(this, c) : c.key && c.key === "ArrowLeft" ? l.goPrevious(this, c) : c.key && c.key === "ArrowRight" && l.goNext(this, c);
    });
  }
  // Focus on the next HTML element sibling
  goNext(t, n) {
    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(t, n) {
    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();
  }
  destroy() {
    const t = this.getComponentContainer(), { position: n } = this.configs;
    N.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class fe extends mt {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = rt.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(t = !1) {
    const n = {}, r = Object.keys(G), i = y(this.getOptions(), "axes");
    r.forEach((a) => {
      i[G[a]] && (n[G[a]] = !0);
    }), this.configs.axes = n, r.forEach((a) => {
      const o = G[a];
      if (this.configs.axes[o] && !this.children[o]) {
        const l = {
          position: o,
          axes: this.configs.axes,
          margins: this.margins
        }, c = this.model.axisFlavor === Ga.DEFAULT ? new Sv(this.model, this.services, l) : new hk(this.model, this.services, l);
        c.setModel(this.model), c.setServices(this.services), c.setParent(this.parent), this.children[o] = c;
      }
    }), Object.keys(this.children).forEach((a) => {
      this.children[a].render(t);
    });
    const s = {};
    Object.keys(this.children).forEach((a) => {
      const o = this.children[a], l = o.configs.position, c = o.getInvisibleAxisRef(), { width: u, height: d } = N.getSVGElementSize(
        c,
        { useBBox: !0 }
      );
      let h = 0;
      if (!o.getTitleRef().empty()) {
        const g = N.getSVGElementSize(o.getTitleRef(), {
          useBBox: !0
        }).height;
        l === G.LEFT || l === G.RIGHT ? h = g + 5 : l === G.BOTTOM ? h = g + Mm : h = g;
      }
      const p = u, f = d;
      switch (l) {
        case G.TOP:
          s.top = f + h;
          break;
        case G.BOTTOM:
          s.bottom = f + h;
          break;
        case G.LEFT:
          s.left = p + h;
          break;
        case G.RIGHT:
          s.right = p + h;
          break;
      }
    }), this.services.events.dispatchEvent(T.Axis.RENDER_COMPLETE), Object.keys(s).some(
      (a) => this.margins[a] !== s[a]
    ) && (this.margins = Object.assign(this.margins, s), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(T.ZoomBar.UPDATE), Object.keys(this.children).forEach((a) => {
      const o = this.children[a];
      o.margins = this.margins;
    }), this.render(!0));
  }
}
class ce extends mt {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = y(this.getOptions(), "data", "loading");
    n ? this.renderSkeleton(n) : this.removeSkeleton();
  }
  renderSkeleton(t) {
    if (this.configs.skeleton === zt.GRID)
      this.renderGridSkeleton(t);
    else if (this.configs.skeleton === zt.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(t);
    else if (this.configs.skeleton === zt.PIE)
      this.renderPieSkeleton(t);
    else if (this.configs.skeleton === zt.DONUT)
      this.renderDonutSkeleton(t);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(t) {
    const n = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(t), n === Ft.VERTICAL && this.drawYGrid(t), n === Ft.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(t) {
    const n = this.computeOuterRadius();
    this.drawRing(n, 0, t), t && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(t) {
    const n = this.computeOuterRadius(), r = this.computeInnerRadius();
    this.drawRing(n, r, t), t && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const t = this.services.cartesianScales.getMainXScale().range(), n = this.services.cartesianScales.getMainYScale().range();
    this.xScale = Fe().domain([0, 1]).range(t), this.yScale = Fe().domain([0, 1]).range(n);
  }
  drawBackdrop(t) {
    const n = this.parent, { width: r, height: i } = N.getSVGElementSize(n, {
      useAttrs: !0
    });
    this.backdrop = N.appendOrSelect(n, "svg.chart-skeleton.DAII").attr("role", "presentation").attr("width", r).attr("height", i);
    const s = N.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    s.attr("width", "100%").attr("height", "100%");
    const [a] = this.xScale.range(), [, o] = this.yScale.range();
    this.backdrop.merge(s).attr("x", a).attr("y", o), s.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(t) {
    const n = +this.backdrop.attr("width"), r = y(this.getOptions(), "grid", "x", "numberOfTicks"), i = this.xScale.ticks(r).map((o) => o * n), s = N.appendOrSelect(this.backdrop, "g.x.skeleton"), a = s.selectAll("line").data(i);
    a.enter().append("line").merge(a).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), s.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(t) {
    const n = +this.backdrop.attr("height"), r = this.backdrop.attr("width"), i = y(this.getOptions(), "grid", "y", "numberOfTicks"), s = this.xScale.ticks(i).map((l) => l * n), a = N.appendOrSelect(this.backdrop, "g.y.skeleton"), o = a.selectAll("line").data(s);
    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", r).attr("y1", (l) => l).attr("y2", (l) => l), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(t, n, r = !0) {
    const i = this.parent, { width: s, height: a } = N.getSVGElementSize(i, {
      useAttrs: !0
    }), o = N.appendOrSelect(i, "svg.chart-skeleton").attr("width", s).attr("height", a).attr("role", "presentation"), l = n === 0 ? "pie" : "donut", c = y(this.getOptions(), l, "alignment");
    N.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", s).attr("height", a).attr("fill", "none");
    const u = ls().innerRadius(n).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), d = t + Math.abs(Mt.radiusOffset), h = t + (Math.min(s, a) - t * 2) / 2, p = N.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${d}, ${h})`).attr("d", u).classed("shimmer-effect-areas", r).classed("empty-state-areas", !r).style(
      "fill",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let f = t + Mt.xOffset;
    c === jt.CENTER ? f = s / 2 : c === jt.RIGHT && (f = s - t - Mt.xOffset);
    const g = t + Mt.yOffset;
    p.attr("transform", `translate(${f}, ${g})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: t, height: n } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(t, n) / 2 + Mt.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(t) {
    const n = "stop-bg-shimmer", r = "stop-shimmer", i = this.parent.select(".chart-skeleton"), { width: s } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), a = 0, o = s, l = N.appendOrSelect(i, "defs").lower(), c = N.appendOrSelect(l, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", a - 3 * 0.2 * s).attr("x2", o).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), u = `
			<stop class="${n}" offset="${a}"></stop>
			<stop class="${r}" offset="${a + 0.2}"></stop>
			<stop class="${n}" offset="${a + 2 * 0.2}"></stop>
		`;
    c.html(u), d();
    function d() {
      c.attr("gradientTransform", `translate(${a - 3 * 0.2 * s}, 0)`).transition().duration(2e3).delay(1e3).ease(YC).attr("gradientTransform", `translate(${o + 3 * 0.2 * s}, 0)`).on("end", d);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class dk extends mt {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = rt.SVG;
  }
  render(t) {
    const n = this.getComponentContainer({ ariaLabel: "box plots", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getDataGroupNames(), a = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [l, c] = a.range(), [u, d] = o.range(), h = c - l, p = u - d;
    if (h === 0)
      return;
    const { cartesianScales: f } = this.services, g = f.getOrientation(), m = g === Ft.VERTICAL, [v, b] = En(
      (M) => this.services.cartesianScales.getDomainValue(M),
      (M) => this.services.cartesianScales.getRangeValue(M),
      g
    ), _ = Math.floor((m ? h : p) / s.length), E = Math.min(_ / 2, 16), x = this.model.getBoxplotData(), S = n.selectAll(".box-group").data(x);
    S.exit().remove();
    const $ = S.enter().append("g").attr("class", "box-group"), D = S.merge($);
    $.append("path").merge(S.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", Te.strokeWidth.default).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-verticalstartline",
        animate: t
      })
    ).attr("d", (M) => {
      const H = f.getDomainValue(M[i]), P = H, B = f.getRangeValue(M.whiskers.min), O = f.getRangeValue(M.quartiles.q_25);
      return ae({ x0: H, x1: P, y0: B, y1: O }, g);
    }), $.append("path").merge(S.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", Te.strokeWidth.default).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-verticalendline",
        animate: t
      })
    ).attr("d", (M) => {
      const H = f.getDomainValue(M[i]), P = H, B = f.getRangeValue(M.whiskers.max), O = f.getRangeValue(M.quartiles.q_75);
      return ae({ x0: H, x1: P, y0: B, y1: O }, g);
    }), $.append("path").merge(S.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.FILL, it.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", Te.box.opacity.default).attr("stroke-width", Te.strokeWidth.default).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (M) => M[i]).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-quartiles",
        animate: t
      })
    ).attr("d", (M) => {
      const H = f.getDomainValue(M[i]) - E / 2, P = H + E, B = f.getRangeValue(
        Math[m ? "max" : "min"](M.quartiles.q_75, M.quartiles.q_25)
      ), O = B + Math.abs(
        f.getRangeValue(M.quartiles.q_75) - f.getRangeValue(M.quartiles.q_25)
      );
      return ae({ x0: H, x1: P, y0: B, y1: O }, g);
    }), $.append("path").merge(S.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (M) => {
      const H = f.getDomainValue(M[i]) - E / 2, P = H + E, B = f.getRangeValue(M.whiskers.min), O = f.getRangeValue(M.whiskers.max);
      return ae({ x0: H, x1: P, y0: B, y1: O }, g);
    }), $.append("path").merge(S.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", Te.strokeWidth.thicker).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-startingwhisker",
        animate: t
      })
    ).attr("d", (M) => {
      const H = f.getDomainValue(M[i]) - E / 4, P = H + E / 2, B = f.getRangeValue(M.whiskers.min), O = f.getRangeValue(M.whiskers.min);
      return ae({ x0: H, x1: P, y0: B, y1: O }, g);
    }), $.append("path").merge(S.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-median",
        animate: t
      })
    ).attr("d", (M) => {
      const H = f.getDomainValue(M[i]) - E / 2, P = H + E, B = f.getRangeValue(M.quartiles.q_50);
      return ae({ x0: H, x1: P, y0: B, y1: B }, g);
    }), $.append("path").merge(S.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", Te.strokeWidth.thicker).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-endingwhisker",
        animate: t
      })
    ).attr("d", (M) => {
      const H = f.getDomainValue(M[i]) - E / 4, P = H + E / 2, B = f.getRangeValue(M.whiskers.max), O = f.getRangeValue(M.whiskers.max);
      return ae({ x0: H, x1: P, y0: B, y1: O }, g);
    });
    const C = D.selectAll("circle.outlier").data(
      (M) => M.outliers.map((H) => ({
        min: M.whiskers.min,
        max: M.whiskers.max,
        [i]: M[i],
        value: H
      }))
    );
    C.exit().remove();
    const R = C.enter().append("circle");
    C.merge(R).attr("r", Te.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [it.FILL, it.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", Te.circle.opacity.default).attr("cx", v).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-circles",
        animate: t
      })
    ).attr("cy", b), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(i, s) {
      const a = I(this);
      I(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", Te.box.opacity.hovered), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        items: [
          {
            label: y(n, "locale", "translations", "group") || y(n, "tooltip", "groupLabel") || "Group",
            value: s[r],
            class: t.model.getColorClassName({
              classNameTypes: [it.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: s.whiskers.min
          },
          {
            label: "Q1",
            value: s.quartiles.q_25
          },
          {
            label: "Median",
            value: s.quartiles.q_50
          },
          {
            label: "Q3",
            value: s.quartiles.q_75
          },
          {
            label: "Maximum",
            value: s.whiskers.max
          },
          {
            label: "IQR",
            value: s.quartiles.q_75 - s.quartiles.q_25
          }
        ]
      }), t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      });
    }).on("mousemove", function(i, s) {
      const a = I(this);
      t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEMOVE, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      t.services.events.dispatchEvent(T.Boxplot.BOX_CLICK, {
        event: i,
        element: I(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = I(this);
      I(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", Te.box.opacity.default), t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  addCircleEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(s, a) {
      const o = I(this);
      o.classed("hovered", !0).attr("fill-opacity", Te.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: y(n, "locale", "translations", "group") || y(n, "tooltip", "groupLabel") || "Group",
            value: a[r],
            class: t.model.getColorClassName({
              classNameTypes: [it.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: a[i]
          }
        ]
      }), t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const o = I(this);
      t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(T.Boxplot.OUTLIER_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      o.classed("hovered", !1).attr("fill-opacity", Te.circle.opacity.default), t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class oi extends mt {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = rt.SVG;
  }
  render(t) {
    const n = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), r = this.services.cartesianScales.getScaleByPosition(n), [i, s] = r.domain(), a = i > 0 && s < 0 || i < 0 && s > 0, o = this.getComponentContainer({
      isPresentational: !0
    });
    if (!a) {
      o.selectAll("line.domain").remove();
      return;
    }
    const [l, c] = this.services.cartesianScales.getDomainScale().range();
    let u = +r(0) + 0.5;
    u || (u = r.range()[0]);
    const d = Pm(
      {
        x0: l,
        x1: c,
        y0: u,
        y1: u
      },
      this.services.cartesianScales.getOrientation()
    );
    N.appendOrSelect(o, "line.domain").transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "zero-line-update",
        animate: t
      })
    ).attr("y1", d.y0).attr("y2", d.y1).attr("x1", d.x0).attr("x2", d.x1);
  }
}
class pk extends nn {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = rt.SVG;
  }
  getRadiusScale(t) {
    const n = this.getOptions(), { radiusMapsTo: r } = n.bubble, i = t.data(), s = i.map((c) => c[r]).filter((c) => c), a = N.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = s.length > 0, l = o ? ze(s) : [1, 1];
    return Fe().domain(l).range(o ? n.bubble.radiusRange(a, i) : [4, 4]);
  }
  styleCircles(t, n) {
    const r = this.getOptions(), { radiusMapsTo: i } = r.bubble, s = this.getRadiusScale(t), { groupMapsTo: a } = r.data, { cartesianScales: o } = this.services, l = (h) => o.getDomainValue(h), c = (h) => o.getRangeValue(h), [u, d] = En(
      l,
      c,
      o.getOrientation()
    );
    t.raise().classed("dot", !0).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (h) => {
      const p = o.getRangeIdentifier(h);
      return h[p];
    }).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bubble-update-enter",
        animate: n
      })
    ).attr("cx", u).attr("cy", d).attr("r", (h) => s(h[i] || 1)).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [it.FILL, it.STROKE],
        dataGroupName: h[a],
        originalClassName: "dot"
      })
    ).style("fill", (h) => {
      const p = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getFillColor(h[a], h[p], h);
    }).style("stroke", (h) => {
      const p = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getStrokeColor(h[a], h[p], h);
    }).attr("fill-opacity", r.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(t) {
    const n = y(this.getOptions(), "bubble");
    return [
      {
        label: y(n, "radiusLabel"),
        value: t[y(n, "radiusMapsTo")]
      }
    ];
  }
}
class fk extends mt {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({ ariaLabel: "bullet graphs", withinChartClip: !0 }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [l, c] = a.range(), [, u] = a.domain(), d = () => {
      const g = [];
      s.forEach((v) => {
        v.ranges ? v.ranges.forEach((b, _) => {
          b != null && b < u && g.push({
            datum: v,
            value: b,
            order: _ + 1
          });
        }) : g.push({
          datum: v,
          order: 1
        });
      });
      const m = N.appendOrSelect(i, "g.range-boxes").selectAll("path.range-box").data(g, (v) => `${v[r]}-${v.order}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (v) => `range-box order-${v.order}`).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-range-box-update-enter",
          animate: t
        })
      ).attr("d", (v) => {
        let b, _, E, x;
        return v.order === 1 ? (b = this.services.cartesianScales.getDomainValue(v.datum) - 16 / 2, _ = b + 16, E = c - 2, x = l + 1) : (b = this.services.cartesianScales.getDomainValue(v.datum) - 16 / 2, _ = b + 16, E = this.services.cartesianScales.getRangeValue(v.value), x = c), ae(
          { x0: b, x1: _, y0: E, y1: x },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, h = () => {
      const g = N.appendOrSelect(i, "g.bars").selectAll("path.bar").data(s, (m) => m[r]);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("bar", !0).transition().call(
        (m) => this.services.transitions.setupTransition({
          transition: m,
          name: "bullet-bar-update-enter",
          animate: t
        })
      ).attr(
        "class",
        (m) => this.model.getColorClassName({
          classNameTypes: [it.FILL],
          dataGroupName: m[r],
          originalClassName: "bar"
        })
      ).style("fill", (m) => {
        const v = this.services.cartesianScales.getDomainIdentifier(m);
        return this.model.getFillColor(m[r], m[v], m);
      }).attr("d", (m) => {
        const v = this.services.cartesianScales.getDomainValue(m) - 4, b = v + 8, _ = this.services.cartesianScales.getRangeValue(0) + 1, E = this.services.cartesianScales.getRangeValue(m);
        return ae(
          { x0: v, x1: b, y0: _, y1: E },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (m) => m.value);
    }, p = () => {
      const g = N.appendOrSelect(i, "g.markers").selectAll("path.marker").data(
        s.filter((m) => y(m, "marker") !== null),
        (m) => m[r]
      );
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("marker", !0).transition().call(
        (m) => this.services.transitions.setupTransition({
          transition: m,
          name: "bullet-marker-update-enter",
          animate: t
        })
      ).attr("d", (m) => {
        const v = this.services.cartesianScales.getDomainValue(m) - 12, b = v + 24, _ = this.services.cartesianScales.getRangeValue(m.marker);
        return ae(
          { x0: v, x1: b, y0: _, y1: _ },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, f = () => {
      let g = [];
      s.filter((v) => y(v, "marker") !== null).forEach((v) => {
        const b = v.marker, _ = v[o];
        g = g.concat([
          { datum: v, value: b * 0.25, barValue: _ },
          { datum: v, value: b * 0.5, barValue: _ },
          { datum: v, value: b * 0.75, barValue: _ }
        ]);
      });
      const m = N.appendOrSelect(i, "g.quartiles").selectAll("path.quartile").data(g, (v) => v[r]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (v) => `quartile ${v.value <= v.barValue ? "over-bar" : ""}`).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-quartile-update-enter",
          animate: t
        })
      ).attr("d", ({ datum: v, value: b }) => {
        let _ = 4;
        v.ranges && v.ranges.indexOf(b) !== -1 && (_ = 8);
        const E = this.services.cartesianScales.getDomainValue(v) - _ / 2, x = E + _, S = this.services.cartesianScales.getRangeValue(b);
        return ae(
          { x0: E, x1: x, y0: S, y1: S },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    d(), h(), p(), f(), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), { code: s, number: a } = y(n, "locale");
    this.parent.selectAll("path.bar").on("mouseover", function(o, l) {
      const c = I(this);
      c.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: o,
        element: c,
        datum: l
      });
      const u = y(n, "bullet", "performanceAreaTitles"), d = t.model.getMatchingRangeIndexForDatapoint(l);
      t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: o,
        hoveredElement: c,
        items: [
          {
            label: y(n, "locale", "translations", "group") || y(n, "tooltip", "groupLabel") || "Group",
            value: l[r],
            class: t.model.getColorClassName({
              classNameTypes: [it.TOOLTIP],
              dataGroupName: l[r]
            })
          },
          {
            label: "Value",
            value: l[i]
          },
          {
            label: "Target",
            value: l.marker
          },
          {
            label: "Percentage",
            value: `${a(Math.floor(l[i] / l.marker * 100), s)}%`
          },
          {
            label: "Performance",
            value: u[d]
          }
        ]
      });
    }).on("mousemove", function(o, l) {
      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: o,
        element: I(this),
        datum: l
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: o
      });
    }).on("click", function(o, l) {
      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: o,
        element: I(this),
        datum: l
      });
    }).on("mouseout", function(o, l) {
      const c = I(this);
      c.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: o,
        element: c,
        datum: l
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: c
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function mk(e) {
  return e;
}
function gk(e) {
  if (e == null) return mk;
  var t, n, r = e.scale[0], i = e.scale[1], s = e.translate[0], a = e.translate[1];
  return function(o, l) {
    l || (t = n = 0);
    var c = 2, u = o.length, d = new Array(u);
    for (d[0] = (t += o[0]) * r + s, d[1] = (n += o[1]) * i + a; c < u; ) d[c] = o[c], ++c;
    return d;
  };
}
function vk(e, t) {
  for (var n, r = e.length, i = r - t; i < --r; ) n = e[i], e[i++] = e[r], e[r] = n;
}
function yk(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return pp(e, n);
  }) } : pp(e, t);
}
function pp(e, t) {
  var n = t.id, r = t.bbox, i = t.properties == null ? {} : t.properties, s = cu(e, t);
  return n == null && r == null ? { type: "Feature", properties: i, geometry: s } : r == null ? { type: "Feature", id: n, properties: i, geometry: s } : { type: "Feature", id: n, bbox: r, properties: i, geometry: s };
}
function cu(e, t) {
  var n = gk(e.transform), r = e.arcs;
  function i(u, d) {
    d.length && d.pop();
    for (var h = r[u < 0 ? ~u : u], p = 0, f = h.length; p < f; ++p)
      d.push(n(h[p], p));
    u < 0 && vk(d, f);
  }
  function s(u) {
    return n(u);
  }
  function a(u) {
    for (var d = [], h = 0, p = u.length; h < p; ++h) i(u[h], d);
    return d.length < 2 && d.push(d[0]), d;
  }
  function o(u) {
    for (var d = a(u); d.length < 4; ) d.push(d[0]);
    return d;
  }
  function l(u) {
    return u.map(o);
  }
  function c(u) {
    var d = u.type, h;
    switch (d) {
      case "GeometryCollection":
        return { type: d, geometries: u.geometries.map(c) };
      case "Point":
        h = s(u.coordinates);
        break;
      case "MultiPoint":
        h = u.coordinates.map(s);
        break;
      case "LineString":
        h = a(u.arcs);
        break;
      case "MultiLineString":
        h = u.arcs.map(a);
        break;
      case "Polygon":
        h = l(u.arcs);
        break;
      case "MultiPolygon":
        h = u.arcs.map(l);
        break;
      default:
        return null;
    }
    return { type: d, coordinates: h };
  }
  return c(t);
}
function xk(e, t) {
  var n = {}, r = {}, i = {}, s = [], a = -1;
  t.forEach(function(c, u) {
    var d = e.arcs[c < 0 ? ~c : c], h;
    d.length < 3 && !d[1][0] && !d[1][1] && (h = t[++a], t[a] = c, t[u] = h);
  }), t.forEach(function(c) {
    var u = o(c), d = u[0], h = u[1], p, f;
    if (p = i[d])
      if (delete i[p.end], p.push(c), p.end = h, f = r[h]) {
        delete r[f.start];
        var g = f === p ? p : p.concat(f);
        r[g.start = p.start] = i[g.end = f.end] = g;
      } else
        r[p.start] = i[p.end] = p;
    else if (p = r[h])
      if (delete r[p.start], p.unshift(c), p.start = d, f = i[d]) {
        delete i[f.end];
        var m = f === p ? p : f.concat(p);
        r[m.start = f.start] = i[m.end = p.end] = m;
      } else
        r[p.start] = i[p.end] = p;
    else
      p = [c], r[p.start = d] = i[p.end = h] = p;
  });
  function o(c) {
    var u = e.arcs[c < 0 ? ~c : c], d = u[0], h;
    return e.transform ? (h = [0, 0], u.forEach(function(p) {
      h[0] += p[0], h[1] += p[1];
    })) : h = u[u.length - 1], c < 0 ? [h, d] : [d, h];
  }
  function l(c, u) {
    for (var d in c) {
      var h = c[d];
      delete u[h.start], delete h.start, delete h.end, h.forEach(function(p) {
        n[p < 0 ? ~p : p] = 1;
      }), s.push(h);
    }
  }
  return l(i, r), l(r, i), t.forEach(function(c) {
    n[c < 0 ? ~c : c] || s.push([c]);
  }), s;
}
function bk(e) {
  for (var t = -1, n = e.length, r, i = e[n - 1], s = 0; ++t < n; ) r = i, i = e[t], s += r[0] * i[1] - r[1] * i[0];
  return Math.abs(s);
}
function _k(e) {
  return cu(e, Ek.apply(this, arguments));
}
function Ek(e, t) {
  var n = {}, r = [], i = [];
  t.forEach(s);
  function s(l) {
    switch (l.type) {
      case "GeometryCollection":
        l.geometries.forEach(s);
        break;
      case "Polygon":
        a(l.arcs);
        break;
      case "MultiPolygon":
        l.arcs.forEach(a);
        break;
    }
  }
  function a(l) {
    l.forEach(function(c) {
      c.forEach(function(u) {
        (n[u = u < 0 ? ~u : u] || (n[u] = [])).push(l);
      });
    }), r.push(l);
  }
  function o(l) {
    return bk(cu(e, { type: "Polygon", arcs: [l] }).coordinates[0]);
  }
  return r.forEach(function(l) {
    if (!l._) {
      var c = [], u = [l];
      for (l._ = 1, i.push(c); l = u.pop(); )
        c.push(l), l.forEach(function(d) {
          d.forEach(function(h) {
            n[h < 0 ? ~h : h].forEach(function(p) {
              p._ || (p._ = 1, u.push(p));
            });
          });
        });
    }
  }), r.forEach(function(l) {
    delete l._;
  }), {
    type: "MultiPolygon",
    arcs: i.map(function(l) {
      var c = [], u;
      if (l.forEach(function(g) {
        g.forEach(function(m) {
          m.forEach(function(v) {
            n[v < 0 ? ~v : v].length < 2 && c.push(v);
          });
        });
      }), c = xk(e, c), (u = c.length) > 1)
        for (var d = 1, h = o(c[0]), p, f; d < u; ++d)
          (p = o(c[d])) > h && (f = c[0], c[0] = c[d], c[d] = f, h = p);
      return c;
    }).filter(function(l) {
      return l.length > 0;
    })
  };
}
class Ok extends Vn {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = rt.SVG;
  }
  showRuler(t, [n, r]) {
    const i = this.parent, s = this.model.getOptions(), { cartesianScales: a } = this.services, o = a.getOrientation(), l = a.getRangeScale(), [c, u] = l.range(), d = a.getDomainScale(), h = d.invert(
      o === Ft.VERTICAL ? n : r
    ), p = N.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), f = N.appendOrSelect(p, "line.ruler-line"), g = i.selectAll("[role=graphics-symbol]").filter((m) => {
      if (parseFloat(gt(m, "data.x0")) <= h && parseFloat(gt(m, "data.x1")) >= h)
        return !0;
    });
    if (g.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Cg(this.elementsToHighlight, g) && this.hideRuler(), g.dispatch("mouseover"), this.elementsToHighlight = g;
      const m = I(g.nodes()[0]).datum(), v = parseFloat(gt(m, "data.x0")), b = parseFloat(gt(m, "data.x1")), _ = this.model.getActiveDataGroupNames(), E = _.reverse().map((x) => ({
        label: x,
        value: gt(m, `data.${x}`),
        class: this.model.getColorClassName({
          classNameTypes: [it.TOOLTIP],
          dataGroupName: x
        })
      })).filter((x) => x.value !== 0);
      if (E.length > 0) {
        this.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: t,
          mousePosition: [n, r],
          hoveredElement: f,
          items: [
            {
              label: gt(s, "bins.rangeLabel") || "Range",
              value: `${v}  ${b}`
            },
            ...E,
            ...y(s, "tooltip", "showTotal") === !0 ? [
              {
                label: gt(s, "tooltip.totalLabel") || gt(s, "locale.translations.total") || "Total",
                value: (() => {
                  const S = y(
                    s,
                    "tooltip",
                    "customTotalCalculation"
                  );
                  if (S) {
                    const $ = _.map(
                      (D) => ({
                        [D]: parseFloat(gt(m, `data.${D}`))
                      })
                    );
                    return S($);
                  } else
                    return _.reduce(
                      ($, D) => $ + parseFloat(gt(m, `data.${D}`)),
                      0
                    );
                })()
              }
            ] : []
          ]
        }), p.attr("opacity", 1);
        const x = d((v + b) / 2);
        o === "horizontal" ? f.attr("x1", u).attr("x2", c).attr("y1", x).attr("y2", x) : f.attr("y1", u).attr("y2", c).attr("x1", x).attr("x2", x);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class Ua extends Vn {
  formatTooltipData(t) {
    return t.reverse();
  }
}
const Sk = (e, t) => {
  const n = e.x, r = e.y, i = t.x, s = t.y, a = Rg();
  return a.moveTo(n, r), a.lineTo(i, s), a.toString();
}, Tk = {
  d: "M7 0v8L0 4z"
}, wk = {
  d: "M0 0v8l7-4z"
}, $k = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z"
}, Mk = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z"
}, Ck = {
  d: "M0 .44974747h8v8H0v-3.6830331z"
}, Ak = {
  d: "M0 0h1.5v8H0z"
};
class Tv extends ou {
  constructor(t, n, r) {
    super(t, n, r), this.type = "color-legend", this.renderType = rt.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const i = this.getComponentContainer(), { width: s } = N.getSVGElementSize(i, {
        useAttrs: !0
      }), a = y(this.getOptions(), "data", "loading");
      if (s > It.color.barWidth && !a) {
        const o = y(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: l } = this.services, c = l.getMainXScale().range();
        if (c[0] > 1 && (i.select("g.legend").attr("transform", `translate(${c[0]}, 0)`), o)) {
          const { width: u } = N.getSVGElementSize(
            i.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), d = c[0] - u - 9;
          d > 1 ? i.select("g.legend-title").attr("transform", `translate(${d}, 0)`) : (i.select("g.legend").attr("transform", `translate(${c[0]}, 16)`), i.select("g.legend-title").attr("transform", `translate(${c[0]}, 0)`));
        }
      } else
        i.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = r.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(T.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = this.getComponentContainer({
      ariaLabel: "legend"
    }), { width: i } = N.getSVGElementSize(r, {
      useAttrs: !0
    }), s = y(n, "color", "gradient", "colors"), a = y(n, this.chartType, "colorLegend", "type");
    let o = y(n, "color", "pairing", "option");
    const l = y(n, "heatmap", "colorLegend", "title");
    if (y(this.getOptions(), "data", "loading")) {
      r.html("");
      return;
    }
    const c = !Be(s), u = zm(this.model.getDisplayData()), d = !(i <= It.color.barWidth), h = d ? It.color.barWidth : i, p = N.appendOrSelect(r, "g.legend"), f = N.appendOrSelect(p, "g.legend-axis");
    if (l) {
      const C = N.appendOrSelect(r, "g.legend-title");
      N.appendOrSelect(C, "text").text(l).attr("dy", "0.7em"), p.attr("transform", "translate(0, 16)");
    }
    const g = u[0] < 0 && u[1] > 0 ? "diverge" : "mono";
    (o < 1 && o > 4 && g === "mono" || o < 1 && o > 2 && g === "diverge") && (o = 1);
    let m = [];
    const v = g === "diverge" ? 17 : 11;
    if (c)
      m = s;
    else
      for (let C = 1; C < v + 1; C++)
        m.push(
          a === qs.LINEAR ? `stop-color-${g}-${o}-${C}` : `fill-${g}-${o}-${C}`
        );
    const b = xe(u[0], u[1]), _ = qC(b, 3), E = Fe().domain(u).range([0, h]), x = Qc(E).tickSize(0).tickValues(_), { code: S, number: $ } = y(n, "locale");
    x.tickFormat((C) => $(C, S));
    let D;
    switch (a) {
      case qs.LINEAR:
        this.drawLinear(m, p, h);
        break;
      case qs.QUANTIZE:
        D = this.drawQuantize(
          m,
          g,
          c,
          p,
          h
        ), E.range([D, h]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    f.attr("transform", `translate(0,${It.color.axisYTranslation})`).call(x), f.select(".domain").remove(), f.select("g.tick:last-of-type text").style("text-anchor", d ? "middle" : "end"), f.select("g.tick:first-of-type text").style(
      "text-anchor",
      d && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(t, n, r) {
    const i = 100 / (t.length - 1);
    N.appendOrSelect(n, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (s, a) => `${a * i}%`).attr("class", (s, a) => t[a]).attr("stop-color", (s) => s), N.appendOrSelect(n, "rect").attr("width", r).attr("height", It.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(t, n, r, i, s) {
    !r && n === "diverge" && t.splice(t.length / 2, 1);
    const a = Jr().domain(t).range([0, s]);
    return N.appendOrSelect(i, "g.quantized-rect").selectAll("rect").data(a.domain()).join("rect").attr("x", (o) => a(o)).attr("y", 0).attr("width", Math.max(0, a.bandwidth() - 1)).attr("height", It.color.barHeight).attr("class", (o) => o).attr("fill", (o) => o), (!r && n) === "mono" ? a.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(T.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
}
class Lk extends _s {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = rt.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = y(this.model.getDisplayData(), 0), r = this.getOptions(), i = this.getComponentContainer({
      ariaLabel: "meter title"
    }), { groupMapsTo: s } = r.data, a = r.locale.translations.meter.title;
    if (y(r, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const c = i.selectAll("text.meter-title").data(a ? [a] : [n[s]]);
      c.enter().append("text").classed("meter-title", !0).merge(c).attr("x", 0).attr("y", "1em").text((u) => u), c.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const o = this.getMaxTitleWidth(), l = N.appendOrSelect(i, "text.meter-title");
    o > 0 && l.node().getComputedTextLength() > o && this.truncateTitle(l, o);
  }
  displayBreakdownTitle() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = this.model.getMaximumDomain(
      this.model.getDisplayData()
    ), i = y(n, "meter", "proportional", "total"), s = y(n, "meter", "proportional", "unit") ? y(n, "meter", "proportional", "unit") : "";
    let a;
    if (r === i)
      a = null;
    else {
      const u = i !== null ? i - r : r, d = y(n, "meter", "proportional", "breakdownFormatter"), { code: h, number: p } = y(n, "locale");
      a = d !== null ? d({
        datasetsTotal: r,
        total: i
      }) : `${p(r, h)} ${s} used (${p(u, h)} ${s} available)`;
    }
    const o = t.selectAll("text.proportional-meter-title").data([a]);
    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((u) => u), o.exit().remove();
    const l = this.getMaxTitleWidth(), c = N.appendOrSelect(t, "text.proportional-meter-title");
    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);
  }
  // show the total for prop meter
  displayTotal() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = y(n, "meter", "proportional", "total"), i = r ? y(n, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), s = y(n, "meter", "proportional", "unit") ? y(n, "meter", "proportional", "unit") : "", a = y(n, "meter", "proportional", "totalFormatter"), { code: o, number: l } = y(n, "locale"), c = a !== null ? a(i) : `${l(r, o)} ${s} total`, u = N.getHTMLElementSize(this.parent.node()).width, d = t.selectAll("text.proportional-meter-total").data([c]);
    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(
      "x",
      this.model.getStatus() && typeof u != "string" ? u - Zt.total.paddingRight : u
    ).attr("y", "1em").attr("text-anchor", "end").text((h) => h), d.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const t = this, n = this.getComponentContainer(), r = N.getHTMLElementSize(this.parent.node()).width || 0, i = this.model.getStatus(), s = Zt.status.indicatorSize / 2, a = N.appendOrSelect(n, "g.status-indicator").attr("class", i !== null ? `status-indicator status--${i}` : "").attr("transform", `translate(${r - s}, 0)`), o = i ? [i] : [], l = a.selectAll("circle.status").data(o);
    l.enter().append("circle").merge(l).attr("class", "status").attr("r", s).attr("cx", 0).attr("cy", 8);
    const c = a.selectAll("path.innerFill").data(o);
    c.enter().append("path").merge(c).attr("d", t.getStatusIconPathString(i)).attr("transform", `translate(-${s}, 0)`).attr("class", "innerFill"), c.exit().remove(), l.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const t = y(this.model.getDisplayData(), 0, "value"), { code: n, number: r } = y(this.getOptions(), "locale"), i = this.getComponentContainer(), s = N.appendOrSelect(i, "text.meter-title"), a = y(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], o = i.selectAll("text.percent-value").data(a), l = Zt.statusBar.paddingRight;
    o.enter().append("text").classed("percent-value", !0).merge(o).text((c) => `${c != null ? r(c, n) : 0}%`).attr("x", +s.attr("x") + s.node().getComputedTextLength() + l).attr("y", s.attr("y")), o.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param maxWidth the max width the title can take
   */
  truncateTitle(t, n) {
    super.truncateTitle(t, n);
    const r = N.appendOrSelect(this.parent, "tspan"), i = Zt.statusBar.paddingRight, s = Math.ceil(r.node().getComputedTextLength());
    N.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +t.attr("x") + t.node().getComputedTextLength() + s + i
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const t = y(this.getOptions(), "meter", "proportional"), n = N.getHTMLElementSize(this.parent.node()).width;
    if (t !== null) {
      const r = N.appendOrSelect(this.parent, "text.proportional-meter-total").node(), i = N.getSVGElementSize(r, {
        useBBox: !0
      }).width;
      return n - i - Zt.total.paddingLeft;
    } else {
      const r = N.appendOrSelect(this.parent, "text.percent-value"), i = Zt.statusBar.paddingRight, s = r.node().getComputedTextLength(), a = N.appendOrSelect(this.parent, "g.status-indicator").node(), o = N.getSVGElementSize(a, { useBBox: !0 }).width + Zt.status.paddingLeft;
      return n - s - i - o;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(t) {
    switch (t) {
      case js.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case js.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case js.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class uu extends mt {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions();
    if (t.bars.width)
      return t.bars.width;
    const n = this.model.getDisplayData().length, r = this.services.cartesianScales.getMainXScale(), i = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!r.step) {
      const s = y(t, "bars", "spacingFactor");
      return Math.min(t.bars.maxWidth, i * s / n);
    }
    return Math.min(t.bars.maxWidth, r.step() / 2);
  }
  isOutsideZoomedDomain(t, n) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const r = this.model.get("zoomDomain");
    if (r !== void 0) {
      const i = this.services.cartesianScales.getDomainScale();
      return t < i(r[0]) || n > i(r[1]);
    }
    return !1;
  }
}
class Dk extends mt {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (r) => r.data.dataGroupName === n.datum().name ? 1 : Ar.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "circle packs",
      withinChartClip: !0
    }), { width: r, height: i } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    let s = this.model.getDisplayData();
    const a = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), l = this.getOptions(), c = y(l, "canvasZoom", "enabled");
    a && y(s, 0, "children") && (s = y(s, 0, "children"));
    const u = xs({ children: s }).sum((f) => f.value).sort((f, g) => g.value - f.value), d = BL().size([r, i]).padding((f) => f.depth >= 1 ? Ar.padding.children + 3 : Ar.padding.mainGroup + 3)(u).descendants().splice(1).filter((f) => f.depth <= o), h = n.selectAll("circle.node").data(d);
    h.exit().attr("width", 0).attr("height", 0).remove();
    const p = h.enter().append("circle").classed("node", !0);
    p.merge(h).attr("class", (f) => {
      const g = c && o === 3 ? this.getZoomClass(f) : "";
      return this.model.getColorClassName({
        classNameTypes: [it.FILL, it.STROKE],
        dataGroupName: f.data.dataGroupName,
        originalClassName: f.children ? `node ${g}` : `node node-leaf ${g}`
      });
    }).style("fill", (f) => this.model.getFillColor(f.data.dataGroupName, null, f.data)).style("stroke", (f) => this.model.getFillColor(f.data.dataGroupName, null, f.data)).attr("cx", (f) => f.x).attr("cy", (f) => f.y).transition("circlepack-leaf-update-enter").call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (f) => f.r).attr("opacity", 1).attr("fill-opacity", Ar.circles.fillOpacity), c === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, p, Pr), this.setBackgroundListeners()), a || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(t) {
    const n = t.map((r) => r.data);
    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", (r) => this.model.getFillColor(r.data.dataGroupName, null, r.data));
  }
  // highlight the children circles with a stroke
  highlightChildren(t) {
    const n = t.map((r) => r.data);
    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", Ar.circles.hover.stroke);
  }
  getZoomClass(t) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((n) => n.data === t.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    I(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const t = I(this.services.domUtils.getMainContainer()), n = this, r = this.parent.selectAll("circle.node");
    t.on("click", () => {
      n.focal = null, n.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), n.services.canvasZoom.zoomOut(r, Pr);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const t = this;
    this.parent.selectAll("circle.node").on("mouseover", function(n, r) {
      const i = I(this);
      i.classed("hovered", !0);
      const s = t.model.getHierarchyLevel(), a = s > 2 && !i.classed("focal"), o = y(t.model.getOptions(), "canvasZoom", "enabled");
      let l = !1;
      if (!a) {
        let c = [], u = [], d = null;
        if (r.children) {
          r.depth > 1 && o && (l = !0, i.classed("clickable", !0)), c = r.children.map((f) => {
            if (f !== null)
              return typeof f.data.value == "number" ? {
                label: f.data.name,
                value: f.data.value
              } : {
                label: f.data.name,
                labelIcon: o && s <= 2 ? t.getZoomIcon() : null,
                value: f.value
              };
          });
          const p = t.model.getOptions();
          u = [
            {
              label: gt(p, "locale.translations.total") || gt(p, "tooltip.totalLabel") || "Total",
              value: r.value,
              bold: !0
            }
          ], t.highlightChildren(r.children);
        } else
          d = r.value;
        const h = getComputedStyle(this, null).getPropertyValue("fill");
        t.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: n,
          hoveredElement: i,
          items: [
            {
              color: h,
              label: r.data.name,
              labelIcon: l && o && s <= 2 ? t.getZoomIcon() : null,
              value: d
            },
            ...c,
            ...u
          ]
        });
      }
      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: n
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      i.classed("hovered", !1), r.children && t.unhighlightChildren(r.children), t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: i
      });
    }).on("click", function(n, r) {
      const i = I(this), s = i.classed("non-focal"), a = y(t.model.getOptions(), "canvasZoom", "enabled");
      if (a && t.model.getHierarchyLevel() > 2) {
        const o = t.parent.selectAll("circle.node");
        I(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Pr);
      } else if (r.depth === 2 && r.children && !s && a) {
        const o = t.parent.selectAll("circle.node");
        I(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = r, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(r, o, Pr), n.stopPropagation();
      }
      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_CLICK, {
        event: n,
        element: i,
        datum: r
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function kk(e, t) {
  const n = gs(this._current, e);
  return (r) => (this._current = n(r), t(this._current));
}
class wv extends mt {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = rt.SVG, this.isRendering = !1, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (i) => i.data[r] !== n.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return Mt.innerRadius;
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer({
      ariaLabel: "pie graph"
    }), i = this.getOptions(), { groupMapsTo: s } = i.data, { valueMapsTo: a } = i.pie;
    this.isRendering = !0;
    const o = this.model.getDisplayData().filter((C) => C[a] > 0), l = this.computeRadius();
    this.arc = ls().innerRadius(this.getInnerRadius()).outerRadius(l), this.hoverArc = ls().innerRadius(this.getInnerRadius()).outerRadius(l + Mt.hoverArc.outerRadiusOffset);
    const c = oD().value((C) => C[a]).sort(y(i, "pie", "sortFunction")).padAngle(Mt.padAngle)(o), u = N.appendOrSelect(r, "g.slices").attr("role", ht.GROUP).attr("data-name", "slices").selectAll("path.slice").data(c, (C) => C.data[s]);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(
      "class",
      (C) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: C.data[s],
        originalClassName: "slice"
      })
    ).style("fill", (C) => n.model.getFillColor(C.data[s], null, C.data)).attr("d", this.arc).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "pie_slice_enter_update",
        animate: t
      })
    ).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr("aria-label", (C) => [
      C[a],
      Ao(C.data[a], o, a) + "%",
      C.data[s]
    ].filter(Boolean).join(", ")).attrTween("d", function(C) {
      return kk.bind(this)(C, n.arc);
    }).on("end", () => {
      n.isRendering = !1;
    });
    const { code: d, number: h } = y(i, "locale"), p = i.pie.labels.enabled, f = p ? c.filter((C) => C.data[a] > 0) : [], g = N.appendOrSelect(r, "g.labels").attr("role", ht.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(f, (C) => C.data[s]);
    g.exit().attr("opacity", 0).remove();
    const m = g.enter().append("text").classed("pie-label", !0), v = [];
    m.merge(g).style("text-anchor", "middle").text((C) => i.pie.labels.formatter ? i.pie.labels.formatter({
      ...C,
      percentageValue: Ao(
        C.data[a],
        o,
        a,
        !0
      )
    }) : h(
      Ao(C.data[a], o, a),
      d
    ) + "%").datum(function(C) {
      const R = l + 7, M = (C.endAngle - C.startAngle) / 2 + C.startAngle, H = M / Math.PI * 180, P = this.getComputedTextLength();
      return C.textOffsetX = P / 2, C.textOffsetY = H > 90 && H < 270 ? 10 : 0, C.xPosition = (C.textOffsetX + R) * Math.sin(M), C.yPosition = (C.textOffsetY + R) * -Math.cos(M), C;
    }).attr("transform", function(C, R) {
      const M = f.length, H = (C.endAngle - C.startAngle) * (180 / Math.PI);
      if (R >= M - 2 && H < Mt.callout.minSliceDegree) {
        let P, B;
        return C.index === M - 1 ? (P = C.xPosition + Mt.callout.offsetX + Mt.callout.textMargin + C.textOffsetX, B = C.yPosition - Mt.callout.offsetY, C.direction = Fs.RIGHT, v.push(C)) : (P = C.xPosition - Mt.callout.offsetX - C.textOffsetX - Mt.callout.textMargin, B = C.yPosition - Mt.callout.offsetY, C.direction = Fs.LEFT, v.push(C)), `translate(${P}, ${B})`;
      }
      return `translate(${C.xPosition}, ${C.yPosition})`;
    }), this.renderCallouts(v);
    const b = y(i, "donut") ? "donut" : "pie", _ = y(i, b, "alignment"), { width: E } = N.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), x = p ? Mt.xOffset : 0, S = p ? Mt.yOffset : 0;
    let $ = l + x;
    _ === jt.CENTER ? $ = E / 2 : _ === jt.RIGHT && ($ = E - l - Mt.xOffset);
    let D = l + S;
    v.length > 0 && (D += Mt.yOffsetCallout), r.attr("x", $ + 7).attr("y", D), this.addEventListeners();
  }
  renderCallouts(t) {
    const n = N.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", ht.GROUP).attr("data-name", "callouts"), r = n.selectAll("g.callout").data(t);
    r.exit().remove();
    const i = r.enter().append("g").classed("callout", !0).attr("role", ht.GROUP).attr("aria-roledescription", "label callout");
    i.merge(r).datum(function(s) {
      const { xPosition: a, yPosition: o, direction: l } = s;
      return l === Fs.RIGHT ? (s.startPos = {
        x: a,
        y: o + s.textOffsetY
      }, s.endPos = {
        x: a + Mt.callout.offsetX,
        y: o - Mt.callout.offsetY + s.textOffsetY
      }, s.intersectPointX = s.endPos.x - Mt.callout.horizontalLineLength) : (s.startPos = {
        x: a,
        y: o + s.textOffsetY
      }, s.endPos = {
        x: a - Mt.callout.offsetX,
        y: o - Mt.callout.offsetY + s.textOffsetY
      }, s.intersectPointX = s.endPos.x + Mt.callout.horizontalLineLength), s;
    }), i.append("line").classed("vertical-line", !0).merge(n.selectAll("line.vertical-line")).datum(function() {
      return I(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (s) => s.startPos.x).attr("y1", (s) => s.startPos.y).attr("x2", (s) => s.intersectPointX).attr("y2", (s) => s.endPos.y), i.append("line").classed("horizontal-line", !0).merge(n.selectAll("line.horizontal-line")).datum(function() {
      return I(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (s) => s.intersectPointX).attr("y1", (s) => s.endPos.y).attr("x2", (s) => s.endPos.x).attr("y2", (s) => s.endPos.y);
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.slice").on("mouseover", function(n, r) {
      const i = I(this);
      t.isRendering || i.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "pie_slice_mouseover"
        })
      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEOVER, {
        event: n,
        element: I(this),
        datum: r
      });
      const { groupMapsTo: s } = t.getOptions().data, { valueMapsTo: a } = t.getOptions().pie;
      t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            label: r.data[s],
            value: r.data[a]
          }
        ]
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(T.Pie.SLICE_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      CC(() => {
        t.isRendering || i.classed("hovered", !1).transition("pie_slice_mouseout").call(
          (s) => t.services.transitions.setupTransition({
            transition: s,
            name: "pie_slice_mouseout"
          })
        ).attr("d", t.arc);
      }, 100), t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: t, height: n } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), r = this.getOptions(), i = Math.min(t, n) / 2;
    return r.pie.labels.enabled ? i + Mt.radiusOffset : i;
  }
}
class Rk extends wv {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = rt.SVG;
  }
  render(t = !0) {
    super.render(t);
    const n = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer({
        ariaLabel: "donut graph"
      }).select("g.center").remove();
      return;
    }
    const r = N.appendOrSelect(
      this.getComponentContainer({
        ariaLabel: "donut graph"
      }),
      "g.center"
    ), i = this.getOptions(), s = this.computeRadius(), a = y(i, "donut", "center", "label");
    N.appendOrSelect(r, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => a === null || a === "" ? "central" : "initial").style("font-size", () => i.donut.center.numberFontSize(s)).transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "donut-figure-enter-update",
        animate: t
      })
    ).tween("text", function() {
      return n.centerNumberTween(I(this));
    }), a !== null && a !== "" && N.appendOrSelect(r, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => i.donut.center.titleFontSize(s)).attr("y", i.donut.center.titleYPosition(s)).text(a);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(t) {
    const n = this.getOptions();
    let r = y(n, "donut", "center", "number");
    r === null && (r = this.model.getDisplayData().reduce((o, l) => o + l[n.pie.valueMapsTo], 0));
    const i = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;
    let s;
    i % 1 === 0 && r % 1 === 0 ? s = um : s = xe;
    const a = s(i, r);
    return (o) => {
      const { numberFormatter: l } = n.donut.center;
      if (l)
        t.text(l(a(o)));
      else {
        const { code: c, number: u } = y(n, "locale");
        t.text(u(Math.floor(a(o)), c));
      }
    };
  }
}
const fp = "4,10 8,6 12,10", mp = "12,6 8,10 4,6";
class Ik extends mt {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = rt.SVG;
  }
  getValue() {
    return this.model.getData().find((t) => t.group === "value")?.value ?? null;
  }
  getValueRatio() {
    return Mg(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    return this.model.getData().find((t) => t.group === "delta")?.value ?? null;
  }
  getArcRatio() {
    const t = this.getOptions();
    return y(t, "gauge", "type") === Ir.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const t = this.getArcSize();
    return t === 2 * Math.PI ? 0 : -t / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(t) {
    const n = this.getOptions();
    switch (y(n, "gauge", "deltaArrow", "direction")) {
      case dl.UP:
        return fp;
      case dl.DOWN:
        return mp;
      default:
        return t > 0 ? fp : mp;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "gauge graph"
    }).attr("width", "100%").attr("height", "100%"), r = this.getOptions(), i = this.getValue(), s = this.getValueRatio(), a = this.getArcSize(), o = this.getStartAngle(), l = s * a, c = o + l, u = o + a, d = this.computeRadius(), h = this.getInnerRadius();
    this.backgroundArc = ls().innerRadius(h).outerRadius(d).startAngle(c).endAngle(u), this.arc = ls().innerRadius(h).outerRadius(d).startAngle(o).endAngle(c), N.appendOrSelect(n, "path.arc-background").attr("d", this.backgroundArc);
    const p = n.selectAll("path.arc-foreground").data([i]);
    p.enter().append("path").merge(p).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => y(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (v) => v), this.drawValueNumber(), this.drawDelta(), p.exit().remove();
    const f = y(r, "gauge", "alignment"), { width: g } = N.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let m = d;
    f === jt.CENTER ? m = g / 2 : f === jt.RIGHT && (m = g - d), n.attr("x", m).attr("y", d), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = y(n, "gauge", "type"), i = this.getValue(), s = this.getDelta(), a = this.computeRadius(), o = y(n, "gauge", "valueFontSize"), l = y(n, "gauge", "deltaFontSize"), c = y(n, "gauge", "numberSpacing"), u = y(n, "gauge", "showPercentageSymbol");
    let d = 0;
    r === Ir.FULL && !s ? d = l(a) : r === Ir.SEMI && s && (d = -(l(a) + c));
    const h = N.appendOrSelect(t, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${d})`
    ), p = o(a), f = N.appendOrSelect(h, "g.gauge-value-number"), { code: g, number: m } = y(n, "locale"), v = y(n, "gauge", "numberFormatter"), b = f.selectAll("text.gauge-value-number").data([i]);
    b.enter().append("text").attr("class", "gauge-value-number").merge(b).style("font-size", `${p}px`).attr("text-anchor", "middle").text((C) => {
      let R;
      return C != null ? R = Number(C.toFixed(2)) % 1 !== 0 ? C.toFixed(2) : C.toFixed() : R = 0, v ? v(R) : m(Number(R), g);
    });
    const { width: _ } = N.getSVGElementSize(
      N.appendOrSelect(t, "text.gauge-value-number"),
      { useBBox: !0 }
    ), E = p / 2, x = u ? "%" : "", S = N.appendOrSelect(f, "text.gauge-value-symbol").style("font-size", `${E}px`).attr("x", _ / 2).text(x), { width: $, height: D } = N.getSVGElementSize(S, {
      useBBox: !0
    });
    S.attr("y", `-${D / 2}px`), f.attr("transform", `translate(-${$ / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = this.getDelta(), { code: s, number: a } = y(r, "locale");
    if (i) {
      const o = this.computeRadius(), l = i ? y(r, "gauge", "deltaFontSize") : () => 0, c = i ? y(r, "gauge", "numberFormatter") : () => null, u = y(r, "gauge", "deltaArrow", "size"), d = y(r, "gauge", "numberSpacing"), h = y(r, "gauge", "showPercentageSymbol"), p = N.appendOrSelect(n, "g.gauge-numbers"), f = N.appendOrSelect(p, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${l(o) + d})`
      ), g = N.appendOrSelect(f, "text.gauge-delta-number"), m = h ? "%" : "";
      g.data(i === null ? [] : [i]), g.enter().append("text").classed("gauge-delta-number", !0).merge(g).attr("text-anchor", "middle").style("font-size", `${l(o)}px`).text((E) => {
        let x;
        return E != null ? x = Number(E.toFixed(2)) % 1 !== 0 ? E.toFixed(2) : E.toFixed() : x = 0, c ? `${c(x)}${m}` : `${a(Number(x), s)}${m}`;
      });
      const { width: v } = N.getSVGElementSize(
        N.appendOrSelect(n, ".gauge-delta-number"),
        { useBBox: !0 }
      ), b = y(r, "gauge", "deltaArrow", "enabled"), _ = f.selectAll("svg.gauge-delta-arrow").data(i !== null && b ? [i] : []);
      _.enter().append("svg").merge(_).attr("class", "gauge-delta-arrow").attr("x", -u(o) - v / 2).attr("y", -u(o) / 2 - l(o) * 0.35).attr("width", u(o)).attr("height", u(o)).attr("viewBox", "0 0 16 16").each(function() {
        const E = I(this);
        N.appendOrSelect(E, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const x = y(r, "gauge", "status");
        N.appendOrSelect(E, "polygon.gauge-delta-arrow").attr("class", x !== null ? `gauge-delta-arrow status--${x}` : "").attr("points", t.getArrow(i));
      }), _.exit().remove(), g.exit().remove();
    } else {
      const o = n.select("g.gauge-delta");
      o.empty() || o.remove();
    }
  }
  getInnerRadius() {
    const t = this.computeRadius(), n = y(this.getOptions(), "gauge", "arcWidth");
    return t - n;
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(n, r) {
      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEOVER, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(T.Gauge.ARC_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      });
    });
  }
  // Helper functions
  computeRadius() {
    const t = this.getOptions(), n = y(t, "gauge", "type"), { width: r, height: i } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return n === Ir.SEMI ? Math.min(r / 2, i) : Math.min(r / 2, i / 2);
  }
}
class $v extends uu {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = rt.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.model.getDisplayData(this.configs.groups), r = this.getOptions(), { groupMapsTo: i } = r.data;
    this.setGroupScale();
    const s = this.getComponentContainer({ ariaLabel: "grouped bar graphs", withinChartClip: !0 }), a = Qi(
      n.map((u) => {
        const d = this.services.cartesianScales.getDomainIdentifier(u);
        return u[d] && typeof u[d].toString == "function" ? u[d].toString() : u[d];
      })
    ), o = s.selectAll("g.bars").data(a, (u) => u);
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("bars", !0).attr("role", ht.GROUP).attr("data-name", "bars").merge(o);
    l.transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-group-update-enter",
        animate: t
      })
    ).attr("transform", (u) => {
      const d = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth(u) / 2;
      return this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? `translate(${d}, 0)` : `translate(0, ${d})`;
    });
    const c = l.selectAll("path.bar").data(
      (u) => this.getDataCorrespondingToLabel(u),
      (u) => u[i]
    );
    c.exit().attr("opacity", 0).remove(), c.enter().append("path").attr("opacity", 0).merge(c).classed("bar", !0).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: u[i],
        originalClassName: "bar"
      })
    ).style("fill", (u) => {
      const d = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[i], u[d], u);
    }).attr("d", (u) => {
      const d = this.services.cartesianScales.getDomainIdentifier(u), h = u[d] && typeof u[d].toString == "function" ? u[d].toString() : u[d], p = this.getGroupScaleForLabel(h)(u[i]), f = this.getBarWidth(), g = p, m = p + f, v = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), b = this.services.cartesianScales.getDomainLowerBound(v), _ = this.services.cartesianScales.getValueThroughAxisPosition(v, b), E = this.services.cartesianScales.getRangeValue(u), x = this.services.cartesianScales.getDomainValue(u) - f / 2, S = x + f;
      if (!this.isOutsideZoomedDomain(x, S))
        return ae(
          { x0: g, x1: m, y0: _, y1: E },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, n = y(this.getOptions(), "tooltip", "alwaysShowRulerTooltip"), r = this.parent.selectAll("path.bar");
    n ? r.style("pointer-events", "none") : r.style("pointer-events", null), r.on("mouseover", function(i, s) {
      const a = I(this);
      a.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      }), n || t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        data: [s]
      });
    }).on("mousemove", function(i, s) {
      const a = I(this);
      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: i,
        element: I(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = I(this);
      a.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(t) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const r = this.services.cartesianScales.getDomainIdentifier(n);
      return n[r].toString() === t;
    });
  }
  getGroupWidth(t) {
    const n = this.getOptions();
    if (y(n, "bars", "preserveSpaceForMissingBars") === !1 && t) {
      const s = this.getDataCorrespondingToLabel(t), a = this.getTotalGroupPadding(s.length);
      return this.getBarWidth() * s.length + a;
    }
    const r = this.model.getGroupedData(this.configs.groups), i = this.getTotalGroupPadding();
    return this.getBarWidth() * r.length + i;
  }
  getDomainScaleStep() {
    const t = this.services.cartesianScales.getDomainScale(), n = this.model.getGroupedData(this.configs.groups);
    let r = this.defaultStepFactor;
    if (typeof t.step == "function")
      r = t.step();
    else if (n.length > 0) {
      const i = n.find((s) => s.data?.length > 1);
      if (i) {
        const s = this.services.cartesianScales.getDomainIdentifier(i.data[0]);
        r = Math.abs(
          t(i.data[1][s]) - t(i.data[0][s])
        );
      }
    }
    return r;
  }
  getTotalGroupPadding(t) {
    const n = this.model.getGroupedData(this.configs.groups), r = t !== void 0 ? t : n.length;
    return r === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (r - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions(), n = y(t, "bars", "width"), r = y(t, "bars", "maxWidth");
    if (n !== null && (r === null || n <= r))
      return n;
    const i = this.model.getGroupedData(this.configs.groups).length, s = this.getTotalGroupPadding();
    return Math.min(
      r,
      (this.getDomainScaleStep() - s) / i
    );
  }
  setGroupScale() {
    const t = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = Jr().domain(t).rangeRound([0, this.getGroupWidth()]);
  }
  getGroupScaleForLabel(t) {
    const n = this.getOptions();
    if (y(n, "bars", "preserveSpaceForMissingBars") === !1) {
      const r = this.getDataCorrespondingToLabel(t), { groupMapsTo: i } = n.data, s = r.map((a) => a[i]);
      return Jr().domain(s).rangeRound([0, this.getGroupWidth(t)]);
    }
    return this.groupScale;
  }
}
class Nk extends mt {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = rt.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (t) => {
      const { detail: n } = t, { datum: r } = n, i = this.model.getUniqueRanges(), s = this.model.getUniqueDomain(), a = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), l = this.services.cartesianScales.getMainXScale(), c = this.services.cartesianScales.getMainYScale();
      let u = "", d = null, h = null, p = null;
      this.matrix[r] !== void 0 ? (u = a, i.forEach((f) => {
        if (typeof this.matrix[r][f].value == "number") {
          const g = this.matrix[r][f].value;
          if (d === null) {
            d = g, h = g, p = g;
            return;
          }
          d += g, h = g < h ? g : h, p = g > p ? g : p;
        }
      })) : (u = o, s.forEach((f) => {
        if (typeof this.matrix[f][r].value == "number") {
          const g = this.matrix[f][r].value;
          if (d === null) {
            d = g, h = g, p = g;
            return;
          }
          d += g, h = g < h ? g : h, p = g > p ? g : p;
        }
      })), l(r) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${l(r)}, ${Bn(c.range())})`) : c(r) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${Bn(l.range())},${c(r)})`), this.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: n.event,
        hoveredElement: I(t.detail.element),
        items: [
          {
            label: u,
            value: r,
            bold: !0
          },
          {
            label: "Min",
            value: h !== null ? h : "-"
          },
          {
            label: "Max",
            value: p !== null ? p : "-"
          },
          {
            label: "Average",
            value: d !== null ? d / s.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (t) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(T.Tooltip.HIDE, {
        event: t
      });
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(T.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(T.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(T.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ ariaLabel: "heatmap", withinChartClip: !0 });
    n.lower();
    const { cartesianScales: r } = this.services;
    if (this.matrix = this.model.getMatrix(), n.html(""), y(this.getOptions(), "data", "loading"))
      return;
    const i = r.getMainXScale(), s = r.getMainYScale(), a = r.getDomainIdentifier(), o = r.getRangeIdentifier(), l = this.model.getUniqueDomain(), c = this.model.getUniqueRanges(), u = this.model.getMatrixAsArray(), d = i.range(), h = s.range();
    this.xBandwidth = Math.abs((d[1] - d[0]) / l.length), this.yBandwidth = Math.abs((h[1] - h[0]) / c.length);
    const p = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    n.append("defs").append("pattern").attr("id", p).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const f = n.selectAll().data(u).enter().append("g").attr("class", (g) => `heat-${g.index}`).classed("cell", !0).attr(
      "transform",
      (g) => `translate(${i(g[a])}, ${s(g[o])})`
    ).append("rect").attr(
      "class",
      (g) => this.model.getColorClassName({
        value: g.value,
        originalClassName: `heat-${g.index}`
      })
    ).classed("heat", !0).classed("null-state", (g) => g.index === -1 || g.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (g) => {
      const m = this.services.cartesianScales.getDomainIdentifier(g);
      return g.index === -1 || g.value === null ? `url(#${p})` : this.model.getFillColor(Number(g.value), g[m], g);
    }).attr("aria-label", (g) => g.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(h[1] - h[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(d[1] - d[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (f.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(t, n, r) {
    const i = N.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);
    N.appendOrSelect(i, "line.top").attr("x1", -1).attr("x2", n + 1), N.appendOrSelect(i, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", r + 1), N.appendOrSelect(i, "line.down").attr("x1", -1).attr("x2", n + 1).attr("y1", r).attr("y2", r), N.appendOrSelect(i, "line.right").attr("x1", n).attr("x2", n).attr("y1", -1).attr("y2", r + 1);
  }
  determineDividerStatus() {
    const t = y(this.getOptions(), "heatmap", "divider", "state");
    return t !== Bi.OFF && (t === Bi.AUTO && Dh.minCellDividerDimension <= this.xBandwidth && Dh.minCellDividerDimension <= this.yBandwidth || t === Bi.ON);
  }
  addEventListener() {
    const t = this, { cartesianScales: n } = this.services, r = this.getOptions(), i = gt(r, "locale.translations.total") || gt(r, "tooltip.totalLabel") || "Total", s = n.getDomainIdentifier(), a = n.getRangeIdentifier(), o = n.getDomainLabel(), l = n.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(c, u) {
      const d = I(this), h = d.select("rect.heat");
      if (!h.classed("null-state")) {
        const p = Ci(d.attr("transform"));
        t.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${p.x + t.translationUnits.x}, ${p.y + t.translationUnits.y})`
        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEOVER, {
          event: c,
          element: h,
          datum: u
        }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: c,
          items: [
            {
              label: o,
              value: u[s]
            },
            {
              label: l,
              value: u[a]
            },
            {
              label: i,
              value: u.value,
              color: h.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(c, u) {
      t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEMOVE, {
        event: c,
        element: I(this),
        datum: u
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, u) {
      t.services.events.dispatchEvent(T.Heatmap.HEATMAP_CLICK, {
        event: c,
        element: I(this),
        datum: u
      });
    }).on("mouseout", function(c, u) {
      const d = I(this).select("rect.heat"), h = d.classed("null-state");
      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), h || (t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEOUT, {
        event: c,
        element: d,
        datum: u
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        event: c,
        hoveredElement: d
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class Pk extends mt {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[i] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({
      ariaLabel: "histogram bars"
    }), r = this.model.getOptions(), { groupIdentifier: i } = r, { groupMapsTo: s } = r.data, a = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), l = n.selectAll("g.bars").data(a, (u) => gt(u, `0.${s}`));
    l.exit().attr("opacity", 0).remove(), l.enter().append("g").classed("bars", !0).attr("role", ht.GROUP);
    const c = n.selectAll("g.bars").selectAll("path.bar").data((u) => u);
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).attr(i, (u, d) => d).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "histogram-bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: u[s],
        originalClassName: "bar"
      })
    ).style("fill", (u) => this.model.getFillColor(u[s], null, u)).attr("d", (u) => {
      const d = gt(u, "data");
      if (!d)
        return;
      const h = o(d.x1) - o(d.x0) - 1, p = this.services.cartesianScales.getDomainValue(d.x0), f = p + h, g = this.services.cartesianScales.getRangeValue(u[0]);
      let m = this.services.cartesianScales.getRangeValue(u[1]);
      return Math.abs(m - g) > 0 && Math.abs(m - g) > r.bars.dividerSize && (this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? m += 1 : m -= 1), ae(
        { x0: p, x1: f, y0: g, y1: m },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => y(u, "data", u[s])), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.model.getOptions(), { groupMapsTo: n } = t.data, { code: r, number: i } = y(t, "locale"), s = y(t, "tooltip", "alwaysShowRulerTooltip"), a = this.parent.selectAll("path.bar");
    s ? a.style("pointer-events", "none") : a.style("pointer-events", null);
    const o = this;
    a.on("mouseover", function(l, c) {
      const u = I(this);
      u.classed("hovered", !0);
      const d = i(parseFloat(gt(c, "data.x0")), r), h = i(parseFloat(gt(c, "data.x1")), r), p = o.services.cartesianScales.getRangeAxisPosition(), f = o.services.cartesianScales.getScaleLabel(p);
      s || o.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: l,
        hoveredElement: u,
        items: [
          {
            label: gt(t, "bins.rangeLabel") || "Range",
            value: `${d}  ${h}`
          },
          {
            label: t.tooltip.groupLabel || "Group",
            value: c[n],
            class: o.model.getColorClassName({
              classNameTypes: [it.TOOLTIP],
              dataGroupName: c[n]
            })
          },
          {
            label: f,
            value: gt(c, `data.${c[n]}`)
          }
        ]
      });
    }).on("mousemove", function(l) {
      o.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: l
      });
    }).on("mouseout", function() {
      I(this).classed("hovered", !1), o.services.events.dispatchEvent(T.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Uk extends nn {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = rt.SVG, this.handleScatterOnHover = (t) => {
      const n = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("line.line").attr("stroke-width", (s) => s[i] !== n.datum[i] ? vn.weight.unselected : vn.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", vn.weight.unselected);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-line"
        })
      ).attr("opacity", (s) => s[i] !== n.datum().name ? vn.opacity.unselected : vn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", vn.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), r = this.model.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services, a = s.getMainXScale(), o = s.getMainYScale(), l = s.getDomainIdentifier(), c = (m) => s.getDomainValue(m), u = (m) => s.getRangeValue(m), d = s.getOrientation(), [h, p] = En(
      c,
      u,
      d
    ), f = n.selectAll("line.line").data(
      this.getScatterData(),
      (m) => `${m[i]}-${m[l]}`
    );
    f.exit().attr("opacity", 0).remove();
    const g = f.enter().append("line").attr("opacity", 0).merge(f).classed("line", !0).attr(
      "class",
      (m) => this.model.getColorClassName({
        classNameTypes: [it.STROKE],
        dataGroupName: m[i],
        originalClassName: "line"
      })
    ).transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "lollipop-line-update-enter",
        animate: t
      })
    ).style("stroke", (m) => this.model.getFillColor(m[i], m[l], m)).attr("opacity", 1);
    d === Ft.HORIZONTAL ? g.attr("y1", p).attr("y2", p).attr("x1", a.range()[0]).attr("x2", (m) => h(m) - r.points.radius) : g.attr("x1", h).attr("x2", h).attr("y1", o.range()[0]).attr("y2", (m) => p(m) + r.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      T.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      T.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(T.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(
      T.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class Bk extends mt {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = rt.SVG;
  }
  getStackedBounds(t, n) {
    let r = 0;
    return t.map((i, s) => s !== 0 ? (r += n(i.value), {
      ...i,
      width: Math.abs(n(i.value) - Zt.dividerWidth),
      x: r - n(i.value)
    }) : (r = n(i.value), {
      ...i,
      width: Math.abs(n(i.value) - Zt.dividerWidth),
      x: 0
    }));
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer({
      ariaLabel: "meter lines"
    }), i = this.getOptions(), s = y(i, "meter", "proportional"), a = this.model.getDisplayData(), o = this.model.getStatus(), { width: l } = N.getSVGElementSize(r, {
      useAttrs: !0
    }), { groupMapsTo: c } = i.data;
    let u;
    y(i, "meter", "proportional") === null ? u = 100 : u = y(i, "meter", "proportional", "total") || this.model.getMaximumDomain(this.model.getDisplayData());
    const d = Fe().domain([0, u]).range([0, l]), h = this.getStackedBounds(a, d), p = y(i, "meter", "height");
    N.appendOrSelect(r, "rect.container").attr("x", 0).attr("y", 0).attr("width", l).attr(
      "height",
      p || (s ? Zt.height.proportional : Zt.height.default)
    ), N.appendOrSelect(r, "line.rangeIndicator").attr("x1", l).attr("x2", l).attr("y1", 0).attr(
      "y2",
      p || (s ? Zt.height.proportional : Zt.height.default)
    );
    const f = r.selectAll("rect.value").data(h), g = o != null && !n.model.isUserProvidedColorScaleValid() && !s ? `value status--${o}` : "value";
    f.enter().append("rect").classed("value", !0).merge(f).attr("x", (_) => _.x).attr("y", 0).attr("height", () => p || (s ? Zt.height.proportional : Zt.height.default)).attr(
      "class",
      (_) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: _[c],
        originalClassName: g
      })
    ).transition().call(
      (_) => this.services.transitions.setupTransition({
        transition: _,
        name: "meter-bar-update",
        animate: t
      })
    ).attr("width", (_) => _.value > u ? d(u) : Math.max(_.width, 2)).style("fill", (_) => n.model.getFillColor(_[c], null, _)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (_) => _.value), f.exit().remove();
    const m = y(i, "meter", "peak");
    let v = m;
    m !== null && (m > u ? v = u : m < 0 && (v = 0));
    const b = r.selectAll("line.peak").data(v == null ? [] : [v]);
    b.enter().append("line").classed("peak", !0).merge(b).attr("y1", 0).attr("y2", () => p || (s ? Zt.height.proportional : Zt.height.default)).transition().call(
      (_) => this.services.transitions.setupTransition({
        transition: _,
        name: "peak-line-update",
        animate: t
      })
    ).attr("x1", (_) => d(_)).attr("x2", (_) => d(_)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (_) => _), b.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = y(t, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(T.Meter.METER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !0), r.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: a[n],
            value: a.value
          }
        ]
      }));
    }).on("mousemove", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(T.Meter.METER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), i && r.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      r.services.events.dispatchEvent(T.Meter.METER_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(T.Meter.METER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !1), r.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class Hk extends mt {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = rt.SVG, this.getLabelDimensions = (t) => {
      const n = N.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), r = N.appendOrSelect(n, "text").text(t), { width: i, height: s } = N.getSVGElementSize(r.node(), { useBBox: !0 });
      return n.remove(), { width: i, height: s };
    }, this.normalizeFlatData = (t) => {
      const n = this.getOptions(), { angle: r, value: i } = y(n, "radar", "axes"), s = y(n, "data", "groupMapsTo"), a = kC(
        this.uniqueKeys.map((o) => this.uniqueGroups.map((l) => ({
          [r]: o,
          [s]: l,
          [i]: null
        })))
      );
      return at(a, t);
    }, this.normalizeGroupedData = (t) => {
      const n = this.getOptions(), { angle: r, value: i } = y(n, "radar", "axes"), s = y(n, "data", "groupMapsTo");
      return t.map(({ name: a, data: o }) => {
        const l = this.uniqueKeys.map((c) => ({
          [s]: a,
          [r]: c,
          [i]: null
        }));
        return { name: a, data: at(l, o) };
      });
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (r) => r.name !== n.datum().name ? Wn.opacity.unselected : Wn.opacity.selected).style("stroke-opacity", (r) => r.name !== n.datum().name ? Wn.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", Wn.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "radar graph"
    }), { width: r, height: i } = N.getSVGElementSize(n, {
      useAttrs: !0
    }), s = this.model.getData(), a = this.model.getGroupedData(), o = this.getOptions(), l = y(o, "data", "groupMapsTo"), c = y(o, "radar", "axes", "value"), { angle: u, value: d } = y(o, "radar", "axes"), { xLabelPadding: h, yLabelPadding: p, yTicksNumber: f, minRange: g, xAxisRectHeight: m } = Wn;
    this.uniqueKeys = Array.from(new Set(s.map((O) => O[u]))), this.uniqueGroups = Array.from(new Set(s.map((O) => O[l]))), this.fullDataNormalized = this.normalizeFlatData(s), this.groupedDataNormalized = this.normalizeGroupedData(a);
    const v = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + p), b = (Math.min(r, i) - v) / 2;
    if (b <= 0)
      return;
    const _ = Jr().domain(this.fullDataNormalized.map((O) => O[u])).range([0, 2 * Math.PI].map((O) => O - Math.PI / 2)), E = Bn(this.fullDataNormalized.map((O) => O[d])), x = Fe().domain([
      E >= 0 ? 0 : E,
      nr(this.fullDataNormalized.map((O) => O[d]))
    ]).range([g, b]).nice(f), S = x.ticks(f), $ = (O, w, L) => this.model.getFillColor(O, w, L), D = uD().angle((O) => _(O[u]) + Math.PI / 2).radius((O) => x(O[d])).curve(ig), C = this.uniqueKeys.map((O) => {
      const w = this.getLabelDimensions(O).width, L = P2(
        _(O),
        b
      );
      return w + L;
    }), R = {
      x: nr(C) + h,
      y: i / 2
    }, M = N.appendOrSelect(n, "g.y-axes").attr("role", ht.GROUP).selectAll("path").data(S, (O) => O), H = (O) => this.uniqueKeys.map((w) => ({ [u]: w, [d]: O }));
    M.join(
      (O) => O.append("path").attr("opacity", 0).attr("transform", `translate(${R.x}, ${R.y})`).attr("fill", "none").call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_y_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("d", (L) => D(H(L)))
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_y_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${R.x}, ${R.y})`).attr("d", (L) => D(H(L)))
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_y_axes_exit",
            animate: t
          })
        ).attr("d", (L) => D(H(L))).attr("opacity", 0).remove()
      )
    ), N.appendOrSelect(n, "g.x-axes").attr("role", ht.GROUP).selectAll("line").data(this.uniqueKeys, (O) => O).join(
      (O) => O.append("line").attr("opacity", 0).attr("class", (w) => `x-axis-${Tr(w)}`).attr("stroke-dasharray", "0").attr("x1", (w) => Ut(_(w), 0, R).x).attr("y1", (w) => Ut(_(w), 0, R).y).attr("x2", (w) => Ut(_(w), 0, R).x).attr("y2", (w) => Ut(_(w), 0, R).y).call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_x_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (L) => Ut(_(L), x.range()[0], R).x).attr("y1", (L) => Ut(_(L), x.range()[0], R).y).attr("x2", (L) => Ut(_(L), x.range()[1], R).x).attr("y2", (L) => Ut(_(L), x.range()[1], R).y)
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_x_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (L) => Ut(_(L), x.range()[0], R).x).attr("y1", (L) => Ut(_(L), x.range()[0], R).y).attr("x2", (L) => Ut(_(L), x.range()[1], R).x).attr("y2", (L) => Ut(_(L), x.range()[1], R).y)
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_x_axes_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), N.appendOrSelect(n, "g.x-labels").attr("role", ht.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (O) => O.append("text").text((w) => w).attr("opacity", 0).attr(
        "x",
        (w) => Ut(_(w), x.range()[1] + h, R).x
      ).attr(
        "y",
        (w) => Ut(_(w), x.range()[1] + h, R).y
      ).style("text-anchor", (w) => dd(_(w)).textAnchor).style(
        "dominant-baseline",
        (w) => dd(_(w)).dominantBaseline
      ).call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_x_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_x_labels_update",
            animate: t
          })
        ).attr("opacity", 1).attr(
          "x",
          (L) => Ut(_(L), x.range()[1] + h, R).x
        ).attr(
          "y",
          (L) => Ut(_(L), x.range()[1] + h, R).y
        ).end().finally(() => {
          const L = y(o, "radar", "alignment"), k = this.getAlignmentXOffset(L, n, this.getParent());
          n.attr("x", k);
        })
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_x_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), N.appendOrSelect(n, "g.blobs").attr("role", ht.GROUP).selectAll("path").data(this.groupedDataNormalized, (O) => O.name).join(
      (O) => O.append("path").attr(
        "class",
        (w) => this.model.getColorClassName({
          classNameTypes: [it.FILL, it.STROKE],
          dataGroupName: w.name,
          originalClassName: "blob"
        })
      ).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (w) => w.name).attr("opacity", 0).attr(
        "transform",
        t ? () => `translate(${R.x}, ${R.y}) scale(${1 + Math.random() * 0.35})` : `translate(${R.x}, ${R.y})`
      ).style("fill", (w) => $(w.name, null, w.data)).style("fill-opacity", Wn.opacity.selected).style("stroke", (w) => $(w.name, null, w.data)).call((w) => {
        const L = w.transition().call(
          (k) => this.services.transitions.setupTransition({
            transition: k,
            name: "radar_blobs_enter",
            animate: t
          })
        );
        t && L.delay(() => Math.random() * 30).attr("transform", `translate(${R.x}, ${R.y})`), L.attr("opacity", 1).attr("d", (k) => D(k.data));
      }),
      (O) => (O.attr(
        "class",
        (w) => this.model.getColorClassName({
          classNameTypes: [it.FILL, it.STROKE],
          dataGroupName: w.name,
          originalClassName: "blob"
        })
      ).style("fill", (w) => $(w.name, null, w.data)).style("stroke", (w) => $(w.name, null, w.data)), O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_blobs_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${R.x}, ${R.y})`).attr("d", (L) => D(L.data))
      ), O),
      (O) => O.call((w) => {
        const L = w.transition().call(
          (k) => this.services.transitions.setupTransition({
            transition: k,
            name: "radar_blobs_exit",
            animate: t
          })
        );
        t && L.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${R.x}, ${R.y}) scale(${1 + Math.random() * 0.35})`
        ), L.attr("opacity", 0).remove();
      })
    ), N.appendOrSelect(n, "g.dots").attr("role", ht.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((O) => y(O, d) !== null)).join(
      (O) => O.append("circle").attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (w) => w[c]),
      (O) => O,
      (O) => O.remove()
    ).attr(
      "class",
      (O) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: O[l],
        originalClassName: Tr(O[u])
      })
    ).attr("cx", (O) => Ut(_(O[u]), x(O[d]), R).x).attr("cy", (O) => Ut(_(O[u]), x(O[d]), R).y).attr("r", 0).attr("opacity", 0).style("fill", (O) => $(O[l])), N.appendOrSelect(n, "g.x-axes-rect").attr("role", ht.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (O) => O.append("rect"),
      (O) => O,
      (O) => O.remove()
    ).attr("x", R.x).attr("y", R.y - m / 2).attr("width", x.range()[1]).attr("height", m).style("fill", "red").style("fill-opacity", 0).attr("transform", (O) => `rotate(${pg(_(O))}, ${R.x}, ${R.y})`);
    const { code: P, number: B } = y(o, "locale");
    N.appendOrSelect(n, "g.y-labels").attr("role", ht.GROUP).selectAll("text").data(ze(S)).join(
      (O) => O.append("text").attr("opacity", 0).text((w) => B(w, P)).attr(
        "x",
        (w) => Ut(-Math.PI / 2, x(w), R).x + p
      ).attr("y", (w) => Ut(-Math.PI / 2, x(w), R).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_y_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_y_labels_update",
            animate: t
          })
        ).text((L) => L).attr("opacity", 1).attr(
          "x",
          (L) => Ut(-Math.PI / 2, x(L), R).x + p
        ).attr("y", (L) => Ut(-Math.PI / 2, x(L), R).y)
      ),
      (O) => O.call(
        (w) => w.transition().call(
          (L) => this.services.transitions.setupTransition({
            transition: L,
            name: "radar_y_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(t, n, r) {
    const i = N.getSVGElementSize(n, {
      useBBox: !0
    }), { width: s } = N.getSVGElementSize(r, {
      useAttrs: !0
    });
    let a = 0;
    return t === jt.CENTER ? a = Math.floor((s - i.width) / 2) : t === jt.RIGHT && (a = s - i.width), a;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const t = this, {
      axes: { angle: n }
    } = y(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEOVER, {
        event: r,
        element: s,
        datum: i
      });
      const a = t.parent.select(`.x-axes .x-axis-${Tr(i)}`), o = t.parent.selectAll(`.dots circle.${Tr(i)}`), l = t.model.getActiveDataGroupNames(), c = t.getOptions(), { groupMapsTo: u } = c.data, d = y(c, "radar", "axes", "value");
      a.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(
        "opacity",
        (p) => l.indexOf(p[u]) !== -1 ? 1 : 0
      ).attr("r", Wn.dotsRadius);
      const h = t.fullDataNormalized.filter(
        (p) => p[n] === i && l.indexOf(p[u]) !== -1
      );
      t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: r,
        hoveredElement: s,
        items: h.filter((p) => typeof p[d] == "number").map((p) => ({
          label: p[u],
          value: p[d],
          color: t.model.getFillColor(p[u], null, p),
          class: t.model.getColorClassName({
            classNameTypes: [it.TOOLTIP],
            dataGroupName: p[u]
          })
        }))
      });
    }).on("mousemove", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEMOVE, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(T.Radar.X_AXIS_CLICK, {
        event: r,
        element: I(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      const s = I(this), a = t.parent.select(`.x-axes .x-axis-${Tr(i)}`), o = t.parent.selectAll(`.dots circle.${Tr(i)}`);
      a.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEOUT, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE);
    });
  }
}
class Mv extends uu {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({
      ariaLabel: "bar graphs",
      withinChartClip: !0
    }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getOrientation(), o = i.selectAll("path.bar").data(s, (l) => l[r]);
    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: l[r],
        originalClassName: "bar"
      })
    ).style("fill", (l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l);
      return this.model.getFillColor(l[r], l[c], l);
    }).attr("d", (l) => {
      const c = this.services.cartesianScales.getRangeIdentifier(), u = this.getBarWidth(), d = l[c], h = this.services.cartesianScales.getDomainValue(l) - u / 2, p = h + u;
      let f, g;
      if (Array.isArray(d) && d.length === 2)
        f = this.services.cartesianScales.getRangeValue(d[0]), g = this.services.cartesianScales.getRangeValue(d[1]);
      else {
        const v = this.services.cartesianScales.getRangeScale().domain()[0];
        f = this.services.cartesianScales.getRangeValue(Math.max(0, v)), g = this.services.cartesianScales.getRangeValue(l);
      }
      const m = Math.abs(g - f);
      if (m !== 0 && m < 2 && (d > 0 && a === Ft.VERTICAL || d < 0 && a === Ft.HORIZONTAL ? g = f - 2 : g = f + 2), !this.isOutsideZoomedDomain(h, p))
        return ae({ x0: h, x1: p, y0: f, y1: g }, a);
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, n = y(this.getOptions(), "tooltip", "alwaysShowRulerTooltip"), r = this.parent.selectAll("path.bar");
    n ? r.style("pointer-events", "none") : r.style("pointer-events", null), r.on("mouseover", function(i, s) {
      const a = I(this);
      a.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      }), n || t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        data: [s]
      });
    }).on("mousemove", function(i, s) {
      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: i,
        element: I(this),
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: i,
        element: I(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = I(this);
      a.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Vk extends ce {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = y(this.getOptions(), "data", "loading"), r = !y(this.getOptions(), "grid", "x", "enabled") && !y(this.getOptions(), "grid", "y", "enabled") && !y(this.getOptions(), "axes", "bottom", "visible") && !y(this.getOptions(), "axes", "left", "visible");
    n && !r ? super.renderGridSkeleton(n) : n && r ? this.renderSparklineSkeleton(n) : this.removeSkeleton();
  }
  renderSparklineSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(t) {
    const n = this.backdrop.attr("width"), r = [100], i = N.appendOrSelect(this.backdrop, "g.y.skeleton"), s = i.selectAll("line").data(r);
    s.enter().append("line").merge(s).attr("x1", 0).attr("x2", n).attr("y1", (a) => a).attr("y2", (a) => a), i.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const t = this.parent;
    this.backdrop = N.appendOrSelect(t, "svg.chart-skeleton.DAII").attr(
      "role",
      "presentation"
    ), N.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class Cv extends mt {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-area"
        })
      ).attr("opacity", (s) => y(s, 0, i) !== n.datum().name ? yn.opacity.unselected : yn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", yn.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "stacked area graphs",
      withinChartClip: !0
    }), r = this, i = this.getOptions(), { groupMapsTo: s } = i.data, a = Object.keys(i.axes).some((p) => i.axes[p].percentage), o = this.model.getStackedData({
      percentage: a,
      groups: this.configs.groups
    }), l = y(o, 0, 0), c = this.services.cartesianScales.getDomainAxisPosition({ datum: l }), u = this.services.cartesianScales.getRangeAxisPosition({ datum: l }), d = this.services.cartesianScales.getScaleByPosition(u), h = n.selectAll("path.area").data(o, (p) => y(p, 0, s));
    this.areaGenerator = su().x(
      (p) => this.services.cartesianScales.getValueThroughAxisPosition(
        c,
        p.data.sharedStackKey
      )
    ).y0((p) => d(p[0])).y1((p) => d(p[1])).curve(this.services.curves.getD3Curve()), h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).data(o, (p) => y(p, 0, s)).attr("class", "area").attr(
      "class",
      (p) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: y(p, 0, s),
        originalClassName: "area"
      })
    ).style("fill", (p) => r.model.getFillColor(y(p, 0, s), null, p)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (p) => y(p, 0, s)).transition().call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", yn.opacity.selected).attr("d", this.areaGenerator);
  }
}
class Av extends uu {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({ ariaLabel: "stacked bar graphs", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), a = this.model.getActiveDataGroupNames(), o = n.selectAll("g.bars").data(s, (c) => y(c, 0, i));
    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", ht.GROUP).attr("data-name", "bars");
    const l = n.selectAll("g.bars").selectAll("path.bar").data(
      (c) => c,
      (c) => c.data.sharedStackKey
    );
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: c[i],
        originalClassName: "bar"
      })
    ).style(
      "fill",
      (c) => this.model.getFillColor(c[i], c.data.sharedStackKey, c.data)
    ).attr("d", (c) => {
      const u = c.data.sharedStackKey, d = this.getBarWidth(), h = this.services.cartesianScales.getDomainValue(u) - d / 2, p = h + d, f = this.services.cartesianScales.getRangeValue(c[0]);
      let g = this.services.cartesianScales.getRangeValue(c[1]);
      if (!this.isOutsideZoomedDomain(h, p)) {
        if (Math.abs(g - f) > 0 && Math.abs(g - f) > r.bars.dividerSize) {
          const m = c[0] < 0 && c[1] <= 0;
          m && a.length > 1 ? this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? g += c[1] === 0 ? 2 : 1 : g -= 1 : m || (this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? g += 1 : g -= 1);
        }
        return ae(
          { x0: h, x1: p, y0: f, y1: g },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c[1] - c[0]), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = y(t, "tooltip", "alwaysShowRulerTooltip"), i = this.parent.selectAll("path.bar");
    r ? i.style("pointer-events", "none") : i.style("pointer-events", null);
    const s = this;
    i.on("mouseover", function(a, o) {
      const l = I(this);
      l.classed("hovered", !0), s.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: a,
        element: l,
        datum: o
      });
      let c = s.model.getDisplayData(s.configs.groups).find((u) => {
        const d = s.services.cartesianScales.getDomainIdentifier(u), h = s.services.cartesianScales.getRangeIdentifier(u);
        return u[h] === o.data[o[n]] && u[d].toString() === o.data.sharedStackKey && u[n] === o[n];
      });
      if (c === void 0) {
        const u = s.services.cartesianScales.getDomainIdentifier(), d = s.services.cartesianScales.getRangeIdentifier();
        c = {
          [u]: o.data.sharedStackKey,
          [d]: o.data[o[n]],
          [n]: o[n]
        };
      }
      r || s.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: l,
        data: [c]
      });
    }).on("mousemove", function(a, o) {
      const l = I(this);
      s.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: a,
        element: l,
        datum: o
      }), s.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, o) {
      s.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: a,
        element: I(this),
        datum: o
      });
    }).on("mouseout", function(a, o) {
      const l = I(this);
      l.classed("hovered", !1), s.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: a,
        element: l,
        datum: o
      }), s.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: l
      });
    });
  }
  getBarWidth() {
    const t = this.getOptions();
    if (y(t, "bars", "width"))
      return t.bars.width;
    const n = this.services.cartesianScales.getMainXScale(), r = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, i = this.model.getStackKeys().length, s = y(t, "bars", "spacingFactor");
    return n.step ? Math.min(t.bars.maxWidth, n.step() / 2) : Math.min(t.bars.maxWidth, r * s / i);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Lv extends nn {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = rt.SVG;
  }
  render(t) {
    if (!y(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ ariaLabel: "scatter points", withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((u) => r.axes[u].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: s
    }), o = n.selectAll("g.dots").data(a, (u) => y(u, 0, i));
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("dots", !0).attr("role", ht.GROUP).merge(o).selectAll("circle.dot").data((u) => u);
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l).datum((u) => {
      const d = u[i], h = this.services.cartesianScales.getDomainIdentifier(u), p = this.services.cartesianScales.getRangeIdentifier(u);
      return {
        [i]: d,
        [h]: u.data.sharedStackKey,
        [p]: u[1]
      };
    });
    this.styleCircles(c, t), this.addEventListeners();
  }
  getTooltipData(t, n) {
    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((l) => r.axes[l].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: s
    }), o = [];
    return a.forEach((l, c) => {
      l.forEach((u, d) => {
        const h = u[i], p = u.data.sharedStackKey;
        let f = u.data[h];
        const g = u[1], m = this.services.cartesianScales.getDomainIdentifier(u), v = this.services.cartesianScales.getRangeIdentifier(u);
        f != null && t === this.services.cartesianScales.getDomainValue(p) && n === this.services.cartesianScales.getRangeValue(g) && (s && (f = this.model.getStackedData({
          groups: this.configs.groups
        })[c][d].data[h]), f !== null && o.push({
          [i]: h,
          [m]: p,
          [v]: f
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l), u = this.services.cartesianScales.getRangeIdentifier(l);
      return o.find((d) => d[i] == l[i] && d[c] == l[c] && d[u] == l[u]) !== void 0;
    });
  }
}
const Cr = 6;
class Gk extends mt {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = rt.SVG;
  }
  getLongestLabel(t) {
    let n = "";
    return t.forEach((r) => {
      const i = r.children ? this.getLongestLabel(r.children) : "";
      (i.length > n.length || r.name.length > n.length) && (n = i.length > r.name.length ? i : r.name);
    }), n;
  }
  getMockLabelWidth(t, n) {
    const r = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(n), { width: i } = N.getSVGElementSize(r.node(), {
      useBBox: !0
    });
    return r.remove(), i;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "tree diagram"
    });
    n.html("");
    const { width: r, height: i } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = y(s, "tree", "rootTitle") || "Tree", l = this.getMockLabelWidth(n, o), c = this.getLongestLabel(a), u = this.getMockLabelWidth(n, c), d = {
      left: l > 0 ? l + Cr : 30 - Cr
    }, h = xs({
      name: o,
      children: a
    }), p = 10, f = r / 6, g = (S) => {
      const $ = h.descendants().reverse(), D = h.links();
      let C = h, R = h;
      h.eachBefore((k) => {
        k.x < C.x && (C = k), k.x > R.x && (R = k);
      });
      const M = R.x - C.x, H = n.transition().call(
        (k) => this.services.transitions.setupTransition({
          transition: k,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-d.left, C.x, r, M].join(" ")), P = x.selectAll("g").data($, (k) => k.id), B = this, O = P.enter().append("g").attr("transform", () => `translate(${S.y0},${S.x0})`).attr(
        "class",
        (k) => k.depth !== 0 && k.children && k.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(k, U) {
        B.services.events.dispatchEvent(T.Tree.NODE_MOUSEOVER, {
          event: k,
          element: I(this),
          datum: U
        });
      }).on("click", function(k, U) {
        U.depth !== 0 && (U.children = U.children ? null : U._children, g(U)), B.services.events.dispatchEvent(T.Tree.NODE_CLICK, {
          event: k,
          element: I(this),
          datum: U
        });
      }).on("mouseout", function(k, U) {
        B.services.events.dispatchEvent(T.Tree.NODE_MOUSEOUT, {
          event: k,
          element: I(this),
          datum: U
        });
      });
      O.append("circle").attr("r", 2.5).attr("class", (k) => k._children ? "parent" : "child").attr("stroke-width", 10), O.append("text").attr("dy", "0.31em").attr("x", (k) => k._children ? -Cr : Cr).attr("text-anchor", (k) => k._children ? "end" : "start").text((k) => k.data.name).clone(!0).attr("class", "text-stroke").lower(), P.merge(O).transition(H).attr("transform", (k) => `translate(${k.y},${k.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), P.exit().transition(H).remove().attr("transform", () => `translate(${S.y},${S.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const w = E.selectAll("path").data(D, (k) => k.target.id), L = w.enter().append("path").attr("d", () => {
        const k = { x: S.x0, y: S.y0 };
        return _({ source: k, target: k });
      });
      w.merge(L).transition(H).attr("d", _), w.exit().transition(H).remove().attr("d", () => {
        const k = { x: S.x, y: S.y };
        return _({ source: k, target: k });
      }), h.eachBefore((k) => {
        k.x0 = k.x, k.y0 = k.y;
      });
    }, m = h.descendants(), v = m[m.length - 1].depth, b = y(s, "tree", "type") === dc.DENDROGRAM ? aL().size([
      i,
      r - u - v * Cr - l
    ]) : qL().nodeSize([p, f]).size([
      i,
      r - u - v * Cr - l
    ]), _ = gD().x((S) => S.y).y((S) => S.x);
    h.x0 = f / 2, h.y0 = 0, h.descendants().forEach((S, $) => {
      S.id = $, S._children = S.children;
    }), b(h), n.attr("viewBox", [-d.left, -0, r, p]).style("user-select", "none");
    const E = n.append("g").attr("class", "links"), x = n.append("g").attr("class", "nodes");
    g(h);
  }
}
var zk = "#000000", Fk = "#ffffff", jk = "#fcf4d6", Wk = "#fddc69", qk = "#f1c21b", Yk = "#d2a106", Xk = "#b28600", Zk = "#8e6a00", Kk = "#684e00", Qk = "#483700", Jk = "#302400", tR = "#1c1500", eR = {
  10: jk,
  20: Wk,
  30: qk,
  40: Yk,
  50: Xk,
  60: Zk,
  70: Kk,
  80: Qk,
  90: Jk,
  100: tR
}, nR = "#fff2e8", rR = "#ffd9be", iR = "#ffb784", sR = "#ff832b", aR = "#eb6200", oR = "#ba4e00", lR = "#8a3800", cR = "#5e2900", uR = "#3e1a00", hR = "#231000", dR = {
  10: nR,
  20: rR,
  30: iR,
  40: sR,
  50: aR,
  60: oR,
  70: lR,
  80: cR,
  90: uR,
  100: hR
}, pR = "#fff1f1", fR = "#ffd7d9", mR = "#ffb3b8", gR = "#ff8389", vR = "#fa4d56", yR = "#da1e28", xR = "#a2191f", bR = "#750e13", _R = "#520408", ER = "#2d0709", OR = {
  10: pR,
  20: fR,
  30: mR,
  40: gR,
  50: vR,
  60: yR,
  70: xR,
  80: bR,
  90: _R,
  100: ER
}, SR = "#fff0f7", TR = "#ffd6e8", wR = "#ffafd2", $R = "#ff7eb6", MR = "#ee5396", CR = "#d02670", AR = "#9f1853", LR = "#740937", DR = "#510224", kR = "#2a0a18", RR = {
  10: SR,
  20: TR,
  30: wR,
  40: $R,
  50: MR,
  60: CR,
  70: AR,
  80: LR,
  90: DR,
  100: kR
}, IR = "#f6f2ff", NR = "#e8daff", PR = "#d4bbff", UR = "#be95ff", BR = "#a56eff", HR = "#8a3ffc", VR = "#6929c4", GR = "#491d8b", zR = "#31135e", FR = "#1c0f30", jR = {
  10: IR,
  20: NR,
  30: PR,
  40: UR,
  50: BR,
  60: HR,
  70: VR,
  80: GR,
  90: zR,
  100: FR
}, WR = "#edf5ff", qR = "#d0e2ff", YR = "#a6c8ff", XR = "#78a9ff", ZR = "#4589ff", KR = "#0f62fe", QR = "#0043ce", JR = "#002d9c", tI = "#001d6c", eI = "#001141", nI = {
  10: WR,
  20: qR,
  30: YR,
  40: XR,
  50: ZR,
  60: KR,
  70: QR,
  80: JR,
  90: tI,
  100: eI
}, rI = "#e5f6ff", iI = "#bae6ff", sI = "#82cfff", aI = "#33b1ff", oI = "#1192e8", lI = "#0072c3", cI = "#00539a", uI = "#003a6d", hI = "#012749", dI = "#061727", pI = {
  10: rI,
  20: iI,
  30: sI,
  40: aI,
  50: oI,
  60: lI,
  70: cI,
  80: uI,
  90: hI,
  100: dI
}, fI = "#d9fbfb", mI = "#9ef0f0", gI = "#3ddbd9", vI = "#08bdba", yI = "#009d9a", xI = "#007d79", bI = "#005d5d", _I = "#004144", EI = "#022b30", OI = "#081a1c", SI = {
  10: fI,
  20: mI,
  30: gI,
  40: vI,
  50: yI,
  60: xI,
  70: bI,
  80: _I,
  90: EI,
  100: OI
}, TI = "#defbe6", wI = "#a7f0ba", $I = "#6fdc8c", MI = "#42be65", CI = "#24a148", AI = "#198038", LI = "#0e6027", DI = "#044317", kI = "#022d0d", RI = "#071908", II = {
  10: TI,
  20: wI,
  30: $I,
  40: MI,
  50: CI,
  60: AI,
  70: LI,
  80: DI,
  90: kI,
  100: RI
}, NI = "#f2f4f8", PI = "#dde1e6", UI = "#c1c7cd", BI = "#a2a9b0", HI = "#878d96", VI = "#697077", GI = "#4d5358", zI = "#343a3f", FI = "#21272a", jI = "#121619", WI = {
  10: NI,
  20: PI,
  30: UI,
  40: BI,
  50: HI,
  60: VI,
  70: GI,
  80: zI,
  90: FI,
  100: jI
}, qI = "#f4f4f4", YI = "#e0e0e0", XI = "#c6c6c6", ZI = "#a8a8a8", KI = "#8d8d8d", QI = "#6f6f6f", JI = "#525252", tN = "#393939", eN = "#262626", nN = "#161616", rN = {
  10: qI,
  20: YI,
  30: XI,
  40: ZI,
  50: KI,
  60: QI,
  70: JI,
  80: tN,
  90: eN,
  100: nN
}, iN = "#f7f3f2", sN = "#e5e0df", aN = "#cac5c4", oN = "#ada8a8", lN = "#8f8b8b", cN = "#726e6e", uN = "#565151", hN = "#3c3838", dN = "#272525", pN = "#171414", fN = {
  10: iN,
  20: sN,
  30: aN,
  40: oN,
  50: lN,
  60: cN,
  70: uN,
  80: hN,
  90: dN,
  100: pN
}, gp = {
  black: {
    100: zk
  },
  blue: nI,
  coolGray: WI,
  cyan: pI,
  gray: rN,
  green: II,
  magenta: RR,
  orange: dR,
  purple: jR,
  red: OR,
  teal: SI,
  warmGray: fN,
  white: {
    0: Fk
  },
  yellow: eR
};
const mN = (e) => {
  if (!e)
    return null;
  for (const t of Object.keys(gp)) {
    const n = gp[t];
    for (const r of Object.keys(n))
      if (n[+r] === e)
        return r;
  }
  return null;
}, vp = function(e) {
  const t = I(this.parentNode).select("rect.leaf"), n = e.backgroundColor ?? getComputedStyle(t.node(), null).getPropertyValue("fill"), r = Tn(n);
  let i;
  if (r && (i = mN(r ? r.hex() : null)), i == null) {
    const s = om(r).l;
    i = Math.abs(s * 100 - 100);
  }
  return i > 50 ? "white" : "black";
};
let gN = 0;
class vN extends mt {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (r) => r.parent.data.name === n.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({
      ariaLabel: "treemap"
    });
    this.model.getData();
    const r = this.model.getDisplayData(), i = this.model.getOptions(), s = y(window, "location"), { width: a, height: o } = N.getSVGElementSize(n, {
      useAttrs: !0
    }), l = xs({
      name: i.title || "Treemap",
      children: r
    }).sum((p) => p.value).sort((p, f) => f.value - p.value), c = QL().size([a, o]).paddingInner(1).paddingOuter(0).round(!0)(
      l
    ), u = n.selectAll("g[data-name='leaf']").data(c.leaves(), (p) => p.data.name);
    u.exit().attr("opacity", 0).remove();
    const d = u.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => gN++).merge(u);
    d.attr("data-name", "leaf").transition().call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "treemap-group-update",
        animate: t
      })
    ).attr("transform", (p) => `translate(${p.x0},${p.y0})`);
    const h = d.selectAll("rect.leaf").data((p) => [p]);
    h.exit().attr("width", 0).attr("height", 0).remove(), h.enter().append("rect").classed("leaf", !0).merge(h).attr("width", 0).attr("height", 0).attr("id", function() {
      const p = I(this.parentNode).attr("data-uid");
      return `${i.style.prefix}-leaf-${p}`;
    }).attr("class", (p) => {
      for (; p.depth > 1; ) p = p.parent;
      return this.model.getColorClassName({
        classNameTypes: [it.FILL],
        dataGroupName: p.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "treemap-leaf-update-enter",
        animate: t
      })
    ).attr("width", (p) => p.x1 - p.x0).attr("height", (p) => p.y1 - p.y0).style("fill", (p) => {
      for (; p.depth > 1; ) p = p.parent;
      return this.model.getFillColor(p.data.name, null, p.data);
    }), d.selectAll("clipPath").data(
      (p) => p.data.showLabel !== !0 ? [] : [1],
      (p) => p
    ).join(
      (p) => p.append("clipPath").attr("id", function() {
        const f = I(this.parentNode).attr("data-uid");
        return `${i.style.prefix}-clip-${f}`;
      }).append("use").attr("xlink:href", function() {
        const f = I(this.parentNode.parentNode).attr("data-uid"), g = `${i.style.prefix}-leaf-${f}`;
        return new URL(`#${g}`, s) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (p) => null,
      (p) => p.remove()
    ), d.selectAll("text").data(
      (p) => {
        if (p.data.showLabel !== !0)
          return [];
        let f = p;
        for (; f.depth > 1; ) f = f.parent;
        return [
          {
            text: p.data.name,
            backgroundColor: this.model.getFillColor(f.data.name)
          }
        ];
      },
      (p) => p
    ).join(
      (p) => {
        const f = p.append("text").text((g) => g.text).style("fill", vp).attr("x", 7).attr("y", 18);
        return s && f.attr("clip-path", function() {
          const g = I(this.parentNode).attr("data-uid"), m = `${i.style.prefix}-clip-${g}`;
          return `url(${new URL(`#${m}`, s) + ""})`;
        }), f;
      },
      (p) => p.text((f) => f.text).style("fill", vp),
      (p) => p.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(n, r) {
      const i = I(this);
      let s = getComputedStyle(this, null).getPropertyValue("fill"), a = r;
      for (; a.depth > 1; ) a = a.parent;
      i.transition("graph_element_mouseover_fill_update").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (o) => {
        const l = t.model.getFillColor(o.parent.data.name, null, o.data);
        return l && (s = l), Tn(s).darker(0.7).toString();
      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            color: s,
            label: a.data.name,
            bold: !0
          },
          {
            label: r.data.name,
            value: r.data.value
          }
        ]
      }), t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(T.Treemap.LEAF_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      i.classed("hovered", !1);
      let s = r;
      for (; s.depth > 1; ) s = s.parent;
      i.transition().call(
        (a) => t.services.transitions.setupTransition({
          transition: a,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (a) => t.model.getFillColor(a.parent.data.name, null, a.data)), t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
}
function yN(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xN(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      var i = !1;
      try {
        i = this instanceof r;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var bN = { value: function() {
} };
function Dv() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new sa(n);
}
function sa(e) {
  this._ = e;
}
function _N(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
sa.prototype = Dv.prototype = {
  constructor: sa,
  on: function(e, t) {
    var n = this._, r = _N(e + "", n), i, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; ) if ((i = (e = r[s]).type) && (i = EN(n[i], e.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (i = (e = r[s]).type) n[i] = yp(n[i], e.name, t);
      else if (t == null) for (i in n) n[i] = yp(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new sa(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, s; r < i; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r) s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i) r[i].value.apply(t, n);
  }
};
function EN(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function yp(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = bN, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
const ON = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispatch: Dv
}, Symbol.toStringTag, { value: "Module" })), SN = /* @__PURE__ */ xN(ON);
var cl, xp;
function TN() {
  if (xp) return cl;
  xp = 1;
  const e = SN.dispatch, t = Math.PI / 180, n = {
    archimedean: g,
    rectangular: m
  }, r = 64, i = 2048;
  cl = function() {
    var E = [256, 256], x = s, S = a, $ = l, D = o, C = o, R = c, M = u, H = g, P = [], B = 1 / 0, O = e("word", "end"), w = null, L = Math.random, k = {}, U = b;
    k.canvas = function(F) {
      return arguments.length ? (U = _(F), k) : U;
    }, k.start = function() {
      var F = Z(U()), Y = v((E[0] >> 5) * E[1]), ot = null, Q = P.length, q = -1, tt = [], lt = P.map(function(W, X) {
        return W.text = x.call(this, W, X), W.font = S.call(this, W, X), W.style = D.call(this, W, X), W.weight = C.call(this, W, X), W.rotate = R.call(this, W, X), W.size = ~~$.call(this, W, X), W.padding = M.call(this, W, X), W;
      }).sort(function(W, X) {
        return X.size - W.size;
      });
      return w && clearInterval(w), w = setInterval(z, 0), z(), k;
      function z() {
        for (var W = Date.now(); Date.now() - W < B && ++q < Q && w; ) {
          var X = lt[q];
          X.x = E[0] * (L() + 0.5) >> 1, X.y = E[1] * (L() + 0.5) >> 1, d(F, X, lt, q), X.hasText && j(Y, X, ot) && (tt.push(X), O.call("word", k, X), ot ? p(ot, X) : ot = [{ x: X.x + X.x0, y: X.y + X.y0 }, { x: X.x + X.x1, y: X.y + X.y1 }], X.x -= E[0] >> 1, X.y -= E[1] >> 1);
        }
        q >= Q && (k.stop(), O.call("end", k, tt, ot));
      }
    }, k.stop = function() {
      w && (clearInterval(w), w = null);
      for (const F of P)
        delete F.sprite;
      return k;
    };
    function Z(F) {
      const Y = F.getContext("2d", { willReadFrequently: !0 });
      F.width = F.height = 1;
      const ot = Math.sqrt(Y.getImageData(0, 0, 1, 1).data.length >> 2);
      return F.width = (r << 5) / ot, F.height = i / ot, Y.fillStyle = Y.strokeStyle = "red", { context: Y, ratio: ot };
    }
    function j(F, Y, ot) {
      E[0], E[1];
      for (var Q = Y.x, q = Y.y, tt = Math.sqrt(E[0] * E[0] + E[1] * E[1]), lt = H(E), z = L() < 0.5 ? 1 : -1, W = -z, X, V, ut; (X = lt(W += z)) && (V = ~~X[0], ut = ~~X[1], !(Math.min(Math.abs(V), Math.abs(ut)) >= tt)); )
        if (Y.x = Q + V, Y.y = q + ut, !(Y.x + Y.x0 < 0 || Y.y + Y.y0 < 0 || Y.x + Y.x1 > E[0] || Y.y + Y.y1 > E[1]) && (!ot || f(Y, ot)) && !h(Y, F, E[0])) {
          for (var st = Y.sprite, kt = Y.width >> 5, Nt = E[0] >> 5, nt = Y.x - (kt << 4), yt = nt & 127, Se = 32 - yt, ge = Y.y1 - Y.y0, ci = (Y.y + Y.y0) * Nt + (nt >> 5), ui, Fn = 0; Fn < ge; Fn++) {
            ui = 0;
            for (var Ie = 0; Ie <= kt; Ie++)
              F[ci + Ie] |= ui << Se | (Ie < kt ? (ui = st[Fn * kt + Ie]) >>> yt : 0);
            ci += Nt;
          }
          return !0;
        }
      return !1;
    }
    return k.timeInterval = function(F) {
      return arguments.length ? (B = F ?? 1 / 0, k) : B;
    }, k.words = function(F) {
      return arguments.length ? (P = F, k) : P;
    }, k.size = function(F) {
      return arguments.length ? (E = [+F[0], +F[1]], k) : E;
    }, k.font = function(F) {
      return arguments.length ? (S = _(F), k) : S;
    }, k.fontStyle = function(F) {
      return arguments.length ? (D = _(F), k) : D;
    }, k.fontWeight = function(F) {
      return arguments.length ? (C = _(F), k) : C;
    }, k.rotate = function(F) {
      return arguments.length ? (R = _(F), k) : R;
    }, k.text = function(F) {
      return arguments.length ? (x = _(F), k) : x;
    }, k.spiral = function(F) {
      return arguments.length ? (H = n[F] || F, k) : H;
    }, k.fontSize = function(F) {
      return arguments.length ? ($ = _(F), k) : $;
    }, k.padding = function(F) {
      return arguments.length ? (M = _(F), k) : M;
    }, k.random = function(F) {
      return arguments.length ? (L = F, k) : L;
    }, k.on = function() {
      var F = O.on.apply(O, arguments);
      return F === O ? k : F;
    }, k;
  };
  function s(E) {
    return E.text;
  }
  function a() {
    return "serif";
  }
  function o() {
    return "normal";
  }
  function l(E) {
    return Math.sqrt(E.value);
  }
  function c() {
    return (~~(random() * 6) - 3) * 30;
  }
  function u() {
    return 1;
  }
  function d(E, x, S, $) {
    if (!x.sprite) {
      var D = E.context, C = E.ratio;
      D.clearRect(0, 0, (r << 5) / C, i / C);
      var R = 0, M = 0, H = 0, P = S.length;
      for (--$; ++$ < P; ) {
        x = S[$], D.save(), D.font = x.style + " " + x.weight + " " + ~~((x.size + 1) / C) + "px " + x.font;
        const X = D.measureText(x.text), V = -Math.floor(X.width / 2);
        let ut = (X.width + 1) * C, st = x.size << 1;
        if (x.rotate) {
          var B = Math.sin(x.rotate * t), O = Math.cos(x.rotate * t), w = ut * O, L = ut * B, k = st * O, U = st * B;
          ut = Math.max(Math.abs(w + U), Math.abs(w - U)) + 31 >> 5 << 5, st = ~~Math.max(Math.abs(L + k), Math.abs(L - k));
        } else
          ut = ut + 31 >> 5 << 5;
        if (st > H && (H = st), R + ut >= r << 5 && (R = 0, M += H, H = 0), M + st >= i) break;
        D.translate((R + (ut >> 1)) / C, (M + (st >> 1)) / C), x.rotate && D.rotate(x.rotate * t), D.fillText(x.text, V, 0), x.padding && (D.lineWidth = 2 * x.padding, D.strokeText(x.text, V, 0)), D.restore(), x.width = ut, x.height = st, x.xoff = R, x.yoff = M, x.x1 = ut >> 1, x.y1 = st >> 1, x.x0 = -x.x1, x.y0 = -x.y1, x.hasText = !0, R += ut;
      }
      for (var Z = D.getImageData(0, 0, (r << 5) / C, i / C).data, j = []; --$ >= 0; )
        if (x = S[$], !!x.hasText) {
          for (var F = x.width, Y = F >> 5, ot = x.y1 - x.y0, Q = 0; Q < ot * Y; Q++) j[Q] = 0;
          if (R = x.xoff, R == null) return;
          M = x.yoff;
          for (var q = 0, tt = -1, lt = 0; lt < ot; lt++) {
            for (var Q = 0; Q < F; Q++) {
              var z = Y * lt + (Q >> 5), W = Z[(M + lt) * (r << 5) + (R + Q) << 2] ? 1 << 31 - Q % 32 : 0;
              j[z] |= W, q |= W;
            }
            q ? tt = lt : (x.y0++, ot--, lt--, M++);
          }
          x.y1 = x.y0 + tt, x.sprite = j.slice(0, (x.y1 - x.y0) * Y);
        }
    }
  }
  function h(E, x, S) {
    S >>= 5;
    for (var $ = E.sprite, D = E.width >> 5, C = E.x - (D << 4), R = C & 127, M = 32 - R, H = E.y1 - E.y0, P = (E.y + E.y0) * S + (C >> 5), B, O = 0; O < H; O++) {
      B = 0;
      for (var w = 0; w <= D; w++)
        if ((B << M | (w < D ? (B = $[O * D + w]) >>> R : 0)) & x[P + w]) return !0;
      P += S;
    }
    return !1;
  }
  function p(E, x) {
    var S = E[0], $ = E[1];
    x.x + x.x0 < S.x && (S.x = x.x + x.x0), x.y + x.y0 < S.y && (S.y = x.y + x.y0), x.x + x.x1 > $.x && ($.x = x.x + x.x1), x.y + x.y1 > $.y && ($.y = x.y + x.y1);
  }
  function f(E, x) {
    return E.x + E.x1 > x[0].x && E.x + E.x0 < x[1].x && E.y + E.y1 > x[0].y && E.y + E.y0 < x[1].y;
  }
  function g(E) {
    var x = E[0] / E[1];
    return function(S) {
      return [x * (S *= 0.1) * Math.cos(S), S * Math.sin(S)];
    };
  }
  function m(E) {
    var x = 4, S = x * E[0] / E[1], $ = 0, D = 0;
    return function(C) {
      var R = C < 0 ? -1 : 1;
      switch (Math.sqrt(1 + 4 * R * C) - R & 3) {
        case 0:
          $ += S;
          break;
        case 1:
          D += x;
          break;
        case 2:
          $ -= S;
          break;
        default:
          D -= x;
          break;
      }
      return [$, D];
    };
  }
  function v(E) {
    for (var x = [], S = -1; ++S < E; ) x[S] = 0;
    return x;
  }
  function b() {
    return document.createElement("canvas");
  }
  function _(E) {
    return typeof E == "function" ? E : function() {
      return E;
    };
  }
  return cl;
}
var wN = TN();
const $N = /* @__PURE__ */ yN(wN);
class MN extends mt {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer({
      ariaLabel: "word cloud"
    }).attr("width", "100%").attr("height", "100%"), i = this.model.getDisplayData(), s = this.getFontSizeScale(i), a = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: l } = a.wordCloud, { groupMapsTo: c } = a.data, { width: u, height: d } = N.getSVGElementSize(r, {
      useAttrs: !0
    });
    if (u === 0 || d === 0)
      return;
    const h = $N().size([u, d]).words(
      i.map(function(f) {
        const g = f[o];
        if (typeof f[o] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [c]: f[c],
          text: f[l],
          size: g,
          value: g
        };
      })
    ).padding(5).rotate(0).fontSize((f) => s(f.size)).on("end", p);
    h.start();
    function p(f) {
      const g = N.appendOrSelect(r, "g.words");
      g.attr("transform", `translate(${h.size()[0] / 2}, ${h.size()[1] / 2})`);
      const m = g.selectAll("text").data(f, (v) => `${v[c]}-${v.text}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("text").attr("opacity", 0).merge(m).style("font-size", (v) => `${v.size}px`).text(function(v) {
        return v.text;
      }).attr(
        "class",
        (v) => n.model.getColorClassName({
          classNameTypes: [it.FILL],
          dataGroupName: v[c],
          originalClassName: `word ${v.size > 32 ? "light" : ""}`
        })
      ).style("fill", (v) => n.model.getFillColor(v[c], v.text, v)).attr("text-anchor", "middle").transition().call(
        (v) => n.services.transitions.setupTransition({
          transition: v,
          name: "wordcloud-text-update-enter",
          animate: t
        })
      ).attr("transform", (v) => `translate(${v.x}, ${v.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(t) {
    const n = this.getOptions(), { fontSizeMapsTo: r } = n.wordCloud, i = t.map((l) => l[r]).filter((l) => l), s = N.getHTMLElementSize(this.services.domUtils.getMainContainer()), a = i.length > 0, o = a ? ze(i) : [1, 1];
    return Fe().domain(o).range(a ? n.wordCloud.fontSizeRange(s, t) : [4, 4]);
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = ba((s) => {
      const a = r.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (o) => r.services.transitions.setupTransition({
          transition: o,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      s === null ? a.attr("opacity", 1) : a.attr("opacity", function() {
        return s === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(s, a) {
      const o = this;
      i(o), r.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEOVER, {
        event: s,
        element: I(this),
        datum: a
      }), r.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: t.tooltip.wordLabel,
            value: a.text
          },
          {
            label: t.tooltip.valueLabel,
            value: a.value
          },
          {
            label: gt(t, "locale.translations.group") || gt(t, "tooltip.groupLabel") || "Group",
            value: a[n],
            class: r.model.getColorClassName({
              classNameTypes: [it.TOOLTIP],
              dataGroupName: a[n]
            })
          }
        ]
      });
    }).on("mousemove", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEMOVE, {
        element: o,
        datum: a
      }), r.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      r.services.events.dispatchEvent(T.WordCloud.WORD_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      i(null), r.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), r.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class CN extends mt {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = rt.SVG;
  }
  render() {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: n, height: r } = N.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (n < 1 || r < 1)
      return;
    const i = this.getProjection(), s = y(this.getOptions(), "geoData"), a = this.model.getCombinedData(), o = {}, l = {};
    Object.keys(a).forEach((m) => {
      typeof a[m].value == "number" ? o[m] = a[m] : l[m] = a[m];
    });
    const c = _k(s, Object.values(l)), u = yk(s, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(o)
    }), d = i.fitSize([n, r], u), h = DA().projection(d);
    N.appendOrSelect(t, "g.geo").selectAll("path").data(u.features).join("path").attr("d", h);
    const p = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), f = N.appendOrSelect(t, "defs");
    N.appendOrSelect(f, "pattern").attr("id", p).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      bs()([
        [0, 0],
        [0, 10]
      ])
    );
    const g = N.appendOrSelect(t, "g.missing-data");
    N.appendOrSelect(g, "path").datum(c).attr("d", h).style("fill", `url(#${p})`);
  }
  /**
   * Retrieves the D3 geographic projection based on the options provided.
   *
   * This method selects a geographic projection from the available D3 projections
   * based on the `projection` property in the `thematic` options. If the projection
   * is not supported or is missing, an error is thrown.
   *
   * @returns {d3.GeoProjection} - The D3 geographic projection corresponding to the selected option.
   * @throws {Error} If the projection is not supported or is missing.
   */
  getProjection() {
    let t = null;
    switch (y(this.getOptions(), "thematic", "projection")) {
      // Azimuthal Projections
      case gn.geoEqualEarth:
        t = KA();
        break;
      // Conic Projections
      case gn.geoAlbers:
        t = FA();
        break;
      case gn.geoConicEqualArea:
        t = ev();
        break;
      case gn.geoConicEquidistant:
        t = XA();
        break;
      // Cyndrical projections
      case gn.geoEquirectangular:
        t = qA();
        break;
      case gn.geoMercator:
        t = jA();
        break;
      case gn.geoNaturalEarth1:
        t = QA();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return t;
  }
}
class AN extends CN {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    super.render();
    const n = this.model.getCombinedData(), r = this.getComponentContainer({ ariaLabel: "map", withinChartClip: !0 }), i = y(this.getOptions(), "color"), s = y(i, "gradient", "colors");
    r.select("g.geo").selectAll("path").classed("border", !0).attr("class", (a) => this.model.getColorClassName({
      value: n[a.properties.NAME].value,
      originalClassName: "border"
    })).attr("style", (a) => s ? `fill: ${this.model.getColorClassName({
      value: n[a.properties.NAME].value
    })}` : null), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const t = this, n = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(Rr.CHOROPLETH_MOUSEOVER, {
        event: r,
        element: s,
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(Pi.SHOW, {
        event: r,
        hoveredElement: s,
        items: [
          {
            label: i.properties.NAME,
            value: n[i.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(r, i) {
      t.services.events.dispatchEvent(Rr.CHOROPLETH_MOUSEMOVE, {
        event: r,
        element: I(this),
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(Pi.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(Rr.CHOROPLETH_CLICK, {
        event: r,
        element: I(this),
        datum: n[i.properties.NAME]
      });
    }).on("mouseout", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(Rr.CHOROPLETH_MOUSEOUT, {
        event: r,
        element: s,
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(Pi.HIDE, {
        event: r,
        hoveredElement: s
      });
    });
  }
}
function hu(e) {
  var t = e == null ? 0 : e.length;
  return t ? Ka(e, 1) : [];
}
function LN(e) {
  return gf(yf(e, void 0, hu), e + "");
}
function kv(e, t, n) {
  var r = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var s = Array(i); ++r < i; )
    s[r] = e[r + t];
  return s;
}
function DN(e, t) {
  return t.length < 2 ? e : Ec(e, kv(t, 0, -1));
}
function kN(e, t) {
  return t = Za(t, e), e = DN(e, t), e == null || delete e[ps(jf(t))];
}
function RN(e) {
  return wf(e) ? void 0 : e;
}
var IN = 1, NN = 2, PN = 4, UN = LN(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var r = !1;
  t = pc(t, function(s) {
    return s = Za(s, e), r || (r = s.length > 1), s;
  }), si(e, Df(e), n), r && (n = Vi(n, IN | NN | PN, RN));
  for (var i = t.length; i--; )
    kN(n, t[i]);
  return n;
});
function bp(e) {
  return Math.log(e);
}
function _p(e) {
  return Math.exp(e);
}
function BN(e) {
  return -Math.log(-e);
}
function HN(e) {
  return -Math.exp(-e);
}
function VN(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function GN(e) {
  return e === 10 ? VN : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function zN(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Ep(e) {
  return (t, n) => -e(-t, n);
}
function FN(e) {
  const t = e(bp, _p), n = t.domain;
  let r = 10, i, s;
  function a() {
    return i = zN(r), s = GN(r), n()[0] < 0 ? (i = Ep(i), s = Ep(s), e(BN, HN)) : e(bp, _p), t;
  }
  return t.base = function(o) {
    return arguments.length ? (r = +o, a()) : r;
  }, t.domain = function(o) {
    return arguments.length ? (n(o), a()) : n();
  }, t.ticks = (o) => {
    const l = n();
    let c = l[0], u = l[l.length - 1];
    const d = u < c;
    d && ([c, u] = [u, c]);
    let h = i(c), p = i(u), f, g;
    const m = o == null ? 10 : +o;
    let v = [];
    if (!(r % 1) && p - h < m) {
      if (h = Math.floor(h), p = Math.ceil(p), c > 0) {
        for (; h <= p; ++h)
          for (f = 1; f < r; ++f)
            if (g = h < 0 ? f / s(-h) : f * s(h), !(g < c)) {
              if (g > u) break;
              v.push(g);
            }
      } else for (; h <= p; ++h)
        for (f = r - 1; f >= 1; --f)
          if (g = h > 0 ? f / s(-h) : f * s(h), !(g < c)) {
            if (g > u) break;
            v.push(g);
          }
      v.length * 2 < m && (v = ca(c, u, m));
    } else
      v = ca(h, p, Math.min(p - h, m)).map(s);
    return d ? v.reverse() : v;
  }, t.tickFormat = (o, l) => {
    if (o == null && (o = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = ns(l)).precision == null && (l.trim = !0), l = Bc(l)), o === 1 / 0) return l;
    const c = Math.max(1, r * o / t.ticks().length);
    return (u) => {
      let d = u / s(Math.round(i(u)));
      return d * r < r - 0.5 && (d *= r), d <= c ? l(u) : "";
    };
  }, t.nice = () => n(qm(n(), {
    floor: (o) => s(Math.floor(i(o))),
    ceil: (o) => s(Math.ceil(i(o)))
  })), t;
}
function Rv() {
  const e = FN(Sm()).domain([1, 10]);
  return e.copy = () => Hc(e, Rv()).base(e.base()), ai.apply(e, arguments), e;
}
function Ba(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function go(e) {
  this._context = e;
}
go.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Ba(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        Ba(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function jN(e) {
  return new go(e);
}
function Iv(e) {
  this._context = e;
}
Iv.prototype = {
  areaStart: Hn,
  areaEnd: Hn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        Ba(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function WN(e) {
  return new Iv(e);
}
function Nv(e) {
  this._context = e;
}
Nv.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Ba(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function qN(e) {
  return new Nv(e);
}
function Pv(e, t) {
  this._basis = new go(e), this._beta = t;
}
Pv.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], s = e[n] - r, a = t[n] - i, o = -1, l; ++o <= n; )
        l = o / n, this._basis.point(
          this._beta * e[o] + (1 - this._beta) * (r + l * s),
          this._beta * t[o] + (1 - this._beta) * (i + l * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const YN = function e(t) {
  function n(r) {
    return t === 1 ? new go(r) : new Pv(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function Ha(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function du(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
du.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Ha(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        Ha(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const XN = function e(t) {
  function n(r) {
    return new du(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function pu(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
pu.prototype = {
  areaStart: Hn,
  areaEnd: Hn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Ha(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const ZN = function e(t) {
  function n(r) {
    return new pu(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function fu(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
fu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Ha(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const KN = function e(t) {
  function n(r) {
    return new fu(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function mu(e, t, n) {
  var r = e._x1, i = e._y1, s = e._x2, a = e._y2;
  if (e._l01_a > ne) {
    var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, i = (i * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
  }
  if (e._l23_a > ne) {
    var c = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * c + e._x1 * e._l23_2a - t * e._l12_2a) / u, a = (a * c + e._y1 * e._l23_2a - n * e._l12_2a) / u;
  }
  e._context.bezierCurveTo(r, i, s, a, e._x2, e._y2);
}
function Uv(e, t) {
  this._context = e, this._alpha = t;
}
Uv.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        mu(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const QN = function e(t) {
  function n(r) {
    return t ? new Uv(r, t) : new du(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Bv(e, t) {
  this._context = e, this._alpha = t;
}
Bv.prototype = {
  areaStart: Hn,
  areaEnd: Hn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        mu(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const JN = function e(t) {
  function n(r) {
    return t ? new Bv(r, t) : new pu(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Hv(e, t) {
  this._context = e, this._alpha = t;
}
Hv.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        mu(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const tP = function e(t) {
  function n(r) {
    return t ? new Hv(r, t) : new fu(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Op(e) {
  return e < 0 ? -1 : 1;
}
function Sp(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, s = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), o = (s * i + a * r) / (r + i);
  return (Op(s) + Op(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function Tp(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function ul(e, t, n) {
  var r = e._x0, i = e._y0, s = e._x1, a = e._y1, o = (s - r) / 3;
  e._context.bezierCurveTo(r + o, i + o * t, s - o, a - o * n, s, a);
}
function Va(e) {
  this._context = e;
}
Va.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        ul(this, this._t0, Tp(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, ul(this, Tp(this, n = Sp(this, e, t)), n);
          break;
        default:
          ul(this, this._t0, n = Sp(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Vv(e) {
  this._context = new Gv(e);
}
(Vv.prototype = Object.create(Va.prototype)).point = function(e, t) {
  Va.prototype.point.call(this, t, e);
};
function Gv(e) {
  this._context = e;
}
Gv.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._context.bezierCurveTo(t, e, r, n, s, i);
  }
};
function eP(e) {
  return new Va(e);
}
function nP(e) {
  return new Vv(e);
}
function zv(e) {
  this._context = e;
}
zv.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = wp(e), i = wp(t), s = 0, a = 1; a < n; ++s, ++a)
          this._context.bezierCurveTo(r[0][s], i[0][s], r[1][s], i[1][s], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function wp(e) {
  var t, n = e.length - 1, r, i = new Array(n), s = new Array(n), a = new Array(n);
  for (i[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) i[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) r = i[t] / s[t - 1], s[t] -= r, a[t] -= r * a[t - 1];
  for (i[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t) i[t] = (a[t] - i[t + 1]) / s[t];
  for (s[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t) s[t] = 2 * e[t + 1] - i[t + 1];
  return [i, s];
}
function rP(e) {
  return new zv(e);
}
function vo(e, t) {
  this._context = e, this._t = t;
}
vo.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function iP(e) {
  return new vo(e, 0.5);
}
function sP(e) {
  return new vo(e, 0);
}
function aP(e) {
  return new vo(e, 1);
}
class oP extends kn {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(t, n, r) {
    let i, s, a;
    const o = r || Pr;
    t && (i = t.x, s = t.y, a = 2);
    const { width: l, height: c } = N.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    n.transition().duration(o.duration).ease(o.ease).attr(
      "transform",
      `translate(${l / 2}, ${c / 2}) scale(${a}) translate(${-i},${-s})`
    ), this.services.events.dispatchEvent(T.CanvasZoom.CANVAS_ZOOM_IN, {
      element: I(t)
    });
  }
  zoomOut(t, n) {
    const r = n || Pr;
    t.transition().duration(r.duration).ease(r.ease).attr("transform", ""), this.services.events.dispatchEvent(T.CanvasZoom.CANVAS_ZOOM_OUT);
  }
}
class lP extends kn {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(t, n) {
    this.documentFragment.addEventListener(t, n);
  }
  removeEventListener(t, n) {
    this.documentFragment.removeEventListener(t, n);
  }
  dispatchEvent(t, n) {
    let r;
    n ? r = new CustomEvent(t, {
      detail: n
    }) : (r = document.createEvent("Event"), r.initEvent(t, !1, !0)), this.documentFragment.dispatchEvent(r);
  }
}
class cP extends kn {
  constructor(t, n) {
    super(t, n);
  }
  downloadCSV(t, n) {
    const r = document.createElement("a"), i = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([t], {
          type: i
        }),
        n
      );
    else if (URL && "download" in r) {
      const s = URL.createObjectURL(
        new Blob([t], {
          type: i
        })
      );
      r.href = s, r.setAttribute("download", n), document.body.appendChild(r), r.click(), document.body.removeChild(r), URL.revokeObjectURL(s);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(t)}`;
  }
  downloadImage(t, n) {
    const r = document.createElement("a");
    r.download = n, r.href = t, document.body.appendChild(r), r.click(), document.body.removeChild(r);
  }
}
class uP extends kn {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    this.services.events?.addEventListener(T.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: t, name: n, animate: r }) {
    return this.pendingTransitions[t._id] = t, t.on("end interrupt cancel", () => {
      delete this.pendingTransitions[t._id];
    }), this.model.getOptions().animations === !1 || r === !1 ? t.duration(0) : t.duration(
      y(Ih, n, "duration") || Ih.default.duration
    );
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
function Wi(e, t) {
  const n = +Ht(e) - +Ht(t);
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function hP(e, t, n) {
  const [r, i] = ur(
    n?.in,
    e,
    t
  );
  return r.getFullYear() - i.getFullYear();
}
function dP(e, t, n) {
  const [r, i] = ur(
    n?.in,
    e,
    t
  ), s = Wi(r, i), a = Math.abs(hP(r, i));
  r.setFullYear(1584), i.setFullYear(1584);
  const o = Wi(r, i) === -s, l = s * (a - +o);
  return l === 0 ? 0 : l;
}
function gu(e, t, n) {
  const r = Ht(e, n?.in);
  if (isNaN(t)) return Le(e, NaN);
  if (!t)
    return r;
  const i = r.getDate(), s = Le(e, r.getTime());
  s.setMonth(r.getMonth() + t + 1, 0);
  const a = s.getDate();
  return i >= a ? s : (r.setFullYear(
    s.getFullYear(),
    s.getMonth(),
    i
  ), r);
}
function Fv(e, t, n) {
  return gu(e, t * 12, n);
}
function pP(e, t, n) {
  return Fv(e, -t, n);
}
function fP(e, t, n) {
  const [r, i] = ur(
    n?.in,
    e,
    t
  ), s = r.getFullYear() - i.getFullYear(), a = r.getMonth() - i.getMonth();
  return s * 12 + a;
}
function mP(e, t) {
  const n = Ht(e, t?.in);
  return n.setHours(23, 59, 59, 999), n;
}
function gP(e, t) {
  const n = Ht(e, t?.in), r = n.getMonth();
  return n.setFullYear(n.getFullYear(), r + 1, 0), n.setHours(23, 59, 59, 999), n;
}
function vP(e, t) {
  const n = Ht(e, t?.in);
  return +mP(n, t) == +gP(n, t);
}
function yP(e, t, n) {
  const [r, i, s] = ur(
    n?.in,
    e,
    e,
    t
  ), a = Wi(i, s), o = Math.abs(
    fP(i, s)
  );
  if (o < 1) return 0;
  i.getMonth() === 1 && i.getDate() > 27 && i.setDate(30), i.setMonth(i.getMonth() - a * o);
  let l = Wi(i, s) === -a;
  vP(r) && o === 1 && Wi(r, s) === 1 && (l = !1);
  const c = a * (o - +l);
  return c === 0 ? 0 : c;
}
function xP(e, t, n) {
  return gu(e, -t, n);
}
function bP(e, t, n) {
  const [r, i] = ur(
    n?.in,
    e,
    t
  ), s = $p(r, i), a = Math.abs(
    Um(r, i)
  );
  r.setDate(r.getDate() - s * a);
  const o = +($p(r, i) === -s), l = s * (a - o);
  return l === 0 ? 0 : l;
}
function $p(e, t) {
  const n = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function jv(e, t, n) {
  const r = Ht(e, n?.in);
  return isNaN(t) ? Le(e, NaN) : (t && r.setDate(r.getDate() + t), r);
}
function _P(e, t, n) {
  return jv(e, -t, n);
}
function vu(e) {
  return (t) => {
    const n = (0, Math.trunc)(t);
    return n === 0 ? 0 : n;
  };
}
function EP(e, t, n) {
  const [r, i] = ur(
    n?.in,
    e,
    t
  ), s = (+r - +i) / uf;
  return vu()(s);
}
function Wv(e, t, n) {
  return Le(e, +Ht(e) + t);
}
function qv(e, t, n) {
  return Wv(e, t * uf);
}
function OP(e, t, n) {
  return qv(e, -t);
}
function Yv(e, t) {
  return +Ht(e) - +Ht(t);
}
function Mp(e, t, n) {
  const r = Yv(e, t) / cf;
  return vu()(r);
}
function lc(e, t, n) {
  const r = Ht(e, n?.in);
  return r.setTime(r.getTime() + t * cf), r;
}
function Cp(e, t, n) {
  return lc(e, -t, n);
}
function Ap(e, t, n) {
  const r = Yv(e, t) / 1e3;
  return vu()(r);
}
function cc(e, t, n) {
  return Wv(e, t * 1e3);
}
function Lp(e, t, n) {
  return cc(e, -t);
}
class SP extends kn {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: t = null } = {}) {
    if (this.dualAxes && t) {
      const n = this.model.getOptions(), { groupMapsTo: r } = n.data, i = y(n, "axes", this.secondaryDomainAxisPosition), s = t[r];
      if (i?.correspondingDatasets && i.correspondingDatasets.includes(s))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: t = null, groups: n = null } = {}) {
    if (this.dualAxes) {
      const r = this.model.getOptions(), { groupMapsTo: i } = r.data, s = y(r, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (t !== null ? a = t[i] : n && n.length > 0 && (a = n[0]), s?.correspondingDatasets && s.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(t) {
    return y(this.model.getOptions(), "axes", t);
  }
  getDomainAxisOptions() {
    const t = this.getDomainAxisPosition();
    return this.getAxisOptions(t);
  }
  getRangeAxisOptions() {
    const t = this.getRangeAxisPosition();
    return this.getAxisOptions(t);
  }
  getScaleLabel(t) {
    return this.getAxisOptions(t).title || (t === G.BOTTOM || t === G.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(G).map(
      (t) => G[t]
    ).forEach((t) => {
      this.scales[t] = this.createScale(t);
    });
  }
  findDomainAndRangeAxes() {
    const t = this.findVerticalAxesPositions(), n = this.findHorizontalAxesPositions(), r = this.findDomainAndRangeAxesPositions(
      t,
      n
    );
    this.domainAxisPosition = r.primaryDomainAxisPosition, this.rangeAxisPosition = r.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = r.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = r.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === G.LEFT || this.rangeAxisPosition === G.RIGHT) && (this.domainAxisPosition === G.BOTTOM || this.domainAxisPosition === G.TOP) ? this.orientation = Ft.VERTICAL : this.orientation = Ft.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    const t = this.model.getOptions(), n = y(t, "axes");
    (n[G.LEFT]?.correspondingDatasets && n[G.RIGHT] || n[G.RIGHT]?.correspondingDatasets && n[G.LEFT] || n[G.TOP]?.correspondingDatasets && n[G.BOTTOM] || n[G.BOTTOM]?.correspondingDatasets && n[G.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(t) {
    const n = y(this.model.getOptions(), "axes", t, "domain");
    if (n && !Array.isArray(n))
      throw new Error(`Domain in ${t} axis is not a valid array`);
    if (Array.isArray(n) && (this.scaleTypes[t] === et.LINEAR || this.scaleTypes[t] === et.TIME) && n.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[t]}`
      );
    return n;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(t) {
    return this.scales[t];
  }
  getScaleTypeByPosition(t) {
    return this.scaleTypes[t];
  }
  getDomainAxisScaleType() {
    const t = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getRangeAxisScaleType() {
    const t = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const t = [G.BOTTOM, G.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const t = [G.LEFT, G.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(t, n, r, i) {
    const s = this.model.getOptions(), a = y(s, "axes")[r], { mapsTo: o } = a, l = y(i, o) !== null ? i[o] : i;
    let c;
    switch (n) {
      case et.LABELS:
        c = t(l) + t.step() / 2;
        break;
      case et.TIME:
        c = t(new Date(l));
        break;
      default:
        c = t(l);
    }
    return c;
  }
  getBoundedScaledValues(t) {
    const { bounds: n } = this.model.getOptions(), r = this.getRangeAxisPosition({ datum: t }), i = this.scales[r], s = this.model.getOptions(), a = y(s, "axes")[r], { mapsTo: o } = a, l = t[o] !== void 0 ? t[o] : t;
    return [
      i(
        y(t, n.upperBoundMapsTo) !== null ? t[n.upperBoundMapsTo] : l
      ),
      i(
        y(t, n.lowerBoundMapsTo) !== null ? t[n.lowerBoundMapsTo] : l
      )
    ];
  }
  getValueThroughAxisPosition(t, n) {
    const r = this.scaleTypes[t], i = this.scales[t];
    return this.getValueFromScale(i, r, t, n);
  }
  getDomainValue(t) {
    const n = this.getDomainAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getRangeValue(t) {
    const n = this.getRangeAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(t) {
    const n = this.model.getOptions();
    return y(n, "axes", this.getDomainAxisPosition({ datum: t }), "mapsTo");
  }
  getRangeIdentifier(t) {
    const n = this.model.getOptions();
    return y(n, "axes", this.getRangeAxisPosition({ datum: t }), "mapsTo");
  }
  extendsDomain(t, n) {
    const r = this.model.getOptions(), i = y(r, "axes", t);
    if (i.scaleType === et.TIME) {
      const s = y(r, "timeScale", "addSpaceOnEdges");
      return TP(n, s);
    } else
      return wP(n, Pn.paddingRatio, i.scaleType);
  }
  findVerticalAxesPositions() {
    const t = this.model.getOptions(), n = y(t, "axes"), r = this.isDualAxes();
    return y(n, G.LEFT) === null && y(n, G.RIGHT) !== null || y(n, G.RIGHT, "main") === !0 || r && y(n, G.LEFT, "correspondingDatasets") ? {
      primary: G.RIGHT,
      secondary: G.LEFT
    } : { primary: G.LEFT, secondary: G.RIGHT };
  }
  findHorizontalAxesPositions() {
    const t = this.model.getOptions(), n = y(t, "axes"), r = this.isDualAxes();
    return y(n, G.BOTTOM) === null && y(n, G.TOP) !== null || y(n, G.TOP, "main") === !0 || r && y(n, G.BOTTOM, "correspondingDatasets") ? {
      primary: G.TOP,
      secondary: G.BOTTOM
    } : { primary: G.BOTTOM, secondary: G.TOP };
  }
  findDomainAndRangeAxesPositions(t, n) {
    const r = this.model.getOptions(), i = y(r, "axes", t.primary), s = y(r, "axes", n.primary), a = i.scaleType || et.LINEAR, o = s.scaleType || et.LINEAR, l = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return l.primaryDomainAxisPosition = n.primary, l.primaryRangeAxisPosition = t.primary, l.secondaryDomainAxisPosition = n.secondary, l.secondaryRangeAxisPosition = t.secondary, (!(o === et.LABELS || o === et.TIME) && a === et.LABELS || a === et.TIME) && (l.primaryDomainAxisPosition = t.primary, l.primaryRangeAxisPosition = n.primary, l.secondaryDomainAxisPosition = t.secondary, l.secondaryRangeAxisPosition = n.secondary), l;
  }
  getScaleDomain(t) {
    const n = this.model.getOptions(), r = y(n, "axes", t), i = y(n, "bounds"), { includeZero: s } = r, a = y(r, "scaleType") || et.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (r.binned) {
      const { bins: v } = this.model.getBinConfigurations();
      return [0, nr(v, (b) => b.length)];
    } else if (r.limitDomainToBins) {
      const { bins: v } = this.model.getBinConfigurations(), b = this.model.getStackKeys({ bins: v });
      return [b[0].split(":")[0], b[b.length - 1].split(":")[1]];
    }
    const o = this.model.getDisplayData(), { extendLinearDomainBy: l, mapsTo: c, percentage: u, thresholds: d } = r, { reference: h, compareTo: p } = Pn.ratio;
    if (r.domain)
      return a === et.LABELS ? r.domain : (a === et.TIME && (r.domain = r.domain.map(
        (v) => v.getTime === void 0 ? new Date(v) : v
      )), this.extendsDomain(t, r.domain));
    if (u)
      return [0, 100];
    if (r && a === et.LABELS)
      return Qi(o.map((v) => v[c]));
    let f, g;
    const m = this.model.getDataGroupNames();
    if (a === et.LABELS_RATIO)
      return o.map((v) => `${v[h]}/${v[p]}`);
    if (a === et.TIME)
      g = o.map((v) => +new Date(v[c]));
    else if (i && n.axes)
      g = [], o.forEach((v) => {
        g.push(v[c]), v[i.upperBoundMapsTo] && g.push(v[i.upperBoundMapsTo]), v[i.lowerBoundMapsTo] && g.push(v[i.lowerBoundMapsTo]);
      });
    else if (r.stacked === !0 && m && t === this.getRangeAxisPosition()) {
      const { groupMapsTo: v } = n.data, b = this.model.getDataValuesGroupedByKeys({
        groups: m
      }), _ = o.filter(
        (x) => !m.includes(x[v])
      ), E = [];
      b.forEach((x) => {
        const { ...S } = x;
        let $ = 0, D = 0;
        Object.values(UN(S, "sharedStackKey")).forEach((C) => {
          isNaN(C) || (C < 0 ? D += C : $ += C);
        }), E.push([D, $]);
      }), g = [
        ...hu(E),
        ..._.map((x) => x[c])
      ];
    } else
      g = [], o.forEach((v) => {
        const b = v[c];
        Array.isArray(b) && b.length === 2 ? (g.push(b[0]), g.push(b[1])) : (l && g.push(Math.max(v[c], v[l])), g.push(b));
      });
    return a !== et.TIME && a !== et.LOG && s && g.push(0), d && d.length > 0 && d.forEach((v) => {
      const b = y(v, "value");
      b !== null && g.push(b);
    }), f = ze(g), f = this.extendsDomain(t, f), f;
  }
  createScale(t) {
    const n = this.model.getOptions(), r = y(n, "axes", t);
    if (!r)
      return null;
    const i = y(r, "scaleType") || et.LINEAR;
    this.scaleTypes[t] = i;
    let s;
    return i === et.TIME ? s = eg() : i === et.LOG ? s = Rv().base(r.base || 10) : i === et.LABELS || i === et.LABELS_RATIO ? s = Jr() : s = Fe(), s.domain(this.getScaleDomain(t)), s;
  }
  getDomainLowerBound(t) {
    let n, r = 0;
    return this.getOrientation() === Ft.VERTICAL ? n = this.getMainYScale().domain() : n = this.getMainXScale().domain(), y(this.model.getOptions(), "axes", t, "includeZero") === !1 && n[0] > 0 && n[1] > 0 && (r = n[0]), r;
  }
  getHighestDomainThreshold() {
    const t = y(this.model.getOptions(), "axes"), n = this.getDomainAxisPosition(), { thresholds: r } = t[n];
    if (!Array.isArray(r) || Array.isArray(r) && !r.length)
      return null;
    const i = this.getDomainScale(), s = r.sort((a, o) => o.value - a.value)[0];
    return this.getScaleTypeByPosition(n) === et.TIME && (typeof s.value == "string" || s.value.getTime === void 0) && (s.value = new Date(s.value)), {
      threshold: s,
      scaleValue: i(s.value)
    };
  }
  getHighestRangeThreshold() {
    const t = y(this.model.getOptions(), "axes"), n = this.getRangeAxisPosition(), { thresholds: r } = t[n];
    if (!Array.isArray(r) || Array.isArray(r) && !r.length)
      return null;
    const i = this.getRangeScale(), s = r.sort((a, o) => o.value - a.value)[0];
    return {
      threshold: s,
      scaleValue: i(s.value)
    };
  }
}
function TP(e, t) {
  const n = new Date(e[0]), r = new Date(e[1]);
  return dP(r, n) > 1 ? [pP(n, t), Fv(r, t)] : yP(r, n) > 1 ? [xP(n, t), gu(r, t)] : bP(r, n) > 1 ? [_P(n, t), jv(r, t)] : EP(r, n) > 1 ? [OP(n, t), qv(r, t)] : Mp(r, n) > 30 ? [
    Cp(n, t * 30),
    lc(r, t * 30)
  ] : Mp(r, n) > 1 ? [Cp(n, t), lc(r, t)] : Ap(r, n) > 15 ? [
    Lp(n, t * 15),
    cc(r, t * 15)
  ] : Ap(r, n) > 1 ? [Lp(n, t), cc(r, t)] : [n, r];
}
function wP([e, t], n, r) {
  const i = (t - e) * n, s = t <= 0 && t + i > 0 ? 0 : t + i;
  let a = e >= 0 && e - i < 0 ? 0 : e - i;
  if (r === et.LOG && a <= 0) {
    if (e <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    a = e;
  }
  return [a, s];
}
class $P extends kn {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: oo,
      curveLinearClosed: ig,
      curveBasis: jN,
      curveBasisClosed: WN,
      curveBasisOpen: qN,
      curveBundle: YN,
      curveCardinal: XN,
      curveCardinalClosed: ZN,
      curveCardinalOpen: KN,
      curveCatmullRom: QN,
      curveCatmullRomClosed: JN,
      curveCatmullRomOpen: tP,
      curveMonotoneX: eP,
      curveMonotoneY: nP,
      curveNatural: rP,
      curveStep: iP,
      curveStepAfter: aP,
      curveStepBefore: sP
    };
  }
  getD3Curve() {
    let t = "curveLinear";
    const n = this.model.getOptions().curve;
    if (n && (typeof n == "string" ? t = n : t = n.name), this.curveTypes[t]) {
      let r = this.curveTypes[t];
      return n && Object.keys(n).forEach((i) => {
        r[i] && (r = r[i](n[i]));
      }), r;
    }
    return console.warn(`The curve type '${t}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}
class MP extends kn {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !y(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const t = this.services.cartesianScales.getMainXAxisPosition(), n = y(
      this.model.getOptions(),
      "axes",
      t,
      "scaleType"
    );
    return t === G.BOTTOM && n === et.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const t = this.model.getZoomBarData();
    return t && t.length > 1 ? t : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(t) {
    if (!this.services.zoom) throw new Error("Services zoom not defined");
    const n = t || this.services.zoom.getZoomBarData(), { cartesianScales: r } = this.services;
    if (!r) throw new Error("Services cartesianScales undefined");
    const i = r.getMainXAxisPosition(), s = r.getDomainIdentifier(), a = y(this.model.getOptions(), "axes", i, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!i) throw new Error("Not defined: mainXAxisPosition");
    return r.extendsDomain(
      i,
      ze(n, (o) => o[s])
    );
  }
  handleDomainChange(t, n = { dispatchEvent: !0, type: "manual" }) {
    this.model.set({ zoomDomain: t }, { animate: !1 }), n.dispatchEvent && this.services.events?.dispatchEvent(T.ZoomDomain.CHANGE, {
      newDomain: t,
      type: n.type
    });
  }
  getZoomRatio() {
    return y(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(t, n) {
    const r = this.model.get("zoomDomain"), i = Object.assign(
      { stacked: !1 },
      // default configs
      n
    ), s = y(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && s && r) {
      const a = i.stacked ? "sharedStackKey" : this.services.cartesianScales?.getDomainIdentifier(), o = t.filter(
        (l) => new Date(l[a]) >= r[0] && new Date(l[a]) <= r[1]
      );
      if (o.length > 0)
        return o;
    }
    return t;
  }
  zoomIn(t = this.getZoomRatio()) {
    const n = this.model.get("zoomDomain"), r = ye.handleWidth, i = this.services.cartesianScales?.getMainXScale().copy();
    i.domain(this.getDefaultZoomBarDomain());
    const s = i(n[0]), a = i(n[1]);
    if (a - s < r + 1)
      return;
    const o = i.range(), l = a - s, c = Math.min((o[1] - o[0]) / 2 * (t / 2), l / 2);
    let u = s + c, d = a - c;
    u >= d && (u = s + l / 2 - r / 2, d = a - l / 2 + r / 2);
    const h = [i.invert(u), i.invert(d)];
    (n[0].valueOf() !== h[0].valueOf() || n[1].valueOf() !== h[1].valueOf()) && this.handleDomainChange(h, { dispatchEvent: !0, type: "in" });
  }
  zoomOut(t = this.getZoomRatio()) {
    const n = this.model.get("zoomDomain");
    if (!this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const r = this.services.cartesianScales.getMainXScale().copy();
    r.domain(this.getDefaultZoomBarDomain());
    const i = r(n[0]), s = r(n[1]), a = r.range(), o = (a[1] - a[0]) / 2 * (t / 2), l = Math.max(i - o, a[0]), c = Math.min(s + o, a[1]), u = [r.invert(l), r.invert(c)];
    (n[0].valueOf() !== u[0].valueOf() || n[1].valueOf() !== u[1].valueOf()) && this.handleDomainChange(u, { dispatchEvent: !0, type: "out" });
  }
  resetZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    (t[0].valueOf() !== n[0].valueOf() || t[1].valueOf() !== n[1].valueOf()) && this.handleDomainChange(n, { dispatchEvent: !0, type: "reset" });
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    if (!t || !n)
      return !1;
    const r = t[1].valueOf() - t[0].valueOf(), i = n[1].valueOf() - n[0].valueOf(), s = y(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return r / i < s;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    return !!(t && n && t[0].valueOf() === n[0].valueOf() && t[1].valueOf() === n[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(t) {
    return y(this.model.getOptions(), "zoomBar", t, "loading");
  }
  isZoomBarLocked(t) {
    return y(this.model.getOptions(), "zoomBar", t, "locked");
  }
}
function CP(e, t, n) {
  var r = e.length;
  return n = n === void 0 ? r : n, !t && n >= r ? e : kv(e, t, n);
}
var AP = "\\ud800-\\udfff", LP = "\\u0300-\\u036f", DP = "\\ufe20-\\ufe2f", kP = "\\u20d0-\\u20ff", RP = LP + DP + kP, IP = "\\ufe0e\\ufe0f", NP = "\\u200d", PP = RegExp("[" + NP + AP + RP + IP + "]");
function Xv(e) {
  return PP.test(e);
}
function UP(e) {
  return e.split("");
}
var Zv = "\\ud800-\\udfff", BP = "\\u0300-\\u036f", HP = "\\ufe20-\\ufe2f", VP = "\\u20d0-\\u20ff", GP = BP + HP + VP, zP = "\\ufe0e\\ufe0f", FP = "[" + Zv + "]", uc = "[" + GP + "]", hc = "\\ud83c[\\udffb-\\udfff]", jP = "(?:" + uc + "|" + hc + ")", Kv = "[^" + Zv + "]", Qv = "(?:\\ud83c[\\udde6-\\uddff]){2}", Jv = "[\\ud800-\\udbff][\\udc00-\\udfff]", WP = "\\u200d", t1 = jP + "?", e1 = "[" + zP + "]?", qP = "(?:" + WP + "(?:" + [Kv, Qv, Jv].join("|") + ")" + e1 + t1 + ")*", YP = e1 + t1 + qP, XP = "(?:" + [Kv + uc + "?", uc, Qv, Jv, FP].join("|") + ")", ZP = RegExp(hc + "(?=" + hc + ")|" + XP + YP, "g");
function KP(e) {
  return e.match(ZP) || [];
}
function QP(e) {
  return Xv(e) ? KP(e) : UP(e);
}
function JP(e) {
  return function(t) {
    t = ds(t);
    var n = Xv(t) ? QP(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? CP(n, 1).join("") : t.slice(1);
    return r[e]() + i;
  };
}
var t3 = JP("toUpperCase");
function e3(e) {
  return t3(ds(e).toLowerCase());
}
var n3 = $g(function(e, t, n) {
  return t = t.toLowerCase(), e + (n ? e3(t) : t);
});
class Ye {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(t, n) {
    this.components = [], this.services = {
      canvasZoom: oP,
      domUtils: N,
      events: lP,
      files: cP,
      gradientUtils: Il,
      transitions: uP
    }, this.model = new an(this.services);
  }
  // Contains the code that uses properties that are overridable by the super-class
  init(t, n) {
    this.model.set({ holder: t }, { skipUpdate: !0 }), Object.keys(this.services).forEach((r) => {
      const i = this.services[r];
      this.services[r] = new i(this.model, this.services);
    }), this.services.events.addEventListener(T.Model.UPDATE, (r) => {
      const i = !!y(r, "detail", "animate");
      this.update(i);
    }), this.model.setData(n.data), this.services.events.addEventListener(T.Chart.RESIZE, () => {
      this.update(!1);
    }), this.components = this.getComponents(), this.update();
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    return console.error("getComponents() method is not implemented"), [];
  }
  update(t = !0) {
    if (!this.components)
      return;
    Object.keys(this.services).forEach((i) => {
      this.services[i].update();
    }), this.components.forEach((i) => i.render(t));
    const n = this.services.transitions.getPendingTransitions(), r = Object.keys(n).map((i) => n[i].end().catch((s) => s));
    Promise.all(r).then(
      () => this.services.events.dispatchEvent(T.Chart.RENDER_FINISHED)
    );
  }
  destroy() {
    this.components.forEach((t) => t.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });
  }
  getChartComponents(t, n) {
    const r = this.model.getOptions(), i = y(r, "toolbar", "enabled"), s = {
      id: "legend",
      components: [new ou(this.model, this.services)],
      growth: ct.PREFERRED
    }, a = y(r, "canvasZoom", "enabled");
    a && a === !0 && t.push(new BD(this.model, this.services));
    const o = !!this.model.getOptions().title, l = {
      id: "title",
      components: [new _s(this.model, this.services)],
      growth: ct.STRETCH
    }, c = {
      id: "toolbar",
      components: [new po(this.model, this.services)],
      growth: ct.PREFERRED
    }, u = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            l,
            ...i ? [c] : []
          ],
          {
            direction: At.ROW,
            alignItems: ii.CENTER
          }
        )
      ],
      growth: ct.PREFERRED
    }, d = {
      id: "graph-frame",
      components: t,
      growth: ct.STRETCH,
      renderType: y(n, "graphFrameRenderType") || rt.SVG
    }, h = y(n, "excludeLegend") !== !0 && r.legend.enabled !== !1;
    let p = At.COLUMN;
    if (h) {
      const v = y(r, "legend", "position");
      v === "left" ? (p = At.ROW, r.legend.orientation || (r.legend.orientation = qi.VERTICAL)) : v === "right" ? (p = At.ROW_REVERSE, r.legend.orientation || (r.legend.orientation = qi.VERTICAL)) : v === "bottom" && (p = At.COLUMN_REVERSE);
    }
    const f = {
      id: "spacer",
      components: [new An(this.model, this.services)],
      growth: ct.PREFERRED
    }, g = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...h ? [s] : [],
            ...h ? [f] : [],
            d
          ],
          {
            direction: p
          }
        )
      ],
      growth: ct.STRETCH
    }, m = [];
    if (o || i) {
      m.push(u);
      const v = {
        id: "spacer",
        components: [
          new An(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: ct.PREFERRED
      };
      m.push(v);
    }
    return m.push(g), [
      new lu(this.model, this.services),
      new fo(this.model, this.services),
      new be(this.model, this.services, m, {
        direction: At.COLUMN
      })
    ];
  }
}
class me extends Ye {
  constructor(t, n) {
    super(t, n), this.services = Object.assign(this.services, {
      cartesianScales: SP,
      curves: $P,
      zoom: MP
    }), this.model = new mr(this.services);
  }
  getAxisChartComponents(t, n) {
    const r = this.model.getOptions(), i = y(r, "zoomBar", G.TOP, "enabled"), s = y(r, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const a = this.services.cartesianScales.getMainXAxisPosition(), o = y(r, "axes", a, "scaleType"), l = i && a === G.BOTTOM && o === et.TIME, c = this.services.zoom.isZoomBarLocked(G.TOP), u = !!this.model.getOptions().title, d = {
      id: "title",
      components: [new _s(this.model, this.services)],
      growth: ct.STRETCH
    }, h = {
      id: "toolbar",
      components: [new po(this.model, this.services)],
      growth: ct.PREFERRED
    }, p = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            d,
            ...s ? [h] : []
          ],
          {
            direction: At.ROW,
            alignItems: ii.CENTER
          }
        )
      ],
      growth: ct.PREFERRED
    }, f = {
      id: "legend",
      components: [new ou(this.model, this.services)],
      growth: ct.PREFERRED
    };
    l && !c && t.push(
      new yv(this.model, this.services),
      new HD(this.model, this.services)
    ), t.push(new GD(this.model, this.services)), t.push(new zD(this.model, this.services));
    const g = {
      id: "graph-frame",
      components: t,
      growth: ct.STRETCH,
      renderType: rt.SVG
    }, m = y(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;
    let v = At.COLUMN;
    if (m) {
      const S = y(this.model.getOptions(), "legend", "position");
      S === Ui.LEFT ? (v = At.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = qi.VERTICAL)) : S === Ui.RIGHT ? (v = At.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = qi.VERTICAL)) : S === Ui.BOTTOM && (v = At.COLUMN_REVERSE);
    }
    const b = {
      id: "spacer",
      components: [new An(this.model, this.services)],
      growth: ct.PREFERRED
    }, _ = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...m ? [f] : [],
            ...m ? [b] : [],
            g
          ],
          {
            direction: v
          }
        )
      ],
      growth: ct.STRETCH
    }, E = {
      id: "zoom-bar",
      components: [new VD(this.model, this.services)],
      growth: ct.PREFERRED,
      renderType: rt.SVG
    }, x = [];
    if (u || s) {
      x.push(p);
      const S = {
        id: "spacer",
        components: [
          new An(this.model, this.services, s ? { size: 15 } : void 0)
        ],
        growth: ct.PREFERRED
      };
      x.push(S);
    }
    return l && x.push(E), x.push(_), [
      new bv(this.model, this.services),
      new fo(this.model, this.services),
      new be(this.model, this.services, x, {
        direction: At.COLUMN
      })
    ];
  }
}
class r3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new Kw(this.services), this.model.setOptions(Rt(wt.alluvialChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new ck(this.model, this.services)];
    return this.getChartComponents(t, {
      excludeLegend: !0
    });
  }
}
class i3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(
      Rt(Sn(wt.areaChart), n.options)
    ), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Vn(this.model, this.services),
      new jr(this.model, this.services),
      new Ov(this.model, this.services),
      new nn(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0
      }),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class s3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new Qw(this.services), this.model.setOptions(Rt(wt.boxplotChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new dk(this.model, this.services),
      new oi(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t, {
      legend: {
        enabled: !1
      }
    });
  }
}
class a3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.bubbleChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Vn(this.model, this.services),
      new pk(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class o3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new Jw(this.services), this.model.setOptions(Rt(wt.bulletChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new fk(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class l3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new t$(this.services), this.model.setOptions(
      Rt(wt.choroplethChart, n.options)
    ), this.init(t, n);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getChartComponents(t, n) {
    const r = this.model.getOptions(), i = y(r, "toolbar", "enabled"), s = !!this.model.getOptions().title, a = {
      id: "title",
      components: [new _s(this.model, this.services)],
      growth: ct.STRETCH
    }, o = {
      id: "toolbar",
      components: [new po(this.model, this.services)],
      growth: ct.PREFERRED
    }, l = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            a,
            ...i ? [o] : []
          ],
          {
            direction: At.ROW,
            alignItems: ii.CENTER
          }
        )
      ],
      growth: ct.PREFERRED
    }, c = {
      id: "legend",
      components: [
        new Tv(this.model, this.services, {
          chartType: "choropleth"
        })
      ],
      growth: ct.PREFERRED,
      renderType: rt.SVG
    }, u = {
      id: "graph-frame",
      components: t,
      growth: ct.STRETCH,
      renderType: rt.SVG
    }, d = y(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, h = At.COLUMN_REVERSE, p = {
      id: "spacer",
      components: [new An(this.model, this.services, { size: 15 })],
      growth: ct.PREFERRED
    }, f = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...d ? [c] : [],
            ...d ? [p] : [],
            u
          ],
          {
            direction: h
          }
        )
      ],
      growth: ct.STRETCH
    }, g = [];
    if (s || i) {
      g.push(l);
      const m = {
        id: "spacer",
        components: [
          new An(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: ct.PREFERRED
      };
      g.push(m);
    }
    return g.push(f), [
      new lu(this.model, this.services),
      new fo(this.model, this.services),
      new be(this.model, this.services, g, {
        direction: At.COLUMN
      })
    ];
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new AN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class c3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new e$(this.services), this.model.setOptions(Rt(wt.circlePackChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new Dk(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
const Dp = {
  [we.LINE]: [jr, nn],
  [we.SCATTER]: [nn],
  [we.AREA]: [Ov, jr, nn],
  [we.STACKED_AREA]: [Cv, jr, Lv, Ua],
  [we.SIMPLE_BAR]: [Mv],
  [we.GROUPED_BAR]: [$v, oi],
  [we.STACKED_BAR]: [Av, Ua]
};
class u3 extends me {
  constructor(t, n) {
    super(t, n);
    const r = Rt(wt.comboChart, n.options);
    n.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), r.comboChartTypes = [{ type: we.LINE, correspondingDatasets: [] }]), this.model.setOptions(r), this.init(t, n);
  }
  getGraphComponents() {
    const { comboChartTypes: t } = this.model.getOptions();
    let n = 0;
    const r = t.map((i) => {
      const s = i.type;
      let a;
      if (typeof i.type == "string") {
        if (!Object.keys(Dp).includes(i.type))
          return console.error(
            `Invalid chart type "${i.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`
          ), null;
        let o = !1;
        const l = `${n3(i.type)}Chart`;
        return a = at({}, wt[l], this.model.getOptions(), i.options), i.type === we.STACKED_AREA && (o = !0), Dp[i.type].map(
          (c) => new c(this.model, this.services, {
            groups: i.correspondingDatasets,
            id: n++,
            options: a,
            stacked: o
          })
        );
      } else
        return a = at({}, this.model.getOptions(), i.options), new s(this.model, this.services, {
          groups: i.correspondingDatasets,
          id: n++,
          options: a
        });
    }).filter((i) => i !== null);
    return hu(r);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const { comboChartTypes: t } = this.model.getOptions(), n = t.some(
      (i) => i.type === we.STACKED_BAR || i.type === we.STACKED_AREA
    ), r = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      }),
      ...n ? [] : [new Vn(this.model, this.services)],
      ...this.getGraphComponents()
    ];
    return this.getAxisChartComponents(r);
  }
}
class n1 extends Ye {
  // TODO - Optimize the use of "extending"
  constructor(t, n, r = !1) {
    super(t, n), this.model = new n$(this.services), !r && (this.model.setOptions(Rt(wt.pieChart, n.options)), this.init(t, n));
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new wv(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.PIE
      })
    ];
    return this.getChartComponents(t);
  }
}
class h3 extends n1 {
  constructor(t, n) {
    super(t, n, !0), this.model.setOptions(Rt(wt.donutChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new Rk(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.DONUT
      })
    ];
    return this.getChartComponents(t);
  }
}
class d3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new r$(this.services), this.model.setOptions(Rt(wt.gaugeChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new Ik(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class p3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.groupedBarChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new $v(this.model, this.services),
      new oi(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class f3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new i$(this.services), this.model.setOptions(
      Rt(wt.heatmapChart, n.options)
    ), this.init(t, n);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getAxisChartComponents(t, n) {
    const r = this.model.getOptions(), i = y(r, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const s = !!this.model.getOptions().title, a = {
      id: "title",
      components: [new _s(this.model, this.services)],
      growth: ct.STRETCH
    }, o = {
      id: "toolbar",
      components: [new po(this.model, this.services)],
      growth: ct.PREFERRED
    }, l = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            a,
            ...i ? [o] : []
          ],
          {
            direction: At.ROW,
            alignItems: ii.CENTER
          }
        )
      ],
      growth: ct.PREFERRED
    }, c = {
      id: "legend",
      components: [
        new Tv(this.model, this.services, {
          chartType: "heatmap"
        })
      ],
      growth: ct.PREFERRED,
      renderType: rt.SVG
    }, u = {
      id: "graph-frame",
      components: t,
      growth: ct.STRETCH,
      renderType: rt.SVG
    }, d = y(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, h = At.COLUMN_REVERSE, p = {
      id: "spacer",
      components: [new An(this.model, this.services, { size: 15 })],
      growth: ct.PREFERRED
    }, f = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...d ? [c] : [],
            ...d ? [p] : [],
            u
          ],
          {
            direction: h
          }
        )
      ],
      growth: ct.STRETCH
    }, g = [];
    if (s || i) {
      g.push(l);
      const m = {
        id: "spacer",
        components: [
          new An(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: ct.PREFERRED
      };
      g.push(m);
    }
    return g.push(f), [
      new bv(this.model, this.services),
      new fo(this.model, this.services),
      new be(this.model, this.services, g, {
        direction: At.COLUMN
      })
    ];
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Nk(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class m3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new s$(this.services), this.model.setOptions(Rt(wt.histogramChart, n.options)), this.init(t, n), this.update();
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Ok(this.model, this.services),
      new Pk(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class g3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.lineChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Vn(this.model, this.services),
      new jr(this.model, this.services),
      new nn(this.model, this.services, { handleThresholds: !0 }),
      new Vk(this.model, this.services),
      new oi(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class v3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.lollipopChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Vn(this.model, this.services),
      new Uk(this.model, this.services),
      new nn(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class y3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new a$(this.services);
    const r = n.options.meter?.proportional ? at(Sn(wt.proportionalMeterChart), n.options) : at(Sn(wt.meterChart), n.options);
    this.model.setOptions(r), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      ...y(this.model.getOptions(), "meter", "showLabels") ? [
        // Meter has a unique dataset title within the graph
        {
          id: "meter-title",
          components: [new Lk(this.model, this.services)],
          growth: ct.STRETCH,
          renderType: rt.SVG
        },
        // Create the title spacer
        {
          id: "spacer",
          components: [
            new An(this.model, this.services, {
              size: 8
            })
          ],
          growth: ct.STRETCH
        }
      ] : [],
      // Specify what to render inside the graph only
      {
        id: "meter-graph",
        components: [new Bk(this.model, this.services)],
        growth: ct.STRETCH,
        renderType: rt.SVG
      }
    ], n = [
      new be(this.model, this.services, t, {
        direction: At.COLUMN
      })
    ];
    return this.getChartComponents(n, {
      graphFrameRenderType: rt.HTML
    });
  }
}
class x3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new o$(this.services), this.model.setOptions(Rt(wt.radarChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new Hk(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class b3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.scatterChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Vn(this.model, this.services),
      new nn(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class _3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new l$(this.services), this.model.setOptions(Rt(wt.treeChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new Gk(this.model, this.services)];
    return this.getChartComponents(t, {
      excludeLegend: !0
    });
  }
}
class E3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new c$(this.services), this.model.setOptions(Rt(wt.treemapChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [new vN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class O3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.simpleBarChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Mv(this.model, this.services),
      new oi(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class S3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.stackedAreaChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Ua(this.model, this.services),
      new Cv(this.model, this.services),
      new jr(this.model, this.services, { stacked: !0 }),
      new Lv(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0,
        stacked: !0
      }),
      new ce(this.model, this.services, {
        skeleton: zt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class T3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Rt(wt.stackedBarChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new fe(this.model, this.services),
      new Oe(this.model, this.services),
      new Ua(this.model, this.services),
      new Av(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.VERT_OR_HORIZ
      }),
      new oi(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class w3 extends Ye {
  constructor(t, n) {
    super(t, n), this.model = new u$(this.services), this.model.setOptions(Rt(wt.wordCloudChart, n.options)), this.init(t, n);
  }
  /**
   * Retrieves the components to be rendered inside the graph frame.
   *
   * @returns {Component[]} An array of components to be rendered.
   */
  getComponents() {
    const t = [
      new MN(this.model, this.services),
      new ce(this.model, this.services, {
        skeleton: zt.PIE
      })
    ];
    return this.getChartComponents(t);
  }
}
class Dt extends Ct.PureComponent {
  chart;
  chartRef = Ct.createRef();
  // TODO: add abstract keyword once React 16 support no longer needed then remove the next 3 comments
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createChart(t, n, r) {
    throw new Error("Method not implemented.");
  }
  componentDidMount() {
    this.chartRef.current && !this.chart && (this.chart = this.createChart(this.chartRef.current, this.props.data, this.props.options));
  }
  componentDidUpdate(t) {
    this.props.data !== t.data && this.chart?.model.setData(this.props.data), this.props.options !== t.options && this.chart?.model.setOptions(this.props.options);
  }
  render() {
    return Ct.createElement("div", { ref: this.chartRef, className: "chart-holder" });
  }
}
class q3 extends Dt {
  createChart(t, n, r) {
    return new r3(t, { data: n, options: r });
  }
}
class Y3 extends Dt {
  createChart(t, n, r) {
    return new i3(t, { data: n, options: r });
  }
}
class X3 extends Dt {
  createChart(t, n, r) {
    return new s3(t, { data: n, options: r });
  }
}
class Z3 extends Dt {
  createChart(t, n, r) {
    return new a3(t, { data: n, options: r });
  }
}
class K3 extends Dt {
  createChart(t, n, r) {
    return new o3(t, { data: n, options: r });
  }
}
class Q3 extends Dt {
  createChart(t, n, r) {
    return new l3(t, { data: n, options: r });
  }
}
class J3 extends Dt {
  createChart(t, n, r) {
    return new c3(t, { data: n, options: r });
  }
}
class tU extends Dt {
  createChart(t, n, r) {
    return new u3(t, { data: n, options: r });
  }
}
class eU extends Dt {
  createChart(t, n, r) {
    return new h3(t, { data: n, options: r });
  }
}
class nU extends Dt {
  createChart(t, n, r) {
    return new d3(t, { data: n, options: r });
  }
}
class rU extends Dt {
  createChart(t, n, r) {
    return new p3(t, { data: n, options: r });
  }
}
class iU extends Dt {
  createChart(t, n, r) {
    return new f3(t, { data: n, options: r });
  }
}
class sU extends Dt {
  createChart(t, n, r) {
    return new m3(t, { data: n, options: r });
  }
}
class aU extends Dt {
  createChart(t, n, r) {
    return new g3(t, { data: n, options: r });
  }
}
class oU extends Dt {
  createChart(t, n, r) {
    return new v3(t, { data: n, options: r });
  }
}
class lU extends Dt {
  createChart(t, n, r) {
    return new y3(t, { data: n, options: r });
  }
}
class cU extends Dt {
  createChart(t, n, r) {
    return new n1(t, { data: n, options: r });
  }
}
class uU extends Dt {
  createChart(t, n, r) {
    return new x3(t, { data: n, options: r });
  }
}
class hU extends Dt {
  createChart(t, n, r) {
    return new b3(t, { data: n, options: r });
  }
}
class dU extends Dt {
  createChart(t, n, r) {
    return new O3(t, { data: n, options: r });
  }
}
class pU extends Dt {
  createChart(t, n, r) {
    return new S3(t, { data: n, options: r });
  }
}
class fU extends Dt {
  createChart(t, n, r) {
    return new T3(t, { data: n, options: r });
  }
}
class mU extends Dt {
  createChart(t, n, r) {
    return new _3(t, { data: n, options: r });
  }
}
class gU extends Dt {
  createChart(t, n, r) {
    return new E3(t, { data: n, options: r });
  }
}
class vU extends Dt {
  createChart(t, n, r) {
    return new w3(t, { data: n, options: r });
  }
}
function $3(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hl = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var kp;
function M3() {
  return kp || (kp = 1, function(e) {
    (function() {
      var t = {}.hasOwnProperty;
      function n() {
        for (var s = "", a = 0; a < arguments.length; a++) {
          var o = arguments[a];
          o && (s = i(s, r(o)));
        }
        return s;
      }
      function r(s) {
        if (typeof s == "string" || typeof s == "number")
          return s;
        if (typeof s != "object")
          return "";
        if (Array.isArray(s))
          return n.apply(null, s);
        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
          return s.toString();
        var a = "";
        for (var o in s)
          t.call(s, o) && s[o] && (a = i(a, o));
        return a;
      }
      function i(s, a) {
        return a ? s ? s + " " + a : s + a : s;
      }
      e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
    })();
  }(hl)), hl.exports;
}
var C3 = M3();
const Gn = /* @__PURE__ */ $3(C3), zn = "cds", yU = ({ tag: e = "div", className: t, children: n, color: r, href: i, position: s = "static", stacked: a, ...o }) => {
  const l = i ? "a" : o.onClick ? "button" : e, c = `${zn}--cc--card-node`, u = Gn(c, {
    [`${c}--stacked`]: a,
    [`${c}--${l}`]: l,
    [t]: t
  });
  return Ct.createElement(
    l,
    {
      className: u,
      style: { borderColor: r, position: s },
      tabIndex: 0,
      ...o
    },
    n
  );
}, xU = ({
  children: e,
  farsideColumn: t = !1,
  ...n
}) => {
  const r = `${zn}--cc--card-node`, i = Gn(`${r}__column`, {
    [`${r}__column--farside`]: t,
    ...n.className ? { [n.className]: !0 } : {}
  });
  return Ct.createElement("div", { className: i, ...n }, e);
}, bU = ({
  children: e,
  ...t
}) => {
  const n = `${zn}--cc--card-node`, r = Gn(`${n}__label`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return Ct.createElement("label", { className: r, ...t }, e);
}, _U = ({
  children: e,
  ...t
}) => {
  const n = `${zn}--cc--card-node`, r = Gn(`${n}__subtitle`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return Ct.createElement("div", { className: r, ...t }, e);
}, EU = ({
  children: e,
  ...t
}) => {
  const n = `${zn}--cc--card-node`, r = Gn(`${n}__title`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return Ct.createElement("div", { className: r, ...t }, e);
}, OU = ({
  color: e,
  markerEnd: t,
  markerStart: n,
  path: r,
  source: i,
  target: s,
  variant: a = null,
  ...o
}) => {
  const l = `${zn}--cc--edge`, c = Gn(l, {
    [`${l}--${a}`]: a,
    ...o.className ? { [o.className]: !0 } : {}
  });
  let u = r;
  if (!u && i && s && (u = Sk(i, s)), !u) throw Error("Missing parameters for Edge component: path or source and target.");
  return Ct.createElement(
    "g",
    { className: c, ...o },
    Ct.createElement("path", { d: u, className: `${l}__container` }),
    Ct.createElement("path", { d: u, className: `${l}__outer` }),
    Ct.createElement("path", {
      d: u,
      className: `${l}__inner`,
      markerEnd: `url(#${t})`,
      markerStart: `url(#${n})`,
      style: { stroke: e }
    })
  );
}, li = ({
  color: e,
  d: t,
  id: n,
  orient: r = "auto",
  height: i,
  width: s,
  position: a = "end",
  className: o,
  refX: l,
  refY: c,
  ...u
}) => {
  const d = `${zn}--cc--marker`, h = Gn(d, o), p = a === "end" ? (s || 0) / 2 + 0.5 : 0.5, f = (i || 0) / 2;
  return Ct.createElement(
    "marker",
    {
      className: h,
      markerHeight: i,
      markerWidth: s,
      orient: r,
      id: n,
      refX: l || p,
      refY: c || f,
      markerUnits: "userSpaceOnUse",
      ...u
    },
    Ct.createElement("path", { d: t, style: { fill: e } })
  );
}, SU = (e) => Ct.createElement(li, { d: Tk.d, ...e }), TU = (e) => Ct.createElement(li, { d: wk.d, ...e }), wU = (e) => Ct.createElement(li, { d: $k.d, ...e }), $U = (e) => Ct.createElement(li, { d: Mk.d, ...e }), MU = (e) => Ct.createElement(li, { d: Ck.d, ...e }), CU = (e) => Ct.createElement(li, { d: Ak.d, ...e }), AU = ({
  shape: e = "circle",
  tag: t = "div",
  title: n = "Title",
  className: r,
  subtitle: i,
  description: s,
  renderIcon: a,
  href: o,
  size: l = 48,
  stacked: c,
  position: u = "fixed",
  bodyPosition: d = "absolute",
  ...h
}) => {
  const p = o ? "a" : h.onClick ? "button" : t, f = `${zn}--cc--shape-node`, g = Gn(f, {
    [`${f}--stacked`]: c,
    [`${f}--${e}`]: e,
    [`${f}--${p}`]: p,
    [r]: r
  }), m = n ? Ct.createElement("div", { className: `${f}__title` }, n) : null, v = i ? Ct.createElement("div", { className: `${f}__subtitle` }, i) : null, b = s ? Ct.createElement("div", { className: `${f}__description` }, s) : null;
  return Ct.createElement(
    p,
    {
      className: g,
      style: { height: l, width: l, position: u },
      tabIndex: 0,
      ...h
    },
    Ct.createElement("div", { className: `${f}__icon` }, a),
    Ct.createElement(
      "div",
      { className: `${f}__body`, style: { position: d } },
      m,
      v,
      b
    )
  );
};
export {
  jt as Alignments,
  q3 as AlluvialChart,
  Y3 as AreaChart,
  Gp as AreaEvent,
  dl as ArrowDirections,
  SU as ArrowLeftMarker,
  TU as ArrowRightMarker,
  Vp as AxisEvent,
  Ga as AxisFlavor,
  G as AxisPositions,
  pl as AxisTitleOrientations,
  Wp as BarEvent,
  X3 as BoxplotChart,
  qp as BoxplotEvent,
  Z3 as BubbleChart,
  K3 as BulletChart,
  Fs as CalloutDirections,
  Hp as CanvasZoomEvent,
  yU as CardNode,
  xU as CardNodeColumn,
  bU as CardNodeLabel,
  _U as CardNodeSubtitle,
  EU as CardNodeTitle,
  Ft as CartesianOrientations,
  Rp as ChartEvent,
  af as ChartTheme,
  we as ChartTypes,
  Q3 as ChoroplethChart,
  wU as CircleMarker,
  J3 as CirclePackChart,
  it as ColorClassNameTypes,
  qs as ColorLegendType,
  tU as ComboChart,
  $U as DiamondMarker,
  Bi as DividerStatus,
  pn as DominantBaseline,
  eU as DonutChart,
  OU as Edge,
  Q3 as ExperimentalChoroplethChart,
  nU as GaugeChart,
  jp as GaugeEvent,
  Ir as GaugeTypes,
  rU as GroupedBarChart,
  iU as HeatmapChart,
  sU as HistogramChart,
  ii as LayoutAlignItems,
  At as LayoutDirection,
  ct as LayoutGrowth,
  Gt as LegendItemType,
  qi as LegendOrientations,
  Ui as LegendPositions,
  aU as LineChart,
  Xp as LineEvent,
  oU as LollipopChart,
  li as Marker,
  lU as MeterChart,
  Ip as ModalEvent,
  Np as ModelEvent,
  cU as PieChart,
  Fp as PieEvent,
  gn as Projection,
  uU as RadarChart,
  Zp as RadarEvent,
  rt as RenderTypes,
  et as ScaleTypes,
  hU as ScatterChart,
  Yp as ScatterEvent,
  AU as ShapeNode,
  dU as SimpleBarChart,
  zt as Skeletons,
  MU as SquareMarker,
  pU as StackedAreaChart,
  fU as StackedBarChart,
  js as Statuses,
  CU as TeeMarker,
  dn as TextAnchor,
  Jp as ThresholdEvent,
  Ws as TickRotations,
  _t as ToolbarControlTypes,
  Pi as TooltipEvent,
  mU as TreeChart,
  Kp as TreeEvent,
  dc as TreeTypes,
  gU as TreemapChart,
  Qp as TreemapEvent,
  Ve as TruncationTypes,
  vU as WordCloudChart,
  zp as WordCloudEvent,
  Ke as ZoomBarTypes,
  Bp as ZoomDomainEvent,
  Up as ZoombarEvent
};
//# sourceMappingURL=index.mjs.map
