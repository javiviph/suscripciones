import { t as Br, $ as ol, i as ll, a0 as cl, a1 as zr, a2 as Ur, a3 as ul, a4 as hl, a5 as dl, a6 as pl, a7 as Fr, a8 as ya, a9 as an, g as O, p as Kt, a as sn, C as Ea, aa as Et, w as Mt, ab as kn, E as xa, H as jt, ac as Wr, ad as Ls, c as fl, ae as xe, I as di, K as pi, e as se, af as yn, ag as ge, f as ye, x as ve, ah as gl, h as Je, O as ml, ai as Xr, aj as Re, z as xt, l as qt, ak as Gt, al as vl, M as yl, am as Yr, y as _t, q as dn, n as Bn, an as $s, ao as El, ap as xl, aq as fi, ar as Sa, A as Ae, as as Ta, at as Zr, au as Sl } from "./color-scale-utils-BzjNNGXE.mjs";
import { y as at, $ as b, N as Tt, r as be, q as ze, L as Tl, A as te, m as nt, s as Me, W as Qe, S as kt, e as J, Z as Ue, i as Xt, f as ba, J as Vs, d as bl, F as zn, n as Gs, H as Hs, C as Bs, p as Un, b as Oa, D as zs, U as Ol, x as we, a0 as Fn, O as Us } from "./axis-scales-CPuwbFQf.mjs";
import { R as lt } from "./a11y-ePqvrObQ.mjs";
import { t as ns, s as D, h as La, e as Ut, c as ss, f as Ce, g as oe, m as Fs, i as Aa, j as Ma, k as tn, l as Dt, n as wa, o as Ll, q as Al, u as zi, D as I, v as Ml, w as gi, G as Ca, x as hs, y as wl, a as Cl, p as bt, r as ka, b as kl } from "./angle-utils-jnw9HSFu.mjs";
import { b as qr, c as pt, a as Ui, s as _l } from "./array-CmsYzTI6.mjs";
function Il(i, t, e, n) {
  for (var s = -1, a = i == null ? 0 : i.length; ++s < a; )
    e = t(e, i[s], s, i);
  return e;
}
function Rl(i) {
  return function(t) {
    return i?.[t];
  };
}
var Dl = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Nl = Rl(Dl), Pl = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, $l = "\\u0300-\\u036f", Vl = "\\ufe20-\\ufe2f", Gl = "\\u20d0-\\u20ff", Hl = $l + Vl + Gl, Bl = "[" + Hl + "]", zl = RegExp(Bl, "g");
function Ul(i) {
  return i = Br(i), i && i.replace(Pl, Nl).replace(zl, "");
}
var Fl = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Wl(i) {
  return i.match(Fl) || [];
}
var Xl = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Yl(i) {
  return Xl.test(i);
}
var jr = "\\ud800-\\udfff", Zl = "\\u0300-\\u036f", ql = "\\ufe20-\\ufe2f", jl = "\\u20d0-\\u20ff", Kl = Zl + ql + jl, Kr = "\\u2700-\\u27bf", Jr = "a-z\\xdf-\\xf6\\xf8-\\xff", Jl = "\\xac\\xb1\\xd7\\xf7", Ql = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", tc = "\\u2000-\\u206f", ec = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Qr = "A-Z\\xc0-\\xd6\\xd8-\\xde", nc = "\\ufe0e\\ufe0f", to = Jl + Ql + tc + ec, eo = "['’]", _a = "[" + to + "]", sc = "[" + Kl + "]", no = "\\d+", ic = "[" + Kr + "]", so = "[" + Jr + "]", io = "[^" + jr + to + no + Kr + Jr + Qr + "]", ac = "\\ud83c[\\udffb-\\udfff]", rc = "(?:" + sc + "|" + ac + ")", oc = "[^" + jr + "]", ao = "(?:\\ud83c[\\udde6-\\uddff]){2}", ro = "[\\ud800-\\udbff][\\udc00-\\udfff]", qe = "[" + Qr + "]", lc = "\\u200d", Ia = "(?:" + so + "|" + io + ")", cc = "(?:" + qe + "|" + io + ")", Ra = "(?:" + eo + "(?:d|ll|m|re|s|t|ve))?", Da = "(?:" + eo + "(?:D|LL|M|RE|S|T|VE))?", oo = rc + "?", lo = "[" + nc + "]?", uc = "(?:" + lc + "(?:" + [oc, ao, ro].join("|") + ")" + lo + oo + ")*", hc = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", dc = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", pc = lo + oo + uc, fc = "(?:" + [ic, ao, ro].join("|") + ")" + pc, gc = RegExp([
  qe + "?" + so + "+" + Ra + "(?=" + [_a, qe, "$"].join("|") + ")",
  cc + "+" + Da + "(?=" + [_a, qe + Ia, "$"].join("|") + ")",
  qe + "?" + Ia + "+" + Ra,
  qe + "+" + Da,
  dc,
  hc,
  no,
  fc
].join("|"), "g");
function mc(i) {
  return i.match(gc) || [];
}
function vc(i, t, e) {
  return i = Br(i), t = t, t === void 0 ? Yl(i) ? mc(i) : Wl(i) : i.match(t) || [];
}
var yc = "['’]", Ec = RegExp(yc, "g");
function xc(i) {
  return function(t) {
    return Il(vc(Ul(t).replace(Ec, "")), i, "");
  };
}
function Sc(i, t, e) {
  return i === i && (e !== void 0 && (i = i <= e ? i : e), t !== void 0 && (i = i >= t ? i : t)), i;
}
function co(i, t, e) {
  return e === void 0 && (e = t, t = void 0), e !== void 0 && (e = ns(e), e = e === e ? e : 0), t !== void 0 && (t = ns(t), t = t === t ? t : 0), Sc(ns(i), t, e);
}
var Tc = "Expected a function";
function bc(i, t, e) {
  if (typeof i != "function")
    throw new TypeError(Tc);
  return setTimeout(function() {
    i.apply(void 0, e);
  }, t);
}
var Oc = ol(function(i, t, e) {
  return bc(i, ns(t) || 0, e);
});
function Lc(i, t) {
  var e = -1, n = ll(i) ? Array(i.length) : [];
  return qr(i, function(s, a, r) {
    n[++e] = t(s, a, r);
  }), n;
}
function Ac(i, t) {
  var e = Ur(i) ? cl : Lc;
  return e(i, zr(t));
}
var Mc = 1 / 0;
function wc(i, t) {
  return ul(Ac(i, t), Mc);
}
function uo(i, t) {
  return hl(i, t);
}
var Fe = xc(function(i, t, e) {
  return i + (e ? "-" : "") + t.toLowerCase();
});
function Cc(i, t) {
  var e;
  return qr(i, function(n, s, a) {
    return e = t(n, s, a), !e;
  }), !!e;
}
function kc(i, t, e) {
  var n = Ur(i) ? dl : Cc;
  return n(i, zr(t));
}
class De {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const e = this._partials;
    let n = 0;
    for (let s = 0; s < this._n && s < 32; s++) {
      const a = e[s], r = t + a, o = Math.abs(t) < Math.abs(a) ? t - (r - a) : a - (r - t);
      o && (e[n++] = o), t = r;
    }
    return e[n] = t, this._n = n + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let e = this._n, n, s, a, r = 0;
    if (e > 0) {
      for (r = t[--e]; e > 0 && (n = r, s = t[--e], r = n + s, a = s - (r - n), !a); )
        ;
      e > 0 && (a < 0 && t[e - 1] < 0 || a > 0 && t[e - 1] > 0) && (s = a * 2, n = r + s, s == n - r && (r = n));
    }
    return r;
  }
}
function* _c(i) {
  for (const t of i)
    yield* t;
}
function ho(i) {
  return Array.from(_c(i));
}
function Ic(i) {
  return i;
}
var is = 1, as = 2, mi = 3, En = 4, Na = 1e-6;
function Rc(i) {
  return "translate(" + i + ",0)";
}
function Dc(i) {
  return "translate(0," + i + ")";
}
function Nc(i) {
  return (t) => +i(t);
}
function Pc(i, t) {
  return t = Math.max(0, i.bandwidth() - t * 2) / 2, i.round() && (t = Math.round(t)), (e) => +i(e) + t;
}
function $c() {
  return !this.__axis;
}
function As(i, t) {
  var e = [], n = null, s = null, a = 6, r = 6, o = 3, c = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, l = i === is || i === En ? -1 : 1, h = i === En || i === as ? "x" : "y", d = i === is || i === mi ? Rc : Dc;
  function u(p) {
    var f = n ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), m = s ?? (t.tickFormat ? t.tickFormat.apply(t, e) : Ic), g = Math.max(a, 0) + o, v = t.range(), S = +v[0] + c, y = +v[v.length - 1] + c, E = (t.bandwidth ? Pc : Nc)(t.copy(), c), x = p.selection ? p.selection() : p, T = x.selectAll(".domain").data([null]), C = x.selectAll(".tick").data(f, t).order(), _ = C.exit(), V = C.enter().append("g").attr("class", "tick"), R = C.select("line"), A = C.select("text");
    T = T.merge(T.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), C = C.merge(V), R = R.merge(V.append("line").attr("stroke", "currentColor").attr(h + "2", l * a)), A = A.merge(V.append("text").attr("fill", "currentColor").attr(h, l * g).attr("dy", i === is ? "0em" : i === mi ? "0.71em" : "0.32em")), p !== x && (T = T.transition(p), C = C.transition(p), R = R.transition(p), A = A.transition(p), _ = _.transition(p).attr("opacity", Na).attr("transform", function(H) {
      return isFinite(H = E(H)) ? d(H + c) : this.getAttribute("transform");
    }), V.attr("opacity", Na).attr("transform", function(H) {
      var N = this.parentNode.__axis;
      return d((N && isFinite(N = N(H)) ? N : E(H)) + c);
    })), _.remove(), T.attr("d", i === En || i === as ? r ? "M" + l * r + "," + S + "H" + c + "V" + y + "H" + l * r : "M" + c + "," + S + "V" + y : r ? "M" + S + "," + l * r + "V" + c + "H" + y + "V" + l * r : "M" + S + "," + c + "H" + y), C.attr("opacity", 1).attr("transform", function(H) {
      return d(E(H) + c);
    }), R.attr(h + "2", l * a), A.attr(h, l * g).text(m), x.filter($c).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", i === as ? "start" : i === En ? "end" : "middle"), x.each(function() {
      this.__axis = E;
    });
  }
  return u.scale = function(p) {
    return arguments.length ? (t = p, u) : t;
  }, u.ticks = function() {
    return e = Array.from(arguments), u;
  }, u.tickArguments = function(p) {
    return arguments.length ? (e = p == null ? [] : Array.from(p), u) : e.slice();
  }, u.tickValues = function(p) {
    return arguments.length ? (n = p == null ? null : Array.from(p), u) : n && n.slice();
  }, u.tickFormat = function(p) {
    return arguments.length ? (s = p, u) : s;
  }, u.tickSize = function(p) {
    return arguments.length ? (a = r = +p, u) : a;
  }, u.tickSizeInner = function(p) {
    return arguments.length ? (a = +p, u) : a;
  }, u.tickSizeOuter = function(p) {
    return arguments.length ? (r = +p, u) : r;
  }, u.tickPadding = function(p) {
    return arguments.length ? (o = +p, u) : o;
  }, u.offset = function(p) {
    return arguments.length ? (c = +p, u) : c;
  }, u;
}
function Vc(i) {
  return As(is, i);
}
function Gc(i) {
  return As(as, i);
}
function Fi(i) {
  return As(mi, i);
}
function po(i) {
  return As(En, i);
}
const vi = { capture: !0, passive: !1 };
function yi(i) {
  i.preventDefault(), i.stopImmediatePropagation();
}
function Hc(i) {
  var t = i.document.documentElement, e = D(i).on("dragstart.drag", yi, vi);
  "onselectstart" in t ? e.on("selectstart.drag", yi, vi) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Bc(i, t) {
  var e = i.document.documentElement, n = D(i).on("dragstart.drag", null);
  t && (n.on("click.drag", yi, vi), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in e ? n.on("selectstart.drag", null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect);
}
function zc(i, t) {
  for (var e = new Array(t), n = 0; n < t; ++n) e[n] = i(n / (t - 1));
  return e;
}
const Uc = (i) => +i, Ws = (i) => () => i;
function Fc(i, {
  sourceEvent: t,
  target: e,
  selection: n,
  mode: s,
  dispatch: a
}) {
  Object.defineProperties(this, {
    type: { value: i, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: e, enumerable: !0, configurable: !0 },
    selection: { value: n, enumerable: !0, configurable: !0 },
    mode: { value: s, enumerable: !0, configurable: !0 },
    _: { value: a }
  });
}
function Wc(i) {
  i.stopImmediatePropagation();
}
function Xs(i) {
  i.preventDefault(), i.stopImmediatePropagation();
}
var Pa = { name: "drag" }, Ys = { name: "space" }, We = { name: "handle" }, Xe = { name: "center" };
const { abs: $a, max: Nt, min: Pt } = Math;
function Va(i) {
  return [+i[0], +i[1]];
}
function Ga(i) {
  return [Va(i[0]), Va(i[1])];
}
var rs = {
  name: "x",
  handles: ["w", "e"].map(Ei),
  input: function(i, t) {
    return i == null ? null : [[+i[0], t[0][1]], [+i[1], t[1][1]]];
  },
  output: function(i) {
    return i && [i[0][0], i[1][0]];
  }
}, Zs = {}, fe = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, Ha = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, Ba = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, Xc = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, Yc = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Ei(i) {
  return { type: i };
}
function Zc(i) {
  return !i.ctrlKey && !i.button;
}
function qc() {
  var i = this.ownerSVGElement || this;
  return i.hasAttribute("viewBox") ? (i = i.viewBox.baseVal, [[i.x, i.y], [i.x + i.width, i.y + i.height]]) : [[0, 0], [i.width.baseVal.value, i.height.baseVal.value]];
}
function jc() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function qs(i) {
  for (; !i.__brush; ) if (!(i = i.parentNode)) return;
  return i.__brush;
}
function Kc(i) {
  return i[0][0] === i[1][0] || i[0][1] === i[1][1];
}
function fo() {
  return Jc(rs);
}
function Jc(i) {
  var t = qc, e = Zc, n = jc, s = !0, a = pl("start", "brush", "end"), r = 6, o;
  function c(g) {
    var v = g.property("__brush", m).selectAll(".overlay").data([Ei("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", fe.overlay).merge(v).each(function() {
      var y = qs(this).extent;
      D(this).attr("x", y[0][0]).attr("y", y[0][1]).attr("width", y[1][0] - y[0][0]).attr("height", y[1][1] - y[0][1]);
    }), g.selectAll(".selection").data([Ei("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", fe.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var S = g.selectAll(".handle").data(i.handles, function(y) {
      return y.type;
    });
    S.exit().remove(), S.enter().append("rect").attr("class", function(y) {
      return "handle handle--" + y.type;
    }).attr("cursor", function(y) {
      return fe[y.type];
    }), g.each(l).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", u).filter(n).on("touchstart.brush", u).on("touchmove.brush", p).on("touchend.brush touchcancel.brush", f).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  c.move = function(g, v, S) {
    g.tween ? g.on("start.brush", function(y) {
      h(this, arguments).beforestart().start(y);
    }).on("interrupt.brush end.brush", function(y) {
      h(this, arguments).end(y);
    }).tween("brush", function() {
      var y = this, E = y.__brush, x = h(y, arguments), T = E.selection, C = i.input(typeof v == "function" ? v.apply(this, arguments) : v, E.extent), _ = Fr(T, C);
      function V(R) {
        E.selection = R === 1 && C === null ? null : _(R), l.call(y), x.brush();
      }
      return T !== null && C !== null ? V : V(1);
    }) : g.each(function() {
      var y = this, E = arguments, x = y.__brush, T = i.input(typeof v == "function" ? v.apply(y, E) : v, x.extent), C = h(y, E).beforestart();
      ya(y), x.selection = T === null ? null : T, l.call(y), C.start(S).brush(S).end(S);
    });
  }, c.clear = function(g, v) {
    c.move(g, null, v);
  };
  function l() {
    var g = D(this), v = qs(this).selection;
    v ? (g.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), g.selectAll(".handle").style("display", null).attr("x", function(S) {
      return S.type[S.type.length - 1] === "e" ? v[1][0] - r / 2 : v[0][0] - r / 2;
    }).attr("y", function(S) {
      return S.type[0] === "s" ? v[1][1] - r / 2 : v[0][1] - r / 2;
    }).attr("width", function(S) {
      return S.type === "n" || S.type === "s" ? v[1][0] - v[0][0] + r : r;
    }).attr("height", function(S) {
      return S.type === "e" || S.type === "w" ? v[1][1] - v[0][1] + r : r;
    })) : g.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function h(g, v, S) {
    var y = g.__brush.emitter;
    return y && (!S || !y.clean) ? y : new d(g, v, S);
  }
  function d(g, v, S) {
    this.that = g, this.args = v, this.state = g.__brush, this.active = 0, this.clean = S;
  }
  d.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(g, v) {
      return this.starting ? (this.starting = !1, this.emit("start", g, v)) : this.emit("brush", g), this;
    },
    brush: function(g, v) {
      return this.emit("brush", g, v), this;
    },
    end: function(g, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", g, v)), this;
    },
    emit: function(g, v, S) {
      var y = D(this.that).datum();
      a.call(
        g,
        this.that,
        new Fc(g, {
          sourceEvent: v,
          target: c,
          selection: i.output(this.state.selection),
          mode: S,
          dispatch: a
        }),
        y
      );
    }
  };
  function u(g) {
    if (o && !g.touches || !e.apply(this, arguments)) return;
    var v = this, S = g.target.__data__.type, y = (s && g.metaKey ? S = "overlay" : S) === "selection" ? Pa : s && g.altKey ? Xe : We, E = i === Zs ? null : Xc[S], x = i === rs ? null : Yc[S], T = qs(v), C = T.extent, _ = T.selection, V = C[0][0], R, A, H = C[0][1], N, M, L = C[1][0], P, $, k = C[1][1], G, q, X = 0, F = 0, Z, rt = E && x && s && g.shiftKey, j, Y, K = Array.from(g.touches || [g], (et) => {
      const yt = et.identifier;
      return et = an(et, v), et.point0 = et.slice(), et.identifier = yt, et;
    });
    ya(v);
    var ot = h(v, arguments, !0).beforestart();
    if (S === "overlay") {
      _ && (Z = !0);
      const et = [K[0], K[1] || K[0]];
      T.selection = _ = [[
        R = i === Zs ? V : Pt(et[0][0], et[1][0]),
        N = i === rs ? H : Pt(et[0][1], et[1][1])
      ], [
        P = i === Zs ? L : Nt(et[0][0], et[1][0]),
        G = i === rs ? k : Nt(et[0][1], et[1][1])
      ]], K.length > 1 && B(g);
    } else
      R = _[0][0], N = _[0][1], P = _[1][0], G = _[1][1];
    A = R, M = N, $ = P, q = G;
    var ct = D(v).attr("pointer-events", "none"), st = ct.selectAll(".overlay").attr("cursor", fe[S]);
    if (g.touches)
      ot.moved = z, ot.ended = U;
    else {
      var it = D(g.view).on("mousemove.brush", z, !0).on("mouseup.brush", U, !0);
      s && it.on("keydown.brush", wt, !0).on("keyup.brush", Te, !0), Hc(g.view);
    }
    l.call(v), ot.start(g, y.name);
    function z(et) {
      for (const yt of et.changedTouches || [et])
        for (const Zt of K)
          Zt.identifier === yt.identifier && (Zt.cur = an(yt, v));
      if (rt && !j && !Y && K.length === 1) {
        const yt = K[0];
        $a(yt.cur[0] - yt[0]) > $a(yt.cur[1] - yt[1]) ? Y = !0 : j = !0;
      }
      for (const yt of K)
        yt.cur && (yt[0] = yt.cur[0], yt[1] = yt.cur[1]);
      Z = !0, Xs(et), B(et);
    }
    function B(et) {
      const yt = K[0], Zt = yt.point0;
      var Wt;
      switch (X = yt[0] - Zt[0], F = yt[1] - Zt[1], y) {
        case Ys:
        case Pa: {
          E && (X = Nt(V - R, Pt(L - P, X)), A = R + X, $ = P + X), x && (F = Nt(H - N, Pt(k - G, F)), M = N + F, q = G + F);
          break;
        }
        case We: {
          K[1] ? (E && (A = Nt(V, Pt(L, K[0][0])), $ = Nt(V, Pt(L, K[1][0])), E = 1), x && (M = Nt(H, Pt(k, K[0][1])), q = Nt(H, Pt(k, K[1][1])), x = 1)) : (E < 0 ? (X = Nt(V - R, Pt(L - R, X)), A = R + X, $ = P) : E > 0 && (X = Nt(V - P, Pt(L - P, X)), A = R, $ = P + X), x < 0 ? (F = Nt(H - N, Pt(k - N, F)), M = N + F, q = G) : x > 0 && (F = Nt(H - G, Pt(k - G, F)), M = N, q = G + F));
          break;
        }
        case Xe: {
          E && (A = Nt(V, Pt(L, R - X * E)), $ = Nt(V, Pt(L, P + X * E))), x && (M = Nt(H, Pt(k, N - F * x)), q = Nt(H, Pt(k, G + F * x)));
          break;
        }
      }
      $ < A && (E *= -1, Wt = R, R = P, P = Wt, Wt = A, A = $, $ = Wt, S in Ha && st.attr("cursor", fe[S = Ha[S]])), q < M && (x *= -1, Wt = N, N = G, G = Wt, Wt = M, M = q, q = Wt, S in Ba && st.attr("cursor", fe[S = Ba[S]])), T.selection && (_ = T.selection), j && (A = _[0][0], $ = _[1][0]), Y && (M = _[0][1], q = _[1][1]), (_[0][0] !== A || _[0][1] !== M || _[1][0] !== $ || _[1][1] !== q) && (T.selection = [[A, M], [$, q]], l.call(v), ot.brush(et, y.name));
    }
    function U(et) {
      if (Wc(et), et.touches) {
        if (et.touches.length) return;
        o && clearTimeout(o), o = setTimeout(function() {
          o = null;
        }, 500);
      } else
        Bc(et.view, Z), it.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      ct.attr("pointer-events", "all"), st.attr("cursor", fe.overlay), T.selection && (_ = T.selection), Kc(_) && (T.selection = null, l.call(v)), ot.end(et, y.name);
    }
    function wt(et) {
      switch (et.keyCode) {
        case 16: {
          rt = E && x;
          break;
        }
        case 18: {
          y === We && (E && (P = $ - X * E, R = A + X * E), x && (G = q - F * x, N = M + F * x), y = Xe, B(et));
          break;
        }
        case 32: {
          (y === We || y === Xe) && (E < 0 ? P = $ - X : E > 0 && (R = A - X), x < 0 ? G = q - F : x > 0 && (N = M - F), y = Ys, st.attr("cursor", fe.selection), B(et));
          break;
        }
        default:
          return;
      }
      Xs(et);
    }
    function Te(et) {
      switch (et.keyCode) {
        case 16: {
          rt && (j = Y = rt = !1, B(et));
          break;
        }
        case 18: {
          y === Xe && (E < 0 ? P = $ : E > 0 && (R = A), x < 0 ? G = q : x > 0 && (N = M), y = We, B(et));
          break;
        }
        case 32: {
          y === Ys && (et.altKey ? (E && (P = $ - X * E, R = A + X * E), x && (G = q - F * x, N = M + F * x), y = Xe) : (E < 0 ? P = $ : E > 0 && (R = A), x < 0 ? G = q : x > 0 && (N = M), y = We), st.attr("cursor", fe[S]), B(et));
          break;
        }
        default:
          return;
      }
      Xs(et);
    }
  }
  function p(g) {
    h(this, arguments).moved(g);
  }
  function f(g) {
    h(this, arguments).ended(g);
  }
  function m() {
    var g = this.__brush || { selection: null };
    return g.extent = Ga(t.apply(this, arguments)), g.dim = i, g;
  }
  return c.extent = function(g) {
    return arguments.length ? (t = typeof g == "function" ? g : Ws(Ga(g)), c) : t;
  }, c.filter = function(g) {
    return arguments.length ? (e = typeof g == "function" ? g : Ws(!!g), c) : e;
  }, c.touchable = function(g) {
    return arguments.length ? (n = typeof g == "function" ? g : Ws(!!g), c) : n;
  }, c.handleSize = function(g) {
    return arguments.length ? (r = +g, c) : r;
  }, c.keyModifiers = function(g) {
    return arguments.length ? (s = !!g, c) : s;
  }, c.on = function() {
    var g = a.on.apply(a, arguments);
    return g === a ? c : g;
  }, c;
}
const xi = Math.PI, Si = 2 * xi, ke = 1e-6, Qc = Si - ke;
function go(i) {
  this._ += i[0];
  for (let t = 1, e = i.length; t < e; ++t)
    this._ += arguments[t] + i[t];
}
function tu(i) {
  let t = Math.floor(i);
  if (!(t >= 0)) throw new Error(`invalid digits: ${i}`);
  if (t > 15) return go;
  const e = 10 ** t;
  return function(n) {
    this._ += n[0];
    for (let s = 1, a = n.length; s < a; ++s)
      this._ += Math.round(arguments[s] * e) / e + n[s];
  };
}
let Wi = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? go : tu(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, n, s) {
    this._append`Q${+t},${+e},${this._x1 = +n},${this._y1 = +s}`;
  }
  bezierCurveTo(t, e, n, s, a, r) {
    this._append`C${+t},${+e},${+n},${+s},${this._x1 = +a},${this._y1 = +r}`;
  }
  arcTo(t, e, n, s, a) {
    if (t = +t, e = +e, n = +n, s = +s, a = +a, a < 0) throw new Error(`negative radius: ${a}`);
    let r = this._x1, o = this._y1, c = n - t, l = s - e, h = r - t, d = o - e, u = h * h + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (u > ke) if (!(Math.abs(d * c - l * h) > ke) || !a)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let p = n - r, f = s - o, m = c * c + l * l, g = p * p + f * f, v = Math.sqrt(m), S = Math.sqrt(u), y = a * Math.tan((xi - Math.acos((m + u - g) / (2 * v * S))) / 2), E = y / S, x = y / v;
      Math.abs(E - 1) > ke && this._append`L${t + E * h},${e + E * d}`, this._append`A${a},${a},0,0,${+(d * p > h * f)},${this._x1 = t + x * c},${this._y1 = e + x * l}`;
    }
  }
  arc(t, e, n, s, a, r) {
    if (t = +t, e = +e, n = +n, r = !!r, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(s), c = n * Math.sin(s), l = t + o, h = e + c, d = 1 ^ r, u = r ? s - a : a - s;
    this._x1 === null ? this._append`M${l},${h}` : (Math.abs(this._x1 - l) > ke || Math.abs(this._y1 - h) > ke) && this._append`L${l},${h}`, n && (u < 0 && (u = u % Si + Si), u > Qc ? this._append`A${n},${n},0,1,${d},${t - o},${e - c}A${n},${n},0,1,${d},${this._x1 = l},${this._y1 = h}` : u > ke && this._append`A${n},${n},0,${+(u >= xi)},${d},${this._x1 = t + n * Math.cos(a)},${this._y1 = e + n * Math.sin(a)}`);
  }
  rect(t, e, n, s) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${n = +n}v${+s}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function Ms() {
  return new Wi();
}
Ms.prototype = Wi.prototype;
var gt = 1e-6, mo = 1e-12, ht = Math.PI, Ft = ht / 2, za = ht / 4, Yt = ht * 2, Vt = 180 / ht, Ot = ht / 180, mt = Math.abs, vo = Math.atan, Ne = Math.atan2, vt = Math.cos, eu = Math.exp, nu = Math.log, ft = Math.sin, Oe = Math.sign || function(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}, ae = Math.sqrt, su = Math.tan;
function iu(i) {
  return i > 1 ? 0 : i < -1 ? ht : Math.acos(i);
}
function Se(i) {
  return i > 1 ? Ft : i < -1 ? -Ft : Math.asin(i);
}
function Qt() {
}
function ds(i, t) {
  i && Fa.hasOwnProperty(i.type) && Fa[i.type](i, t);
}
var Ua = {
  Feature: function(i, t) {
    ds(i.geometry, t);
  },
  FeatureCollection: function(i, t) {
    for (var e = i.features, n = -1, s = e.length; ++n < s; ) ds(e[n].geometry, t);
  }
}, Fa = {
  Sphere: function(i, t) {
    t.sphere();
  },
  Point: function(i, t) {
    i = i.coordinates, t.point(i[0], i[1], i[2]);
  },
  MultiPoint: function(i, t) {
    for (var e = i.coordinates, n = -1, s = e.length; ++n < s; ) i = e[n], t.point(i[0], i[1], i[2]);
  },
  LineString: function(i, t) {
    Ti(i.coordinates, t, 0);
  },
  MultiLineString: function(i, t) {
    for (var e = i.coordinates, n = -1, s = e.length; ++n < s; ) Ti(e[n], t, 0);
  },
  Polygon: function(i, t) {
    Wa(i.coordinates, t);
  },
  MultiPolygon: function(i, t) {
    for (var e = i.coordinates, n = -1, s = e.length; ++n < s; ) Wa(e[n], t);
  },
  GeometryCollection: function(i, t) {
    for (var e = i.geometries, n = -1, s = e.length; ++n < s; ) ds(e[n], t);
  }
};
function Ti(i, t, e) {
  var n = -1, s = i.length - e, a;
  for (t.lineStart(); ++n < s; ) a = i[n], t.point(a[0], a[1], a[2]);
  t.lineEnd();
}
function Wa(i, t) {
  var e = -1, n = i.length;
  for (t.polygonStart(); ++e < n; ) Ti(i[e], t, 1);
  t.polygonEnd();
}
function je(i, t) {
  i && Ua.hasOwnProperty(i.type) ? Ua[i.type](i, t) : ds(i, t);
}
function bi(i) {
  return [Ne(i[1], i[0]), Se(i[2])];
}
function rn(i) {
  var t = i[0], e = i[1], n = vt(e);
  return [n * vt(t), n * ft(t), ft(e)];
}
function Wn(i, t) {
  return i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
}
function ps(i, t) {
  return [i[1] * t[2] - i[2] * t[1], i[2] * t[0] - i[0] * t[2], i[0] * t[1] - i[1] * t[0]];
}
function js(i, t) {
  i[0] += t[0], i[1] += t[1], i[2] += t[2];
}
function Xn(i, t) {
  return [i[0] * t, i[1] * t, i[2] * t];
}
function Oi(i) {
  var t = ae(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
  i[0] /= t, i[1] /= t, i[2] /= t;
}
function Li(i, t) {
  function e(n, s) {
    return n = i(n, s), t(n[0], n[1]);
  }
  return i.invert && t.invert && (e.invert = function(n, s) {
    return n = t.invert(n, s), n && i.invert(n[0], n[1]);
  }), e;
}
function Ai(i, t) {
  return mt(i) > ht && (i -= Math.round(i / Yt) * Yt), [i, t];
}
Ai.invert = Ai;
function yo(i, t, e) {
  return (i %= Yt) ? t || e ? Li(Ya(i), Za(t, e)) : Ya(i) : t || e ? Za(t, e) : Ai;
}
function Xa(i) {
  return function(t, e) {
    return t += i, mt(t) > ht && (t -= Math.round(t / Yt) * Yt), [t, e];
  };
}
function Ya(i) {
  var t = Xa(i);
  return t.invert = Xa(-i), t;
}
function Za(i, t) {
  var e = vt(i), n = ft(i), s = vt(t), a = ft(t);
  function r(o, c) {
    var l = vt(c), h = vt(o) * l, d = ft(o) * l, u = ft(c), p = u * e + h * n;
    return [
      Ne(d * s - p * a, h * e - u * n),
      Se(p * s + d * a)
    ];
  }
  return r.invert = function(o, c) {
    var l = vt(c), h = vt(o) * l, d = ft(o) * l, u = ft(c), p = u * s - d * a;
    return [
      Ne(d * s + u * a, h * e + p * n),
      Se(p * e - h * n)
    ];
  }, r;
}
function au(i) {
  i = yo(i[0] * Ot, i[1] * Ot, i.length > 2 ? i[2] * Ot : 0);
  function t(e) {
    return e = i(e[0] * Ot, e[1] * Ot), e[0] *= Vt, e[1] *= Vt, e;
  }
  return t.invert = function(e) {
    return e = i.invert(e[0] * Ot, e[1] * Ot), e[0] *= Vt, e[1] *= Vt, e;
  }, t;
}
function ru(i, t, e, n, s, a) {
  if (e) {
    var r = vt(t), o = ft(t), c = n * e;
    s == null ? (s = t + n * Yt, a = t - c / 2) : (s = qa(r, s), a = qa(r, a), (n > 0 ? s < a : s > a) && (s += n * Yt));
    for (var l, h = s; n > 0 ? h > a : h < a; h -= c)
      l = bi([r, -o * vt(h), -o * ft(h)]), i.point(l[0], l[1]);
  }
}
function qa(i, t) {
  t = rn(t), t[0] -= i, Oi(t);
  var e = iu(-t[1]);
  return ((-t[2] < 0 ? -e : e) + Yt - gt) % Yt;
}
function Eo() {
  var i = [], t;
  return {
    point: function(e, n, s) {
      t.push([e, n, s]);
    },
    lineStart: function() {
      i.push(t = []);
    },
    lineEnd: Qt,
    rejoin: function() {
      i.length > 1 && i.push(i.pop().concat(i.shift()));
    },
    result: function() {
      var e = i;
      return i = [], t = null, e;
    }
  };
}
function os(i, t) {
  return mt(i[0] - t[0]) < gt && mt(i[1] - t[1]) < gt;
}
function Yn(i, t, e, n) {
  this.x = i, this.z = t, this.o = e, this.e = n, this.v = !1, this.n = this.p = null;
}
function xo(i, t, e, n, s) {
  var a = [], r = [], o, c;
  if (i.forEach(function(f) {
    if (!((m = f.length - 1) <= 0)) {
      var m, g = f[0], v = f[m], S;
      if (os(g, v)) {
        if (!g[2] && !v[2]) {
          for (s.lineStart(), o = 0; o < m; ++o) s.point((g = f[o])[0], g[1]);
          s.lineEnd();
          return;
        }
        v[0] += 2 * gt;
      }
      a.push(S = new Yn(g, f, null, !0)), r.push(S.o = new Yn(g, null, S, !1)), a.push(S = new Yn(v, f, null, !1)), r.push(S.o = new Yn(v, null, S, !0));
    }
  }), !!a.length) {
    for (r.sort(t), ja(a), ja(r), o = 0, c = r.length; o < c; ++o)
      r[o].e = e = !e;
    for (var l = a[0], h, d; ; ) {
      for (var u = l, p = !0; u.v; ) if ((u = u.n) === l) return;
      h = u.z, s.lineStart();
      do {
        if (u.v = u.o.v = !0, u.e) {
          if (p)
            for (o = 0, c = h.length; o < c; ++o) s.point((d = h[o])[0], d[1]);
          else
            n(u.x, u.n.x, 1, s);
          u = u.n;
        } else {
          if (p)
            for (h = u.p.z, o = h.length - 1; o >= 0; --o) s.point((d = h[o])[0], d[1]);
          else
            n(u.x, u.p.x, -1, s);
          u = u.p;
        }
        u = u.o, h = u.z, p = !p;
      } while (!u.v);
      s.lineEnd();
    }
  }
}
function ja(i) {
  if (t = i.length) {
    for (var t, e = 0, n = i[0], s; ++e < t; )
      n.n = s = i[e], s.p = n, n = s;
    n.n = s = i[0], s.p = n;
  }
}
function Ks(i) {
  return mt(i[0]) <= ht ? i[0] : Oe(i[0]) * ((mt(i[0]) + ht) % Yt - ht);
}
function ou(i, t) {
  var e = Ks(t), n = t[1], s = ft(n), a = [ft(e), -vt(e), 0], r = 0, o = 0, c = new De();
  s === 1 ? n = Ft + gt : s === -1 && (n = -Ft - gt);
  for (var l = 0, h = i.length; l < h; ++l)
    if (u = (d = i[l]).length)
      for (var d, u, p = d[u - 1], f = Ks(p), m = p[1] / 2 + za, g = ft(m), v = vt(m), S = 0; S < u; ++S, f = E, g = T, v = C, p = y) {
        var y = d[S], E = Ks(y), x = y[1] / 2 + za, T = ft(x), C = vt(x), _ = E - f, V = _ >= 0 ? 1 : -1, R = V * _, A = R > ht, H = g * T;
        if (c.add(Ne(H * V * ft(R), v * C + H * vt(R))), r += A ? _ + V * Yt : _, A ^ f >= e ^ E >= e) {
          var N = ps(rn(p), rn(y));
          Oi(N);
          var M = ps(a, N);
          Oi(M);
          var L = (A ^ _ >= 0 ? -1 : 1) * Se(M[2]);
          (n > L || n === L && (N[0] || N[1])) && (o += A ^ _ >= 0 ? 1 : -1);
        }
      }
  return (r < -gt || r < gt && c < -mo) ^ o & 1;
}
function So(i, t, e, n) {
  return function(s) {
    var a = t(s), r = Eo(), o = t(r), c = !1, l, h, d, u = {
      point: p,
      lineStart: m,
      lineEnd: g,
      polygonStart: function() {
        u.point = v, u.lineStart = S, u.lineEnd = y, h = [], l = [];
      },
      polygonEnd: function() {
        u.point = p, u.lineStart = m, u.lineEnd = g, h = ho(h);
        var E = ou(l, n);
        h.length ? (c || (s.polygonStart(), c = !0), xo(h, cu, E, e, s)) : E && (c || (s.polygonStart(), c = !0), s.lineStart(), e(null, null, 1, s), s.lineEnd()), c && (s.polygonEnd(), c = !1), h = l = null;
      },
      sphere: function() {
        s.polygonStart(), s.lineStart(), e(null, null, 1, s), s.lineEnd(), s.polygonEnd();
      }
    };
    function p(E, x) {
      i(E, x) && s.point(E, x);
    }
    function f(E, x) {
      a.point(E, x);
    }
    function m() {
      u.point = f, a.lineStart();
    }
    function g() {
      u.point = p, a.lineEnd();
    }
    function v(E, x) {
      d.push([E, x]), o.point(E, x);
    }
    function S() {
      o.lineStart(), d = [];
    }
    function y() {
      v(d[0][0], d[0][1]), o.lineEnd();
      var E = o.clean(), x = r.result(), T, C = x.length, _, V, R;
      if (d.pop(), l.push(d), d = null, !!C) {
        if (E & 1) {
          if (V = x[0], (_ = V.length - 1) > 0) {
            for (c || (s.polygonStart(), c = !0), s.lineStart(), T = 0; T < _; ++T) s.point((R = V[T])[0], R[1]);
            s.lineEnd();
          }
          return;
        }
        C > 1 && E & 2 && x.push(x.pop().concat(x.shift())), h.push(x.filter(lu));
      }
    }
    return u;
  };
}
function lu(i) {
  return i.length > 1;
}
function cu(i, t) {
  return ((i = i.x)[0] < 0 ? i[1] - Ft - gt : Ft - i[1]) - ((t = t.x)[0] < 0 ? t[1] - Ft - gt : Ft - t[1]);
}
const Ka = So(
  function() {
    return !0;
  },
  uu,
  du,
  [-ht, -Ft]
);
function uu(i) {
  var t = NaN, e = NaN, n = NaN, s;
  return {
    lineStart: function() {
      i.lineStart(), s = 1;
    },
    point: function(a, r) {
      var o = a > 0 ? ht : -ht, c = mt(a - t);
      mt(c - ht) < gt ? (i.point(t, e = (e + r) / 2 > 0 ? Ft : -Ft), i.point(n, e), i.lineEnd(), i.lineStart(), i.point(o, e), i.point(a, e), s = 0) : n !== o && c >= ht && (mt(t - n) < gt && (t -= n * gt), mt(a - o) < gt && (a -= o * gt), e = hu(t, e, a, r), i.point(n, e), i.lineEnd(), i.lineStart(), i.point(o, e), s = 0), i.point(t = a, e = r), n = o;
    },
    lineEnd: function() {
      i.lineEnd(), t = e = NaN;
    },
    clean: function() {
      return 2 - s;
    }
  };
}
function hu(i, t, e, n) {
  var s, a, r = ft(i - e);
  return mt(r) > gt ? vo((ft(t) * (a = vt(n)) * ft(e) - ft(n) * (s = vt(t)) * ft(i)) / (s * a * r)) : (t + n) / 2;
}
function du(i, t, e, n) {
  var s;
  if (i == null)
    s = e * Ft, n.point(-ht, s), n.point(0, s), n.point(ht, s), n.point(ht, 0), n.point(ht, -s), n.point(0, -s), n.point(-ht, -s), n.point(-ht, 0), n.point(-ht, s);
  else if (mt(i[0] - t[0]) > gt) {
    var a = i[0] < t[0] ? ht : -ht;
    s = e * a / 2, n.point(-a, s), n.point(0, s), n.point(a, s);
  } else
    n.point(t[0], t[1]);
}
function pu(i) {
  var t = vt(i), e = 2 * Ot, n = t > 0, s = mt(t) > gt;
  function a(h, d, u, p) {
    ru(p, i, e, u, h, d);
  }
  function r(h, d) {
    return vt(h) * vt(d) > t;
  }
  function o(h) {
    var d, u, p, f, m;
    return {
      lineStart: function() {
        f = p = !1, m = 1;
      },
      point: function(g, v) {
        var S = [g, v], y, E = r(g, v), x = n ? E ? 0 : l(g, v) : E ? l(g + (g < 0 ? ht : -ht), v) : 0;
        if (!d && (f = p = E) && h.lineStart(), E !== p && (y = c(d, S), (!y || os(d, y) || os(S, y)) && (S[2] = 1)), E !== p)
          m = 0, E ? (h.lineStart(), y = c(S, d), h.point(y[0], y[1])) : (y = c(d, S), h.point(y[0], y[1], 2), h.lineEnd()), d = y;
        else if (s && d && n ^ E) {
          var T;
          !(x & u) && (T = c(S, d, !0)) && (m = 0, n ? (h.lineStart(), h.point(T[0][0], T[0][1]), h.point(T[1][0], T[1][1]), h.lineEnd()) : (h.point(T[1][0], T[1][1]), h.lineEnd(), h.lineStart(), h.point(T[0][0], T[0][1], 3)));
        }
        E && (!d || !os(d, S)) && h.point(S[0], S[1]), d = S, p = E, u = x;
      },
      lineEnd: function() {
        p && h.lineEnd(), d = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return m | (f && p) << 1;
      }
    };
  }
  function c(h, d, u) {
    var p = rn(h), f = rn(d), m = [1, 0, 0], g = ps(p, f), v = Wn(g, g), S = g[0], y = v - S * S;
    if (!y) return !u && h;
    var E = t * v / y, x = -t * S / y, T = ps(m, g), C = Xn(m, E), _ = Xn(g, x);
    js(C, _);
    var V = T, R = Wn(C, V), A = Wn(V, V), H = R * R - A * (Wn(C, C) - 1);
    if (!(H < 0)) {
      var N = ae(H), M = Xn(V, (-R - N) / A);
      if (js(M, C), M = bi(M), !u) return M;
      var L = h[0], P = d[0], $ = h[1], k = d[1], G;
      P < L && (G = L, L = P, P = G);
      var q = P - L, X = mt(q - ht) < gt, F = X || q < gt;
      if (!X && k < $ && (G = $, $ = k, k = G), F ? X ? $ + k > 0 ^ M[1] < (mt(M[0] - L) < gt ? $ : k) : $ <= M[1] && M[1] <= k : q > ht ^ (L <= M[0] && M[0] <= P)) {
        var Z = Xn(V, (-R + N) / A);
        return js(Z, C), [M, bi(Z)];
      }
    }
  }
  function l(h, d) {
    var u = n ? i : ht - i, p = 0;
    return h < -u ? p |= 1 : h > u && (p |= 2), d < -u ? p |= 4 : d > u && (p |= 8), p;
  }
  return So(r, o, a, n ? [0, -i] : [-ht, i - ht]);
}
function fu(i, t, e, n, s, a) {
  var r = i[0], o = i[1], c = t[0], l = t[1], h = 0, d = 1, u = c - r, p = l - o, f;
  if (f = e - r, !(!u && f > 0)) {
    if (f /= u, u < 0) {
      if (f < h) return;
      f < d && (d = f);
    } else if (u > 0) {
      if (f > d) return;
      f > h && (h = f);
    }
    if (f = s - r, !(!u && f < 0)) {
      if (f /= u, u < 0) {
        if (f > d) return;
        f > h && (h = f);
      } else if (u > 0) {
        if (f < h) return;
        f < d && (d = f);
      }
      if (f = n - o, !(!p && f > 0)) {
        if (f /= p, p < 0) {
          if (f < h) return;
          f < d && (d = f);
        } else if (p > 0) {
          if (f > d) return;
          f > h && (h = f);
        }
        if (f = a - o, !(!p && f < 0)) {
          if (f /= p, p < 0) {
            if (f > d) return;
            f > h && (h = f);
          } else if (p > 0) {
            if (f < h) return;
            f < d && (d = f);
          }
          return h > 0 && (i[0] = r + h * u, i[1] = o + h * p), d < 1 && (t[0] = r + d * u, t[1] = o + d * p), !0;
        }
      }
    }
  }
}
var xn = 1e9, Zn = -xn;
function gu(i, t, e, n) {
  function s(l, h) {
    return i <= l && l <= e && t <= h && h <= n;
  }
  function a(l, h, d, u) {
    var p = 0, f = 0;
    if (l == null || (p = r(l, d)) !== (f = r(h, d)) || c(l, h) < 0 ^ d > 0)
      do
        u.point(p === 0 || p === 3 ? i : e, p > 1 ? n : t);
      while ((p = (p + d + 4) % 4) !== f);
    else
      u.point(h[0], h[1]);
  }
  function r(l, h) {
    return mt(l[0] - i) < gt ? h > 0 ? 0 : 3 : mt(l[0] - e) < gt ? h > 0 ? 2 : 1 : mt(l[1] - t) < gt ? h > 0 ? 1 : 0 : h > 0 ? 3 : 2;
  }
  function o(l, h) {
    return c(l.x, h.x);
  }
  function c(l, h) {
    var d = r(l, 1), u = r(h, 1);
    return d !== u ? d - u : d === 0 ? h[1] - l[1] : d === 1 ? l[0] - h[0] : d === 2 ? l[1] - h[1] : h[0] - l[0];
  }
  return function(l) {
    var h = l, d = Eo(), u, p, f, m, g, v, S, y, E, x, T, C = {
      point: _,
      lineStart: H,
      lineEnd: N,
      polygonStart: R,
      polygonEnd: A
    };
    function _(L, P) {
      s(L, P) && h.point(L, P);
    }
    function V() {
      for (var L = 0, P = 0, $ = p.length; P < $; ++P)
        for (var k = p[P], G = 1, q = k.length, X = k[0], F, Z, rt = X[0], j = X[1]; G < q; ++G)
          F = rt, Z = j, X = k[G], rt = X[0], j = X[1], Z <= n ? j > n && (rt - F) * (n - Z) > (j - Z) * (i - F) && ++L : j <= n && (rt - F) * (n - Z) < (j - Z) * (i - F) && --L;
      return L;
    }
    function R() {
      h = d, u = [], p = [], T = !0;
    }
    function A() {
      var L = V(), P = T && L, $ = (u = ho(u)).length;
      (P || $) && (l.polygonStart(), P && (l.lineStart(), a(null, null, 1, l), l.lineEnd()), $ && xo(u, o, L, a, l), l.polygonEnd()), h = l, u = p = f = null;
    }
    function H() {
      C.point = M, p && p.push(f = []), x = !0, E = !1, S = y = NaN;
    }
    function N() {
      u && (M(m, g), v && E && d.rejoin(), u.push(d.result())), C.point = _, E && h.lineEnd();
    }
    function M(L, P) {
      var $ = s(L, P);
      if (p && f.push([L, P]), x)
        m = L, g = P, v = $, x = !1, $ && (h.lineStart(), h.point(L, P));
      else if ($ && E) h.point(L, P);
      else {
        var k = [S = Math.max(Zn, Math.min(xn, S)), y = Math.max(Zn, Math.min(xn, y))], G = [L = Math.max(Zn, Math.min(xn, L)), P = Math.max(Zn, Math.min(xn, P))];
        fu(k, G, i, t, e, n) ? (E || (h.lineStart(), h.point(k[0], k[1])), h.point(G[0], G[1]), $ || h.lineEnd(), T = !1) : $ && (h.lineStart(), h.point(L, P), T = !1);
      }
      S = L, y = P, E = $;
    }
    return C;
  };
}
const Mi = (i) => i;
var Js = new De(), wi = new De(), To, bo, Ci, ki, Ee = {
  point: Qt,
  lineStart: Qt,
  lineEnd: Qt,
  polygonStart: function() {
    Ee.lineStart = mu, Ee.lineEnd = yu;
  },
  polygonEnd: function() {
    Ee.lineStart = Ee.lineEnd = Ee.point = Qt, Js.add(mt(wi)), wi = new De();
  },
  result: function() {
    var i = Js / 2;
    return Js = new De(), i;
  }
};
function mu() {
  Ee.point = vu;
}
function vu(i, t) {
  Ee.point = Oo, To = Ci = i, bo = ki = t;
}
function Oo(i, t) {
  wi.add(ki * i - Ci * t), Ci = i, ki = t;
}
function yu() {
  Oo(To, bo);
}
var on = 1 / 0, fs = on, _n = -on, gs = _n, ms = {
  point: Eu,
  lineStart: Qt,
  lineEnd: Qt,
  polygonStart: Qt,
  polygonEnd: Qt,
  result: function() {
    var i = [[on, fs], [_n, gs]];
    return _n = gs = -(fs = on = 1 / 0), i;
  }
};
function Eu(i, t) {
  i < on && (on = i), i > _n && (_n = i), t < fs && (fs = t), t > gs && (gs = t);
}
var _i = 0, Ii = 0, Sn = 0, vs = 0, ys = 0, en = 0, Ri = 0, Di = 0, Tn = 0, Lo, Ao, le, ce, Jt = {
  point: Pe,
  lineStart: Ja,
  lineEnd: Qa,
  polygonStart: function() {
    Jt.lineStart = Tu, Jt.lineEnd = bu;
  },
  polygonEnd: function() {
    Jt.point = Pe, Jt.lineStart = Ja, Jt.lineEnd = Qa;
  },
  result: function() {
    var i = Tn ? [Ri / Tn, Di / Tn] : en ? [vs / en, ys / en] : Sn ? [_i / Sn, Ii / Sn] : [NaN, NaN];
    return _i = Ii = Sn = vs = ys = en = Ri = Di = Tn = 0, i;
  }
};
function Pe(i, t) {
  _i += i, Ii += t, ++Sn;
}
function Ja() {
  Jt.point = xu;
}
function xu(i, t) {
  Jt.point = Su, Pe(le = i, ce = t);
}
function Su(i, t) {
  var e = i - le, n = t - ce, s = ae(e * e + n * n);
  vs += s * (le + i) / 2, ys += s * (ce + t) / 2, en += s, Pe(le = i, ce = t);
}
function Qa() {
  Jt.point = Pe;
}
function Tu() {
  Jt.point = Ou;
}
function bu() {
  Mo(Lo, Ao);
}
function Ou(i, t) {
  Jt.point = Mo, Pe(Lo = le = i, Ao = ce = t);
}
function Mo(i, t) {
  var e = i - le, n = t - ce, s = ae(e * e + n * n);
  vs += s * (le + i) / 2, ys += s * (ce + t) / 2, en += s, s = ce * i - le * t, Ri += s * (le + i), Di += s * (ce + t), Tn += s * 3, Pe(le = i, ce = t);
}
function wo(i) {
  this._context = i;
}
wo.prototype = {
  _radius: 4.5,
  pointRadius: function(i) {
    return this._radius = i, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(i, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(i, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(i, t);
        break;
      }
      default: {
        this._context.moveTo(i + this._radius, t), this._context.arc(i, t, this._radius, 0, Yt);
        break;
      }
    }
  },
  result: Qt
};
var Ni = new De(), Qs, Co, ko, bn, On, In = {
  point: Qt,
  lineStart: function() {
    In.point = Lu;
  },
  lineEnd: function() {
    Qs && _o(Co, ko), In.point = Qt;
  },
  polygonStart: function() {
    Qs = !0;
  },
  polygonEnd: function() {
    Qs = null;
  },
  result: function() {
    var i = +Ni;
    return Ni = new De(), i;
  }
};
function Lu(i, t) {
  In.point = _o, Co = bn = i, ko = On = t;
}
function _o(i, t) {
  bn -= i, On -= t, Ni.add(ae(bn * bn + On * On)), bn = i, On = t;
}
let tr, Es, er, nr;
class sr {
  constructor(t) {
    this._append = t == null ? Io : Au(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, e) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${e}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${e}`;
        break;
      }
      default: {
        if (this._append`M${t},${e}`, this._radius !== er || this._append !== Es) {
          const n = this._radius, s = this._;
          this._ = "", this._append`m0,${n}a${n},${n} 0 1,1 0,${-2 * n}a${n},${n} 0 1,1 0,${2 * n}z`, er = n, Es = this._append, nr = this._, this._ = s;
        }
        this._ += nr;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function Io(i) {
  let t = 1;
  this._ += i[0];
  for (const e = i.length; t < e; ++t)
    this._ += arguments[t] + i[t];
}
function Au(i) {
  const t = Math.floor(i);
  if (!(t >= 0)) throw new RangeError(`invalid digits: ${i}`);
  if (t > 15) return Io;
  if (t !== tr) {
    const e = 10 ** t;
    tr = t, Es = function(s) {
      let a = 1;
      this._ += s[0];
      for (const r = s.length; a < r; ++a)
        this._ += Math.round(arguments[a] * e) / e + s[a];
    };
  }
  return Es;
}
function Mu(i, t) {
  let e = 3, n = 4.5, s, a;
  function r(o) {
    return o && (typeof n == "function" && a.pointRadius(+n.apply(this, arguments)), je(o, s(a))), a.result();
  }
  return r.area = function(o) {
    return je(o, s(Ee)), Ee.result();
  }, r.measure = function(o) {
    return je(o, s(In)), In.result();
  }, r.bounds = function(o) {
    return je(o, s(ms)), ms.result();
  }, r.centroid = function(o) {
    return je(o, s(Jt)), Jt.result();
  }, r.projection = function(o) {
    return arguments.length ? (s = o == null ? (i = null, Mi) : (i = o).stream, r) : i;
  }, r.context = function(o) {
    return arguments.length ? (a = o == null ? (t = null, new sr(e)) : new wo(t = o), typeof n != "function" && a.pointRadius(n), r) : t;
  }, r.pointRadius = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : (a.pointRadius(+o), +o), r) : n;
  }, r.digits = function(o) {
    if (!arguments.length) return e;
    if (o == null) e = null;
    else {
      const c = Math.floor(o);
      if (!(c >= 0)) throw new RangeError(`invalid digits: ${o}`);
      e = c;
    }
    return t === null && (a = new sr(e)), r;
  }, r.projection(i).digits(e).context(t);
}
function Xi(i) {
  return function(t) {
    var e = new Pi();
    for (var n in i) e[n] = i[n];
    return e.stream = t, e;
  };
}
function Pi() {
}
Pi.prototype = {
  constructor: Pi,
  point: function(i, t) {
    this.stream.point(i, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function Yi(i, t, e) {
  var n = i.clipExtent && i.clipExtent();
  return i.scale(150).translate([0, 0]), n != null && i.clipExtent(null), je(e, i.stream(ms)), t(ms.result()), n != null && i.clipExtent(n), i;
}
function Ro(i, t, e) {
  return Yi(i, function(n) {
    var s = t[1][0] - t[0][0], a = t[1][1] - t[0][1], r = Math.min(s / (n[1][0] - n[0][0]), a / (n[1][1] - n[0][1])), o = +t[0][0] + (s - r * (n[1][0] + n[0][0])) / 2, c = +t[0][1] + (a - r * (n[1][1] + n[0][1])) / 2;
    i.scale(150 * r).translate([o, c]);
  }, e);
}
function wu(i, t, e) {
  return Ro(i, [[0, 0], t], e);
}
function Cu(i, t, e) {
  return Yi(i, function(n) {
    var s = +t, a = s / (n[1][0] - n[0][0]), r = (s - a * (n[1][0] + n[0][0])) / 2, o = -a * n[0][1];
    i.scale(150 * a).translate([r, o]);
  }, e);
}
function ku(i, t, e) {
  return Yi(i, function(n) {
    var s = +t, a = s / (n[1][1] - n[0][1]), r = -a * n[0][0], o = (s - a * (n[1][1] + n[0][1])) / 2;
    i.scale(150 * a).translate([r, o]);
  }, e);
}
var ir = 16, _u = vt(30 * Ot);
function ar(i, t) {
  return +t ? Ru(i, t) : Iu(i);
}
function Iu(i) {
  return Xi({
    point: function(t, e) {
      t = i(t, e), this.stream.point(t[0], t[1]);
    }
  });
}
function Ru(i, t) {
  function e(n, s, a, r, o, c, l, h, d, u, p, f, m, g) {
    var v = l - n, S = h - s, y = v * v + S * S;
    if (y > 4 * t && m--) {
      var E = r + u, x = o + p, T = c + f, C = ae(E * E + x * x + T * T), _ = Se(T /= C), V = mt(mt(T) - 1) < gt || mt(a - d) < gt ? (a + d) / 2 : Ne(x, E), R = i(V, _), A = R[0], H = R[1], N = A - n, M = H - s, L = S * N - v * M;
      (L * L / y > t || mt((v * N + S * M) / y - 0.5) > 0.3 || r * u + o * p + c * f < _u) && (e(n, s, a, r, o, c, A, H, V, E /= C, x /= C, T, m, g), g.point(A, H), e(A, H, V, E, x, T, l, h, d, u, p, f, m, g));
    }
  }
  return function(n) {
    var s, a, r, o, c, l, h, d, u, p, f, m, g = {
      point: v,
      lineStart: S,
      lineEnd: E,
      polygonStart: function() {
        n.polygonStart(), g.lineStart = x;
      },
      polygonEnd: function() {
        n.polygonEnd(), g.lineStart = S;
      }
    };
    function v(_, V) {
      _ = i(_, V), n.point(_[0], _[1]);
    }
    function S() {
      d = NaN, g.point = y, n.lineStart();
    }
    function y(_, V) {
      var R = rn([_, V]), A = i(_, V);
      e(d, u, h, p, f, m, d = A[0], u = A[1], h = _, p = R[0], f = R[1], m = R[2], ir, n), n.point(d, u);
    }
    function E() {
      g.point = v, n.lineEnd();
    }
    function x() {
      S(), g.point = T, g.lineEnd = C;
    }
    function T(_, V) {
      y(s = _, V), a = d, r = u, o = p, c = f, l = m, g.point = y;
    }
    function C() {
      e(d, u, h, p, f, m, a, r, s, o, c, l, ir, n), g.lineEnd = E, E();
    }
    return g;
  };
}
var Du = Xi({
  point: function(i, t) {
    this.stream.point(i * Ot, t * Ot);
  }
});
function Nu(i) {
  return Xi({
    point: function(t, e) {
      var n = i(t, e);
      return this.stream.point(n[0], n[1]);
    }
  });
}
function Pu(i, t, e, n, s) {
  function a(r, o) {
    return r *= n, o *= s, [t + i * r, e - i * o];
  }
  return a.invert = function(r, o) {
    return [(r - t) / i * n, (e - o) / i * s];
  }, a;
}
function rr(i, t, e, n, s, a) {
  if (!a) return Pu(i, t, e, n, s);
  var r = vt(a), o = ft(a), c = r * i, l = o * i, h = r / i, d = o / i, u = (o * e - r * t) / i, p = (o * t + r * e) / i;
  function f(m, g) {
    return m *= n, g *= s, [c * m - l * g + t, e - l * m - c * g];
  }
  return f.invert = function(m, g) {
    return [n * (h * m - d * g + u), s * (p - d * m - h * g)];
  }, f;
}
function ws(i) {
  return Do(function() {
    return i;
  })();
}
function Do(i) {
  var t, e = 150, n = 480, s = 250, a = 0, r = 0, o = 0, c = 0, l = 0, h, d = 0, u = 1, p = 1, f = null, m = Ka, g = null, v, S, y, E = Mi, x = 0.5, T, C, _, V, R;
  function A(L) {
    return _(L[0] * Ot, L[1] * Ot);
  }
  function H(L) {
    return L = _.invert(L[0], L[1]), L && [L[0] * Vt, L[1] * Vt];
  }
  A.stream = function(L) {
    return V && R === L ? V : V = Du(Nu(h)(m(T(E(R = L)))));
  }, A.preclip = function(L) {
    return arguments.length ? (m = L, f = void 0, M()) : m;
  }, A.postclip = function(L) {
    return arguments.length ? (E = L, g = v = S = y = null, M()) : E;
  }, A.clipAngle = function(L) {
    return arguments.length ? (m = +L ? pu(f = L * Ot) : (f = null, Ka), M()) : f * Vt;
  }, A.clipExtent = function(L) {
    return arguments.length ? (E = L == null ? (g = v = S = y = null, Mi) : gu(g = +L[0][0], v = +L[0][1], S = +L[1][0], y = +L[1][1]), M()) : g == null ? null : [[g, v], [S, y]];
  }, A.scale = function(L) {
    return arguments.length ? (e = +L, N()) : e;
  }, A.translate = function(L) {
    return arguments.length ? (n = +L[0], s = +L[1], N()) : [n, s];
  }, A.center = function(L) {
    return arguments.length ? (a = L[0] % 360 * Ot, r = L[1] % 360 * Ot, N()) : [a * Vt, r * Vt];
  }, A.rotate = function(L) {
    return arguments.length ? (o = L[0] % 360 * Ot, c = L[1] % 360 * Ot, l = L.length > 2 ? L[2] % 360 * Ot : 0, N()) : [o * Vt, c * Vt, l * Vt];
  }, A.angle = function(L) {
    return arguments.length ? (d = L % 360 * Ot, N()) : d * Vt;
  }, A.reflectX = function(L) {
    return arguments.length ? (u = L ? -1 : 1, N()) : u < 0;
  }, A.reflectY = function(L) {
    return arguments.length ? (p = L ? -1 : 1, N()) : p < 0;
  }, A.precision = function(L) {
    return arguments.length ? (T = ar(C, x = L * L), M()) : ae(x);
  }, A.fitExtent = function(L, P) {
    return Ro(A, L, P);
  }, A.fitSize = function(L, P) {
    return wu(A, L, P);
  }, A.fitWidth = function(L, P) {
    return Cu(A, L, P);
  }, A.fitHeight = function(L, P) {
    return ku(A, L, P);
  };
  function N() {
    var L = rr(e, 0, 0, u, p, d).apply(null, t(a, r)), P = rr(e, n - L[0], s - L[1], u, p, d);
    return h = yo(o, c, l), C = Li(t, P), _ = Li(h, C), T = ar(C, x), M();
  }
  function M() {
    return V = R = null, A;
  }
  return function() {
    return t = i.apply(this, arguments), A.invert = t.invert && H, N();
  };
}
function No(i) {
  var t = 0, e = ht / 3, n = Do(i), s = n(t, e);
  return s.parallels = function(a) {
    return arguments.length ? n(t = a[0] * Ot, e = a[1] * Ot) : [t * Vt, e * Vt];
  }, s;
}
function $u(i) {
  var t = vt(i);
  function e(n, s) {
    return [n * t, ft(s) / t];
  }
  return e.invert = function(n, s) {
    return [n / t, Se(s * t)];
  }, e;
}
function Vu(i, t) {
  var e = ft(i), n = (e + ft(t)) / 2;
  if (mt(n) < gt) return $u(i);
  var s = 1 + e * (2 * n - e), a = ae(s) / n;
  function r(o, c) {
    var l = ae(s - 2 * n * ft(c)) / n;
    return [l * ft(o *= n), a - l * vt(o)];
  }
  return r.invert = function(o, c) {
    var l = a - c, h = Ne(o, mt(l)) * Oe(l);
    return l * n < 0 && (h -= ht * Oe(o) * Oe(l)), [h / n, Se((s - (o * o + l * l) * n * n) / (2 * n))];
  }, r;
}
function Po() {
  return No(Vu).scale(155.424).center([0, 33.6442]);
}
function Gu() {
  return Po().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function Zi(i, t) {
  return [i, nu(su((Ft + t) / 2))];
}
Zi.invert = function(i, t) {
  return [i, 2 * vo(eu(t)) - Ft];
};
function Hu() {
  return Bu(Zi).scale(961 / Yt);
}
function Bu(i) {
  var t = ws(i), e = t.center, n = t.scale, s = t.translate, a = t.clipExtent, r = null, o, c, l;
  t.scale = function(d) {
    return arguments.length ? (n(d), h()) : n();
  }, t.translate = function(d) {
    return arguments.length ? (s(d), h()) : s();
  }, t.center = function(d) {
    return arguments.length ? (e(d), h()) : e();
  }, t.clipExtent = function(d) {
    return arguments.length ? (d == null ? r = o = c = l = null : (r = +d[0][0], o = +d[0][1], c = +d[1][0], l = +d[1][1]), h()) : r == null ? null : [[r, o], [c, l]];
  };
  function h() {
    var d = ht * n(), u = t(au(t.rotate()).invert([0, 0]));
    return a(r == null ? [[u[0] - d, u[1] - d], [u[0] + d, u[1] + d]] : i === Zi ? [[Math.max(u[0] - d, r), o], [Math.min(u[0] + d, c), l]] : [[r, Math.max(u[1] - d, o)], [c, Math.min(u[1] + d, l)]]);
  }
  return h();
}
function xs(i, t) {
  return [i, t];
}
xs.invert = xs;
function zu() {
  return ws(xs).scale(152.63);
}
function Uu(i, t) {
  var e = vt(i), n = i === t ? ft(i) : (e - vt(t)) / (t - i), s = e / n + i;
  if (mt(n) < gt) return xs;
  function a(r, o) {
    var c = s - o, l = n * r;
    return [c * ft(l), s - c * vt(l)];
  }
  return a.invert = function(r, o) {
    var c = s - o, l = Ne(r, mt(c)) * Oe(c);
    return c * n < 0 && (l -= ht * Oe(r) * Oe(c)), [l / n, s - Oe(n) * ae(r * r + c * c)];
  }, a;
}
function Fu() {
  return No(Uu).scale(131.154).center([0, 13.9389]);
}
var An = 1.340264, Mn = -0.081106, wn = 893e-6, Cn = 3796e-6, Ss = ae(3) / 2, Wu = 12;
function $o(i, t) {
  var e = Se(Ss * ft(t)), n = e * e, s = n * n * n;
  return [
    i * vt(e) / (Ss * (An + 3 * Mn * n + s * (7 * wn + 9 * Cn * n))),
    e * (An + Mn * n + s * (wn + Cn * n))
  ];
}
$o.invert = function(i, t) {
  for (var e = t, n = e * e, s = n * n * n, a = 0, r, o, c; a < Wu && (o = e * (An + Mn * n + s * (wn + Cn * n)) - t, c = An + 3 * Mn * n + s * (7 * wn + 9 * Cn * n), e -= r = o / c, n = e * e, s = n * n * n, !(mt(r) < mo)); ++a)
    ;
  return [
    Ss * i * (An + 3 * Mn * n + s * (7 * wn + 9 * Cn * n)) / vt(e),
    Se(ft(e) / Ss)
  ];
};
function Xu() {
  return ws($o).scale(177.158);
}
function Vo(i, t) {
  var e = t * t, n = e * e;
  return [
    i * (0.8707 - 0.131979 * e + n * (-0.013791 + n * (3971e-6 * e - 1529e-6 * n))),
    t * (1.007226 + e * (0.015085 + n * (-0.044475 + 0.028874 * e - 5916e-6 * n)))
  ];
}
Vo.invert = function(i, t) {
  var e = t, n = 25, s;
  do {
    var a = e * e, r = a * a;
    e -= s = (e * (1.007226 + a * (0.015085 + r * (-0.044475 + 0.028874 * a - 5916e-6 * r))) - t) / (1.007226 + a * (0.015085 * 3 + r * (-0.044475 * 7 + 0.028874 * 9 * a - 5916e-6 * 11 * r)));
  } while (mt(s) > gt && --n > 0);
  return [
    i / (0.8707 + (a = e * e) * (-0.131979 + a * (-0.013791 + a * a * a * (3971e-6 - 1529e-6 * a)))),
    e
  ];
};
function Yu() {
  return ws(Vo).scale(175.295);
}
function Zu(i, t) {
  return i.parent === t.parent ? 1 : 2;
}
function qu(i) {
  return i.reduce(ju, 0) / i.length;
}
function ju(i, t) {
  return i + t.x;
}
function Ku(i) {
  return 1 + i.reduce(Ju, 0);
}
function Ju(i, t) {
  return Math.max(i, t.y);
}
function Qu(i) {
  for (var t; t = i.children; ) i = t[0];
  return i;
}
function th(i) {
  for (var t; t = i.children; ) i = t[t.length - 1];
  return i;
}
function eh() {
  var i = Zu, t = 1, e = 1, n = !1;
  function s(a) {
    var r, o = 0;
    a.eachAfter(function(u) {
      var p = u.children;
      p ? (u.x = qu(p), u.y = Ku(p)) : (u.x = r ? o += i(u, r) : 0, u.y = 0, r = u);
    });
    var c = Qu(a), l = th(a), h = c.x - i(c, l) / 2, d = l.x + i(l, c) / 2;
    return a.eachAfter(n ? function(u) {
      u.x = (u.x - a.x) * t, u.y = (a.y - u.y) * e;
    } : function(u) {
      u.x = (u.x - h) / (d - h) * t, u.y = (1 - (a.y ? u.y / a.y : 1)) * e;
    });
  }
  return s.separation = function(a) {
    return arguments.length ? (i = a, s) : i;
  }, s.size = function(a) {
    return arguments.length ? (n = !1, t = +a[0], e = +a[1], s) : n ? null : [t, e];
  }, s.nodeSize = function(a) {
    return arguments.length ? (n = !0, t = +a[0], e = +a[1], s) : n ? [t, e] : null;
  }, s;
}
function nh(i) {
  var t = 0, e = i.children, n = e && e.length;
  if (!n) t = 1;
  else for (; --n >= 0; ) t += e[n].value;
  i.value = t;
}
function sh() {
  return this.eachAfter(nh);
}
function ih(i, t) {
  let e = -1;
  for (const n of this)
    i.call(t, n, ++e, this);
  return this;
}
function ah(i, t) {
  for (var e = this, n = [e], s, a, r = -1; e = n.pop(); )
    if (i.call(t, e, ++r, this), s = e.children)
      for (a = s.length - 1; a >= 0; --a)
        n.push(s[a]);
  return this;
}
function rh(i, t) {
  for (var e = this, n = [e], s = [], a, r, o, c = -1; e = n.pop(); )
    if (s.push(e), a = e.children)
      for (r = 0, o = a.length; r < o; ++r)
        n.push(a[r]);
  for (; e = s.pop(); )
    i.call(t, e, ++c, this);
  return this;
}
function oh(i, t) {
  let e = -1;
  for (const n of this)
    if (i.call(t, n, ++e, this))
      return n;
}
function lh(i) {
  return this.eachAfter(function(t) {
    for (var e = +i(t.data) || 0, n = t.children, s = n && n.length; --s >= 0; ) e += n[s].value;
    t.value = e;
  });
}
function ch(i) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(i);
  });
}
function uh(i) {
  for (var t = this, e = hh(t, i), n = [t]; t !== e; )
    t = t.parent, n.push(t);
  for (var s = n.length; i !== e; )
    n.splice(s, 0, i), i = i.parent;
  return n;
}
function hh(i, t) {
  if (i === t) return i;
  var e = i.ancestors(), n = t.ancestors(), s = null;
  for (i = e.pop(), t = n.pop(); i === t; )
    s = i, i = e.pop(), t = n.pop();
  return s;
}
function dh() {
  for (var i = this, t = [i]; i = i.parent; )
    t.push(i);
  return t;
}
function ph() {
  return Array.from(this);
}
function fh() {
  var i = [];
  return this.eachBefore(function(t) {
    t.children || i.push(t);
  }), i;
}
function gh() {
  var i = this, t = [];
  return i.each(function(e) {
    e !== i && t.push({ source: e.parent, target: e });
  }), t;
}
function* mh() {
  var i = this, t, e = [i], n, s, a;
  do
    for (t = e.reverse(), e = []; i = t.pop(); )
      if (yield i, n = i.children)
        for (s = 0, a = n.length; s < a; ++s)
          e.push(n[s]);
  while (e.length);
}
function Nn(i, t) {
  i instanceof Map ? (i = [void 0, i], t === void 0 && (t = Eh)) : t === void 0 && (t = yh);
  for (var e = new Rn(i), n, s = [e], a, r, o, c; n = s.pop(); )
    if ((r = t(n.data)) && (c = (r = Array.from(r)).length))
      for (n.children = r, o = c - 1; o >= 0; --o)
        s.push(a = r[o] = new Rn(r[o])), a.parent = n, a.depth = n.depth + 1;
  return e.eachBefore(Sh);
}
function vh() {
  return Nn(this).eachBefore(xh);
}
function yh(i) {
  return i.children;
}
function Eh(i) {
  return Array.isArray(i) ? i[1] : null;
}
function xh(i) {
  i.data.value !== void 0 && (i.value = i.data.value), i.data = i.data.data;
}
function Sh(i) {
  var t = 0;
  do
    i.height = t;
  while ((i = i.parent) && i.height < ++t);
}
function Rn(i) {
  this.data = i, this.depth = this.height = 0, this.parent = null;
}
Rn.prototype = Nn.prototype = {
  constructor: Rn,
  count: sh,
  each: ih,
  eachAfter: rh,
  eachBefore: ah,
  find: oh,
  sum: lh,
  sort: ch,
  path: uh,
  ancestors: dh,
  descendants: ph,
  leaves: fh,
  links: gh,
  copy: vh,
  [Symbol.iterator]: mh
};
function Th(i) {
  return i == null ? null : Go(i);
}
function Go(i) {
  if (typeof i != "function") throw new Error();
  return i;
}
function Ie() {
  return 0;
}
function Ke(i) {
  return function() {
    return i;
  };
}
const bh = 1664525, Oh = 1013904223, or = 4294967296;
function Lh() {
  let i = 1;
  return () => (i = (bh * i + Oh) % or) / or;
}
function Ah(i) {
  return typeof i == "object" && "length" in i ? i : Array.from(i);
}
function Mh(i, t) {
  let e = i.length, n, s;
  for (; e; )
    s = t() * e-- | 0, n = i[e], i[e] = i[s], i[s] = n;
  return i;
}
function wh(i, t) {
  for (var e = 0, n = (i = Mh(Array.from(i), t)).length, s = [], a, r; e < n; )
    a = i[e], r && Ho(r, a) ? ++e : (r = kh(s = Ch(s, a)), e = 0);
  return r;
}
function Ch(i, t) {
  var e, n;
  if (ti(t, i)) return [t];
  for (e = 0; e < i.length; ++e)
    if (qn(t, i[e]) && ti(Ln(i[e], t), i))
      return [i[e], t];
  for (e = 0; e < i.length - 1; ++e)
    for (n = e + 1; n < i.length; ++n)
      if (qn(Ln(i[e], i[n]), t) && qn(Ln(i[e], t), i[n]) && qn(Ln(i[n], t), i[e]) && ti(Bo(i[e], i[n], t), i))
        return [i[e], i[n], t];
  throw new Error();
}
function qn(i, t) {
  var e = i.r - t.r, n = t.x - i.x, s = t.y - i.y;
  return e < 0 || e * e < n * n + s * s;
}
function Ho(i, t) {
  var e = i.r - t.r + Math.max(i.r, t.r, 1) * 1e-9, n = t.x - i.x, s = t.y - i.y;
  return e > 0 && e * e > n * n + s * s;
}
function ti(i, t) {
  for (var e = 0; e < t.length; ++e)
    if (!Ho(i, t[e]))
      return !1;
  return !0;
}
function kh(i) {
  switch (i.length) {
    case 1:
      return _h(i[0]);
    case 2:
      return Ln(i[0], i[1]);
    case 3:
      return Bo(i[0], i[1], i[2]);
  }
}
function _h(i) {
  return {
    x: i.x,
    y: i.y,
    r: i.r
  };
}
function Ln(i, t) {
  var e = i.x, n = i.y, s = i.r, a = t.x, r = t.y, o = t.r, c = a - e, l = r - n, h = o - s, d = Math.sqrt(c * c + l * l);
  return {
    x: (e + a + c / d * h) / 2,
    y: (n + r + l / d * h) / 2,
    r: (d + s + o) / 2
  };
}
function Bo(i, t, e) {
  var n = i.x, s = i.y, a = i.r, r = t.x, o = t.y, c = t.r, l = e.x, h = e.y, d = e.r, u = n - r, p = n - l, f = s - o, m = s - h, g = c - a, v = d - a, S = n * n + s * s - a * a, y = S - r * r - o * o + c * c, E = S - l * l - h * h + d * d, x = p * f - u * m, T = (f * E - m * y) / (x * 2) - n, C = (m * g - f * v) / x, _ = (p * y - u * E) / (x * 2) - s, V = (u * v - p * g) / x, R = C * C + V * V - 1, A = 2 * (a + T * C + _ * V), H = T * T + _ * _ - a * a, N = -(Math.abs(R) > 1e-6 ? (A + Math.sqrt(A * A - 4 * R * H)) / (2 * R) : H / A);
  return {
    x: n + T + C * N,
    y: s + _ + V * N,
    r: N
  };
}
function lr(i, t, e) {
  var n = i.x - t.x, s, a, r = i.y - t.y, o, c, l = n * n + r * r;
  l ? (a = t.r + e.r, a *= a, c = i.r + e.r, c *= c, a > c ? (s = (l + c - a) / (2 * l), o = Math.sqrt(Math.max(0, c / l - s * s)), e.x = i.x - s * n - o * r, e.y = i.y - s * r + o * n) : (s = (l + a - c) / (2 * l), o = Math.sqrt(Math.max(0, a / l - s * s)), e.x = t.x + s * n - o * r, e.y = t.y + s * r + o * n)) : (e.x = t.x + e.r, e.y = t.y);
}
function cr(i, t) {
  var e = i.r + t.r - 1e-6, n = t.x - i.x, s = t.y - i.y;
  return e > 0 && e * e > n * n + s * s;
}
function ur(i) {
  var t = i._, e = i.next._, n = t.r + e.r, s = (t.x * e.r + e.x * t.r) / n, a = (t.y * e.r + e.y * t.r) / n;
  return s * s + a * a;
}
function jn(i) {
  this._ = i, this.next = null, this.previous = null;
}
function Ih(i, t) {
  if (!(a = (i = Ah(i)).length)) return 0;
  var e, n, s, a, r, o, c, l, h, d, u;
  if (e = i[0], e.x = 0, e.y = 0, !(a > 1)) return e.r;
  if (n = i[1], e.x = -n.r, n.x = e.r, n.y = 0, !(a > 2)) return e.r + n.r;
  lr(n, e, s = i[2]), e = new jn(e), n = new jn(n), s = new jn(s), e.next = s.previous = n, n.next = e.previous = s, s.next = n.previous = e;
  t: for (c = 3; c < a; ++c) {
    lr(e._, n._, s = i[c]), s = new jn(s), l = n.next, h = e.previous, d = n._.r, u = e._.r;
    do
      if (d <= u) {
        if (cr(l._, s._)) {
          n = l, e.next = n, n.previous = e, --c;
          continue t;
        }
        d += l._.r, l = l.next;
      } else {
        if (cr(h._, s._)) {
          e = h, e.next = n, n.previous = e, --c;
          continue t;
        }
        u += h._.r, h = h.previous;
      }
    while (l !== h.next);
    for (s.previous = e, s.next = n, e.next = n.previous = n = s, r = ur(e); (s = s.next) !== n; )
      (o = ur(s)) < r && (e = s, r = o);
    n = e.next;
  }
  for (e = [n._], s = n; (s = s.next) !== n; ) e.push(s._);
  for (s = wh(e, t), c = 0; c < a; ++c) e = i[c], e.x -= s.x, e.y -= s.y;
  return s.r;
}
function Rh(i) {
  return Math.sqrt(i.value);
}
function Dh() {
  var i = null, t = 1, e = 1, n = Ie;
  function s(a) {
    const r = Lh();
    return a.x = t / 2, a.y = e / 2, i ? a.eachBefore(hr(i)).eachAfter(ei(n, 0.5, r)).eachBefore(dr(1)) : a.eachBefore(hr(Rh)).eachAfter(ei(Ie, 1, r)).eachAfter(ei(n, a.r / Math.min(t, e), r)).eachBefore(dr(Math.min(t, e) / (2 * a.r))), a;
  }
  return s.radius = function(a) {
    return arguments.length ? (i = Th(a), s) : i;
  }, s.size = function(a) {
    return arguments.length ? (t = +a[0], e = +a[1], s) : [t, e];
  }, s.padding = function(a) {
    return arguments.length ? (n = typeof a == "function" ? a : Ke(+a), s) : n;
  }, s;
}
function hr(i) {
  return function(t) {
    t.children || (t.r = Math.max(0, +i(t) || 0));
  };
}
function ei(i, t, e) {
  return function(n) {
    if (s = n.children) {
      var s, a, r = s.length, o = i(n) * t || 0, c;
      if (o) for (a = 0; a < r; ++a) s[a].r += o;
      if (c = Ih(s, e), o) for (a = 0; a < r; ++a) s[a].r -= o;
      n.r = c + o;
    }
  };
}
function dr(i) {
  return function(t) {
    var e = t.parent;
    t.r *= i, e && (t.x = e.x + i * t.x, t.y = e.y + i * t.y);
  };
}
function Nh(i) {
  i.x0 = Math.round(i.x0), i.y0 = Math.round(i.y0), i.x1 = Math.round(i.x1), i.y1 = Math.round(i.y1);
}
function Ph(i, t, e, n, s) {
  for (var a = i.children, r, o = -1, c = a.length, l = i.value && (n - t) / i.value; ++o < c; )
    r = a[o], r.y0 = e, r.y1 = s, r.x0 = t, r.x1 = t += r.value * l;
}
function $h(i, t) {
  return i.parent === t.parent ? 1 : 2;
}
function ni(i) {
  var t = i.children;
  return t ? t[0] : i.t;
}
function si(i) {
  var t = i.children;
  return t ? t[t.length - 1] : i.t;
}
function Vh(i, t, e) {
  var n = e / (t.i - i.i);
  t.c -= n, t.s += e, i.c += n, t.z += e, t.m += e;
}
function Gh(i) {
  for (var t = 0, e = 0, n = i.children, s = n.length, a; --s >= 0; )
    a = n[s], a.z += t, a.m += t, t += a.s + (e += a.c);
}
function Hh(i, t, e) {
  return i.a.parent === t.parent ? i.a : e;
}
function ls(i, t) {
  this._ = i, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
ls.prototype = Object.create(Rn.prototype);
function Bh(i) {
  for (var t = new ls(i, 0), e, n = [t], s, a, r, o; e = n.pop(); )
    if (a = e._.children)
      for (e.children = new Array(o = a.length), r = o - 1; r >= 0; --r)
        n.push(s = e.children[r] = new ls(a[r], r)), s.parent = e;
  return (t.parent = new ls(null, 0)).children = [t], t;
}
function zh() {
  var i = $h, t = 1, e = 1, n = null;
  function s(l) {
    var h = Bh(l);
    if (h.eachAfter(a), h.parent.m = -h.z, h.eachBefore(r), n) l.eachBefore(c);
    else {
      var d = l, u = l, p = l;
      l.eachBefore(function(S) {
        S.x < d.x && (d = S), S.x > u.x && (u = S), S.depth > p.depth && (p = S);
      });
      var f = d === u ? 1 : i(d, u) / 2, m = f - d.x, g = t / (u.x + f + m), v = e / (p.depth || 1);
      l.eachBefore(function(S) {
        S.x = (S.x + m) * g, S.y = S.depth * v;
      });
    }
    return l;
  }
  function a(l) {
    var h = l.children, d = l.parent.children, u = l.i ? d[l.i - 1] : null;
    if (h) {
      Gh(l);
      var p = (h[0].z + h[h.length - 1].z) / 2;
      u ? (l.z = u.z + i(l._, u._), l.m = l.z - p) : l.z = p;
    } else u && (l.z = u.z + i(l._, u._));
    l.parent.A = o(l, u, l.parent.A || d[0]);
  }
  function r(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function o(l, h, d) {
    if (h) {
      for (var u = l, p = l, f = h, m = u.parent.children[0], g = u.m, v = p.m, S = f.m, y = m.m, E; f = si(f), u = ni(u), f && u; )
        m = ni(m), p = si(p), p.a = l, E = f.z + S - u.z - g + i(f._, u._), E > 0 && (Vh(Hh(f, l, d), l, E), g += E, v += E), S += f.m, g += u.m, y += m.m, v += p.m;
      f && !si(p) && (p.t = f, p.m += S - v), u && !ni(m) && (m.t = u, m.m += g - y, d = l);
    }
    return d;
  }
  function c(l) {
    l.x *= t, l.y = l.depth * e;
  }
  return s.separation = function(l) {
    return arguments.length ? (i = l, s) : i;
  }, s.size = function(l) {
    return arguments.length ? (n = !1, t = +l[0], e = +l[1], s) : n ? null : [t, e];
  }, s.nodeSize = function(l) {
    return arguments.length ? (n = !0, t = +l[0], e = +l[1], s) : n ? [t, e] : null;
  }, s;
}
function Uh(i, t, e, n, s) {
  for (var a = i.children, r, o = -1, c = a.length, l = i.value && (s - e) / i.value; ++o < c; )
    r = a[o], r.x0 = t, r.x1 = n, r.y0 = e, r.y1 = e += r.value * l;
}
var Fh = (1 + Math.sqrt(5)) / 2;
function Wh(i, t, e, n, s, a) {
  for (var r = [], o = t.children, c, l, h = 0, d = 0, u = o.length, p, f, m = t.value, g, v, S, y, E, x, T; h < u; ) {
    p = s - e, f = a - n;
    do
      g = o[d++].value;
    while (!g && d < u);
    for (v = S = g, x = Math.max(f / p, p / f) / (m * i), T = g * g * x, E = Math.max(S / T, T / v); d < u; ++d) {
      if (g += l = o[d].value, l < v && (v = l), l > S && (S = l), T = g * g * x, y = Math.max(S / T, T / v), y > E) {
        g -= l;
        break;
      }
      E = y;
    }
    r.push(c = { value: g, dice: p < f, children: o.slice(h, d) }), c.dice ? Ph(c, e, n, s, m ? n += f * g / m : a) : Uh(c, e, n, m ? e += p * g / m : s, a), m -= g, h = d;
  }
  return r;
}
const Xh = function i(t) {
  function e(n, s, a, r, o) {
    Wh(t, n, s, a, r, o);
  }
  return e.ratio = function(n) {
    return i((n = +n) > 1 ? n : 1);
  }, e;
}(Fh);
function Yh() {
  var i = Xh, t = !1, e = 1, n = 1, s = [0], a = Ie, r = Ie, o = Ie, c = Ie, l = Ie;
  function h(u) {
    return u.x0 = u.y0 = 0, u.x1 = e, u.y1 = n, u.eachBefore(d), s = [0], t && u.eachBefore(Nh), u;
  }
  function d(u) {
    var p = s[u.depth], f = u.x0 + p, m = u.y0 + p, g = u.x1 - p, v = u.y1 - p;
    g < f && (f = g = (f + g) / 2), v < m && (m = v = (m + v) / 2), u.x0 = f, u.y0 = m, u.x1 = g, u.y1 = v, u.children && (p = s[u.depth + 1] = a(u) / 2, f += l(u) - p, m += r(u) - p, g -= o(u) - p, v -= c(u) - p, g < f && (f = g = (f + g) / 2), v < m && (m = v = (m + v) / 2), i(u, f, m, g, v));
  }
  return h.round = function(u) {
    return arguments.length ? (t = !!u, h) : t;
  }, h.size = function(u) {
    return arguments.length ? (e = +u[0], n = +u[1], h) : [e, n];
  }, h.tile = function(u) {
    return arguments.length ? (i = Go(u), h) : i;
  }, h.padding = function(u) {
    return arguments.length ? h.paddingInner(u).paddingOuter(u) : h.paddingInner();
  }, h.paddingInner = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : Ke(+u), h) : a;
  }, h.paddingOuter = function(u) {
    return arguments.length ? h.paddingTop(u).paddingRight(u).paddingBottom(u).paddingLeft(u) : h.paddingTop();
  }, h.paddingTop = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ke(+u), h) : r;
  }, h.paddingRight = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Ke(+u), h) : o;
  }, h.paddingBottom = function(u) {
    return arguments.length ? (c = typeof u == "function" ? u : Ke(+u), h) : c;
  }, h.paddingLeft = function(u) {
    return arguments.length ? (l = typeof u == "function" ? u : Ke(+u), h) : l;
  }, h;
}
function Cs(i) {
  let t = 3;
  return i.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const n = Math.floor(e);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = n;
    }
    return i;
  }, () => new Wi(t);
}
function Zh(i) {
  return i.innerRadius;
}
function qh(i) {
  return i.outerRadius;
}
function jh(i) {
  return i.startAngle;
}
function Kh(i) {
  return i.endAngle;
}
function Jh(i) {
  return i && i.padAngle;
}
function Qh(i, t, e, n, s, a, r, o) {
  var c = e - i, l = n - t, h = r - s, d = o - a, u = d * c - h * l;
  if (!(u * u < Ut))
    return u = (h * (t - a) - d * (i - s)) / u, [i + u * c, t + u * l];
}
function Kn(i, t, e, n, s, a, r) {
  var o = i - e, c = t - n, l = (r ? a : -a) / tn(o * o + c * c), h = l * c, d = -l * o, u = i + h, p = t + d, f = e + h, m = n + d, g = (u + f) / 2, v = (p + m) / 2, S = f - u, y = m - p, E = S * S + y * y, x = s - a, T = u * m - f * p, C = (y < 0 ? -1 : 1) * tn(Al(0, x * x * E - T * T)), _ = (T * y - S * C) / E, V = (-T * S - y * C) / E, R = (T * y + S * C) / E, A = (-T * S + y * C) / E, H = _ - g, N = V - v, M = R - g, L = A - v;
  return H * H + N * N > M * M + L * L && (_ = R, V = A), {
    cx: _,
    cy: V,
    x01: -h,
    y01: -d,
    x11: _ * (s / x - 1),
    y11: V * (s / x - 1)
  };
}
function Dn() {
  var i = Zh, t = qh, e = pt(0), n = null, s = jh, a = Kh, r = Jh, o = null, c = Cs(l);
  function l() {
    var h, d, u = +i.apply(this, arguments), p = +t.apply(this, arguments), f = s.apply(this, arguments) - La, m = a.apply(this, arguments) - La, g = Aa(m - f), v = m > f;
    if (o || (o = h = c()), p < u && (d = p, p = u, u = d), !(p > Ut)) o.moveTo(0, 0);
    else if (g > ss - Ut)
      o.moveTo(p * Ce(f), p * oe(f)), o.arc(0, 0, p, f, m, !v), u > Ut && (o.moveTo(u * Ce(m), u * oe(m)), o.arc(0, 0, u, m, f, v));
    else {
      var S = f, y = m, E = f, x = m, T = g, C = g, _ = r.apply(this, arguments) / 2, V = _ > Ut && (n ? +n.apply(this, arguments) : tn(u * u + p * p)), R = Fs(Aa(p - u) / 2, +e.apply(this, arguments)), A = R, H = R, N, M;
      if (V > Ut) {
        var L = wa(V / u * oe(_)), P = wa(V / p * oe(_));
        (T -= L * 2) > Ut ? (L *= v ? 1 : -1, E += L, x -= L) : (T = 0, E = x = (f + m) / 2), (C -= P * 2) > Ut ? (P *= v ? 1 : -1, S += P, y -= P) : (C = 0, S = y = (f + m) / 2);
      }
      var $ = p * Ce(S), k = p * oe(S), G = u * Ce(x), q = u * oe(x);
      if (R > Ut) {
        var X = p * Ce(y), F = p * oe(y), Z = u * Ce(E), rt = u * oe(E), j;
        if (g < Ma)
          if (j = Qh($, k, Z, rt, X, F, G, q)) {
            var Y = $ - j[0], K = k - j[1], ot = X - j[0], ct = F - j[1], st = 1 / oe(Ll((Y * ot + K * ct) / (tn(Y * Y + K * K) * tn(ot * ot + ct * ct))) / 2), it = tn(j[0] * j[0] + j[1] * j[1]);
            A = Fs(R, (u - it) / (st - 1)), H = Fs(R, (p - it) / (st + 1));
          } else
            A = H = 0;
      }
      C > Ut ? H > Ut ? (N = Kn(Z, rt, $, k, p, H, v), M = Kn(X, F, G, q, p, H, v), o.moveTo(N.cx + N.x01, N.cy + N.y01), H < R ? o.arc(N.cx, N.cy, H, Dt(N.y01, N.x01), Dt(M.y01, M.x01), !v) : (o.arc(N.cx, N.cy, H, Dt(N.y01, N.x01), Dt(N.y11, N.x11), !v), o.arc(0, 0, p, Dt(N.cy + N.y11, N.cx + N.x11), Dt(M.cy + M.y11, M.cx + M.x11), !v), o.arc(M.cx, M.cy, H, Dt(M.y11, M.x11), Dt(M.y01, M.x01), !v))) : (o.moveTo($, k), o.arc(0, 0, p, S, y, !v)) : o.moveTo($, k), !(u > Ut) || !(T > Ut) ? o.lineTo(G, q) : A > Ut ? (N = Kn(G, q, X, F, u, -A, v), M = Kn($, k, Z, rt, u, -A, v), o.lineTo(N.cx + N.x01, N.cy + N.y01), A < R ? o.arc(N.cx, N.cy, A, Dt(N.y01, N.x01), Dt(M.y01, M.x01), !v) : (o.arc(N.cx, N.cy, A, Dt(N.y01, N.x01), Dt(N.y11, N.x11), !v), o.arc(0, 0, u, Dt(N.cy + N.y11, N.cx + N.x11), Dt(M.cy + M.y11, M.cx + M.x11), v), o.arc(M.cx, M.cy, A, Dt(M.y11, M.x11), Dt(M.y01, M.x01), !v))) : o.arc(0, 0, u, x, E, v);
    }
    if (o.closePath(), h) return o = null, h + "" || null;
  }
  return l.centroid = function() {
    var h = (+i.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+s.apply(this, arguments) + +a.apply(this, arguments)) / 2 - Ma / 2;
    return [Ce(d) * h, oe(d) * h];
  }, l.innerRadius = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : pt(+h), l) : i;
  }, l.outerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : pt(+h), l) : t;
  }, l.cornerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : pt(+h), l) : e;
  }, l.padRadius = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : pt(+h), l) : n;
  }, l.startAngle = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : pt(+h), l) : s;
  }, l.endAngle = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : pt(+h), l) : a;
  }, l.padAngle = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : pt(+h), l) : r;
  }, l.context = function(h) {
    return arguments.length ? (o = h ?? null, l) : o;
  }, l;
}
function qi(i) {
  return i[0];
}
function ji(i) {
  return i[1];
}
function Pn(i, t) {
  var e = pt(!0), n = null, s = zi, a = null, r = Cs(o);
  i = typeof i == "function" ? i : i === void 0 ? qi : pt(i), t = typeof t == "function" ? t : t === void 0 ? ji : pt(t);
  function o(c) {
    var l, h = (c = Ui(c)).length, d, u = !1, p;
    for (n == null && (a = s(p = r())), l = 0; l <= h; ++l)
      !(l < h && e(d = c[l], l, c)) === u && ((u = !u) ? a.lineStart() : a.lineEnd()), u && a.point(+i(d, l, c), +t(d, l, c));
    if (p) return a = null, p + "" || null;
  }
  return o.x = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : pt(+c), o) : i;
  }, o.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : pt(+c), o) : t;
  }, o.defined = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : pt(!!c), o) : e;
  }, o.curve = function(c) {
    return arguments.length ? (s = c, n != null && (a = s(n)), o) : s;
  }, o.context = function(c) {
    return arguments.length ? (c == null ? n = a = null : a = s(n = c), o) : n;
  }, o;
}
function Ki(i, t, e) {
  var n = null, s = pt(!0), a = null, r = zi, o = null, c = Cs(l);
  i = typeof i == "function" ? i : i === void 0 ? qi : pt(+i), t = typeof t == "function" ? t : t === void 0 ? pt(0) : pt(+t), e = typeof e == "function" ? e : e === void 0 ? ji : pt(+e);
  function l(d) {
    var u, p, f, m = (d = Ui(d)).length, g, v = !1, S, y = new Array(m), E = new Array(m);
    for (a == null && (o = r(S = c())), u = 0; u <= m; ++u) {
      if (!(u < m && s(g = d[u], u, d)) === v)
        if (v = !v)
          p = u, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), f = u - 1; f >= p; --f)
            o.point(y[f], E[f]);
          o.lineEnd(), o.areaEnd();
        }
      v && (y[u] = +i(g, u, d), E[u] = +t(g, u, d), o.point(n ? +n(g, u, d) : y[u], e ? +e(g, u, d) : E[u]));
    }
    if (S) return o = null, S + "" || null;
  }
  function h() {
    return Pn().defined(s).curve(r).context(a);
  }
  return l.x = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : pt(+d), n = null, l) : i;
  }, l.x0 = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : pt(+d), l) : i;
  }, l.x1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : pt(+d), l) : n;
  }, l.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : pt(+d), e = null, l) : t;
  }, l.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : pt(+d), l) : t;
  }, l.y1 = function(d) {
    return arguments.length ? (e = d == null ? null : typeof d == "function" ? d : pt(+d), l) : e;
  }, l.lineX0 = l.lineY0 = function() {
    return h().x(i).y(t);
  }, l.lineY1 = function() {
    return h().x(i).y(e);
  }, l.lineX1 = function() {
    return h().x(n).y(t);
  }, l.defined = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : pt(!!d), l) : s;
  }, l.curve = function(d) {
    return arguments.length ? (r = d, a != null && (o = r(a)), l) : r;
  }, l.context = function(d) {
    return arguments.length ? (d == null ? a = o = null : o = r(a = d), l) : a;
  }, l;
}
function td(i, t) {
  return t < i ? -1 : t > i ? 1 : t >= i ? 0 : NaN;
}
function ed(i) {
  return i;
}
function nd() {
  var i = ed, t = td, e = null, n = pt(0), s = pt(ss), a = pt(0);
  function r(o) {
    var c, l = (o = Ui(o)).length, h, d, u = 0, p = new Array(l), f = new Array(l), m = +n.apply(this, arguments), g = Math.min(ss, Math.max(-ss, s.apply(this, arguments) - m)), v, S = Math.min(Math.abs(g) / l, a.apply(this, arguments)), y = S * (g < 0 ? -1 : 1), E;
    for (c = 0; c < l; ++c)
      (E = f[p[c] = c] = +i(o[c], c, o)) > 0 && (u += E);
    for (t != null ? p.sort(function(x, T) {
      return t(f[x], f[T]);
    }) : e != null && p.sort(function(x, T) {
      return e(o[x], o[T]);
    }), c = 0, d = u ? (g - l * y) / u : 0; c < l; ++c, m = v)
      h = p[c], E = f[h], v = m + (E > 0 ? E * d : 0) + y, f[h] = {
        data: o[h],
        index: c,
        value: E,
        startAngle: m,
        endAngle: v,
        padAngle: S
      };
    return f;
  }
  return r.value = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : pt(+o), r) : i;
  }, r.sortValues = function(o) {
    return arguments.length ? (t = o, e = null, r) : t;
  }, r.sort = function(o) {
    return arguments.length ? (e = o, t = null, r) : e;
  }, r.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : pt(+o), r) : n;
  }, r.endAngle = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : pt(+o), r) : s;
  }, r.padAngle = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : pt(+o), r) : a;
  }, r;
}
var sd = Uo(zi);
function zo(i) {
  this._curve = i;
}
zo.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(i, t) {
    this._curve.point(t * Math.sin(i), t * -Math.cos(i));
  }
};
function Uo(i) {
  function t(e) {
    return new zo(i(e));
  }
  return t._curve = i, t;
}
function id(i) {
  var t = i.curve;
  return i.angle = i.x, delete i.x, i.radius = i.y, delete i.y, i.curve = function(e) {
    return arguments.length ? t(Uo(e)) : t()._curve;
  }, i;
}
function ad() {
  return id(Pn().curve(sd));
}
class rd {
  constructor(t, e) {
    this._context = t, this._x = e;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, e, t, e) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + e) / 2, t, this._y0, t, e);
        break;
      }
    }
    this._x0 = t, this._y0 = e;
  }
}
function od(i) {
  return new rd(i, !0);
}
function ld(i) {
  return i.source;
}
function cd(i) {
  return i.target;
}
function ud(i) {
  let t = ld, e = cd, n = qi, s = ji, a = null, r = null, o = Cs(c);
  function c() {
    let l;
    const h = _l.call(arguments), d = t.apply(this, h), u = e.apply(this, h);
    if (a == null && (r = i(l = o())), r.lineStart(), h[0] = d, r.point(+n.apply(this, h), +s.apply(this, h)), h[0] = u, r.point(+n.apply(this, h), +s.apply(this, h)), r.lineEnd(), l) return r = null, l + "" || null;
  }
  return c.source = function(l) {
    return arguments.length ? (t = l, c) : t;
  }, c.target = function(l) {
    return arguments.length ? (e = l, c) : e;
  }, c.x = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : pt(+l), c) : n;
  }, c.y = function(l) {
    return arguments.length ? (s = typeof l == "function" ? l : pt(+l), c) : s;
  }, c.context = function(l) {
    return arguments.length ? (l == null ? a = r = null : r = i(a = l), c) : a;
  }, c;
}
function hd() {
  return ud(od);
}
class dt {
  constructor(t, e, n) {
    if (this.type = "", this.renderType = at.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = e, n && (this.configs = n, this.configs.id)) {
      const s = O(this.model.getOptions(), "style", "prefix");
      this.id = `${s}--${this.configs.id}`;
    }
    this.parent || this.setParent(
      D(
        this.services.domUtils.getMainContainer()
      )
    );
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down information to the components
  setServices(t) {
    this.services = t;
  }
  setParent(t) {
    const e = this.parent;
    if (this.parent = t, !(e && e.node() === t.node()) && this.type) {
      const n = O(this.model.getOptions(), "style", "prefix");
      this.parent?.classed(`${Kt}--${n}--${this.type}`, !0), e && e.classed(`${Kt}--${n}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(t = { ariaLabel: null, isPresentational: !1, withinChartClip: !1 }) {
    if (this.type) {
      const e = O(this.model.getOptions(), "style", "prefix"), n = this.id ? `#${this.id}` : "", s = I.appendOrSelect(
        this.parent,
        `${this.renderType === at.SVG ? "svg" : "div"}${n}.${Kt}--${e}--${this.type}`
      );
      if (t.ariaLabel && s.attr("aria-label", t.ariaLabel), t.isPresentational && s.attr("role", "presentation"), t.withinChartClip) {
        const a = this.model.get("chartClipId");
        if (a) {
          const o = D(`#${a}`).select("rect");
          if (o.size() !== 0) {
            const c = parseFloat(o.attr("height")), l = parseFloat(o.attr("width"));
            !isNaN(c) && !isNaN(l) && c > 0 && l > 0 && s.attr("clip-path", `url(#${a})`);
          }
        }
      }
      return s.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? sn({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: Fo,
  setPrototypeOf: pr,
  isFrozen: dd,
  getPrototypeOf: pd,
  getOwnPropertyDescriptor: fd
} = Object;
let {
  freeze: Ht,
  seal: ee,
  create: Wo
} = Object, {
  apply: $i,
  construct: Vi
} = typeof Reflect < "u" && Reflect;
Ht || (Ht = function(t) {
  return t;
});
ee || (ee = function(t) {
  return t;
});
$i || ($i = function(t, e, n) {
  return t.apply(e, n);
});
Vi || (Vi = function(t, e) {
  return new t(...e);
});
const Jn = Bt(Array.prototype.forEach), gd = Bt(Array.prototype.lastIndexOf), fr = Bt(Array.prototype.pop), pn = Bt(Array.prototype.push), md = Bt(Array.prototype.splice), cs = Bt(String.prototype.toLowerCase), ii = Bt(String.prototype.toString), gr = Bt(String.prototype.match), fn = Bt(String.prototype.replace), vd = Bt(String.prototype.indexOf), yd = Bt(String.prototype.trim), ie = Bt(Object.prototype.hasOwnProperty), $t = Bt(RegExp.prototype.test), gn = Ed(TypeError);
function Bt(i) {
  return function(t) {
    t instanceof RegExp && (t.lastIndex = 0);
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++)
      n[s - 1] = arguments[s];
    return $i(i, t, n);
  };
}
function Ed(i) {
  return function() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return Vi(i, e);
  };
}
function ut(i, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : cs;
  pr && pr(i, null);
  let n = t.length;
  for (; n--; ) {
    let s = t[n];
    if (typeof s == "string") {
      const a = e(s);
      a !== s && (dd(t) || (t[n] = a), s = a);
    }
    i[s] = !0;
  }
  return i;
}
function xd(i) {
  for (let t = 0; t < i.length; t++)
    ie(i, t) || (i[t] = null);
  return i;
}
function me(i) {
  const t = Wo(null);
  for (const [e, n] of Fo(i))
    ie(i, e) && (Array.isArray(n) ? t[e] = xd(n) : n && typeof n == "object" && n.constructor === Object ? t[e] = me(n) : t[e] = n);
  return t;
}
function mn(i, t) {
  for (; i !== null; ) {
    const n = fd(i, t);
    if (n) {
      if (n.get)
        return Bt(n.get);
      if (typeof n.value == "function")
        return Bt(n.value);
    }
    i = pd(i);
  }
  function e() {
    return null;
  }
  return e;
}
const mr = Ht(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ai = Ht(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ri = Ht(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Sd = Ht(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), oi = Ht(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Td = Ht(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), vr = Ht(["#text"]), yr = Ht(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), li = Ht(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Er = Ht(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Qn = Ht(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), bd = ee(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Od = ee(/<%[\w\W]*|[\w\W]*%>/gm), Ld = ee(/\$\{[\w\W]*/gm), Ad = ee(/^data-[\-\w.\u00B7-\uFFFF]+$/), Md = ee(/^aria-[\-\w]+$/), Xo = ee(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), wd = ee(/^(?:\w+script|data):/i), Cd = ee(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Yo = ee(/^html$/i), kd = ee(/^[a-z][.\w]*(-[.\w]+)+$/i);
var xr = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: Md,
  ATTR_WHITESPACE: Cd,
  CUSTOM_ELEMENT: kd,
  DATA_ATTR: Ad,
  DOCTYPE_NAME: Yo,
  ERB_EXPR: Od,
  IS_ALLOWED_URI: Xo,
  IS_SCRIPT_OR_DATA: wd,
  MUSTACHE_EXPR: bd,
  TMPLIT_EXPR: Ld
});
const vn = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, _d = function() {
  return typeof window > "u" ? null : window;
}, Id = function(t, e) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let n = null;
  const s = "data-tt-policy-suffix";
  e && e.hasAttribute(s) && (n = e.getAttribute(s));
  const a = "dompurify" + (n ? "#" + n : "");
  try {
    return t.createPolicy(a, {
      createHTML(r) {
        return r;
      },
      createScriptURL(r) {
        return r;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
}, Sr = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function Zo() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _d();
  const t = (tt) => Zo(tt);
  if (t.version = "3.2.6", t.removed = [], !i || !i.document || i.document.nodeType !== vn.document || !i.Element)
    return t.isSupported = !1, t;
  let {
    document: e
  } = i;
  const n = e, s = n.currentScript, {
    DocumentFragment: a,
    HTMLTemplateElement: r,
    Node: o,
    Element: c,
    NodeFilter: l,
    NamedNodeMap: h = i.NamedNodeMap || i.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: u,
    trustedTypes: p
  } = i, f = c.prototype, m = mn(f, "cloneNode"), g = mn(f, "remove"), v = mn(f, "nextSibling"), S = mn(f, "childNodes"), y = mn(f, "parentNode");
  if (typeof r == "function") {
    const tt = e.createElement("template");
    tt.content && tt.content.ownerDocument && (e = tt.content.ownerDocument);
  }
  let E, x = "";
  const {
    implementation: T,
    createNodeIterator: C,
    createDocumentFragment: _,
    getElementsByTagName: V
  } = e, {
    importNode: R
  } = n;
  let A = Sr();
  t.isSupported = typeof Fo == "function" && typeof y == "function" && T && T.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: H,
    ERB_EXPR: N,
    TMPLIT_EXPR: M,
    DATA_ATTR: L,
    ARIA_ATTR: P,
    IS_SCRIPT_OR_DATA: $,
    ATTR_WHITESPACE: k,
    CUSTOM_ELEMENT: G
  } = xr;
  let {
    IS_ALLOWED_URI: q
  } = xr, X = null;
  const F = ut({}, [...mr, ...ai, ...ri, ...oi, ...vr]);
  let Z = null;
  const rt = ut({}, [...yr, ...li, ...Er, ...Qn]);
  let j = Object.seal(Wo(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Y = null, K = null, ot = !0, ct = !0, st = !1, it = !0, z = !1, B = !0, U = !1, wt = !1, Te = !1, et = !1, yt = !1, Zt = !1, Wt = !0, ln = !1;
  const cn = "user-content-";
  let Le = !0, ne = !1, $e = {}, Ve = null;
  const na = ut({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let sa = null;
  const ia = ut({}, ["audio", "video", "img", "source", "image", "track"]);
  let _s = null;
  const aa = ut({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), $n = "http://www.w3.org/1998/Math/MathML", Vn = "http://www.w3.org/2000/svg", he = "http://www.w3.org/1999/xhtml";
  let Ge = he, Is = !1, Rs = null;
  const tl = ut({}, [$n, Vn, he], ii);
  let Gn = ut({}, ["mi", "mo", "mn", "ms", "mtext"]), Hn = ut({}, ["annotation-xml"]);
  const el = ut({}, ["title", "style", "font", "a", "script"]);
  let un = null;
  const nl = ["application/xhtml+xml", "text/html"], sl = "text/html";
  let Ct = null, He = null;
  const il = e.createElement("form"), ra = function(w) {
    return w instanceof RegExp || w instanceof Function;
  }, Ds = function() {
    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(He && He === w)) {
      if ((!w || typeof w != "object") && (w = {}), w = me(w), un = // eslint-disable-next-line unicorn/prefer-includes
      nl.indexOf(w.PARSER_MEDIA_TYPE) === -1 ? sl : w.PARSER_MEDIA_TYPE, Ct = un === "application/xhtml+xml" ? ii : cs, X = ie(w, "ALLOWED_TAGS") ? ut({}, w.ALLOWED_TAGS, Ct) : F, Z = ie(w, "ALLOWED_ATTR") ? ut({}, w.ALLOWED_ATTR, Ct) : rt, Rs = ie(w, "ALLOWED_NAMESPACES") ? ut({}, w.ALLOWED_NAMESPACES, ii) : tl, _s = ie(w, "ADD_URI_SAFE_ATTR") ? ut(me(aa), w.ADD_URI_SAFE_ATTR, Ct) : aa, sa = ie(w, "ADD_DATA_URI_TAGS") ? ut(me(ia), w.ADD_DATA_URI_TAGS, Ct) : ia, Ve = ie(w, "FORBID_CONTENTS") ? ut({}, w.FORBID_CONTENTS, Ct) : na, Y = ie(w, "FORBID_TAGS") ? ut({}, w.FORBID_TAGS, Ct) : me({}), K = ie(w, "FORBID_ATTR") ? ut({}, w.FORBID_ATTR, Ct) : me({}), $e = ie(w, "USE_PROFILES") ? w.USE_PROFILES : !1, ot = w.ALLOW_ARIA_ATTR !== !1, ct = w.ALLOW_DATA_ATTR !== !1, st = w.ALLOW_UNKNOWN_PROTOCOLS || !1, it = w.ALLOW_SELF_CLOSE_IN_ATTR !== !1, z = w.SAFE_FOR_TEMPLATES || !1, B = w.SAFE_FOR_XML !== !1, U = w.WHOLE_DOCUMENT || !1, et = w.RETURN_DOM || !1, yt = w.RETURN_DOM_FRAGMENT || !1, Zt = w.RETURN_TRUSTED_TYPE || !1, Te = w.FORCE_BODY || !1, Wt = w.SANITIZE_DOM !== !1, ln = w.SANITIZE_NAMED_PROPS || !1, Le = w.KEEP_CONTENT !== !1, ne = w.IN_PLACE || !1, q = w.ALLOWED_URI_REGEXP || Xo, Ge = w.NAMESPACE || he, Gn = w.MATHML_TEXT_INTEGRATION_POINTS || Gn, Hn = w.HTML_INTEGRATION_POINTS || Hn, j = w.CUSTOM_ELEMENT_HANDLING || {}, w.CUSTOM_ELEMENT_HANDLING && ra(w.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (j.tagNameCheck = w.CUSTOM_ELEMENT_HANDLING.tagNameCheck), w.CUSTOM_ELEMENT_HANDLING && ra(w.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (j.attributeNameCheck = w.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), w.CUSTOM_ELEMENT_HANDLING && typeof w.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (j.allowCustomizedBuiltInElements = w.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), z && (ct = !1), yt && (et = !0), $e && (X = ut({}, vr), Z = [], $e.html === !0 && (ut(X, mr), ut(Z, yr)), $e.svg === !0 && (ut(X, ai), ut(Z, li), ut(Z, Qn)), $e.svgFilters === !0 && (ut(X, ri), ut(Z, li), ut(Z, Qn)), $e.mathMl === !0 && (ut(X, oi), ut(Z, Er), ut(Z, Qn))), w.ADD_TAGS && (X === F && (X = me(X)), ut(X, w.ADD_TAGS, Ct)), w.ADD_ATTR && (Z === rt && (Z = me(Z)), ut(Z, w.ADD_ATTR, Ct)), w.ADD_URI_SAFE_ATTR && ut(_s, w.ADD_URI_SAFE_ATTR, Ct), w.FORBID_CONTENTS && (Ve === na && (Ve = me(Ve)), ut(Ve, w.FORBID_CONTENTS, Ct)), Le && (X["#text"] = !0), U && ut(X, ["html", "head", "body"]), X.table && (ut(X, ["tbody"]), delete Y.tbody), w.TRUSTED_TYPES_POLICY) {
        if (typeof w.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw gn('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof w.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw gn('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        E = w.TRUSTED_TYPES_POLICY, x = E.createHTML("");
      } else
        E === void 0 && (E = Id(p, s)), E !== null && typeof x == "string" && (x = E.createHTML(""));
      Ht && Ht(w), He = w;
    }
  }, oa = ut({}, [...ai, ...ri, ...Sd]), la = ut({}, [...oi, ...Td]), al = function(w) {
    let W = y(w);
    (!W || !W.tagName) && (W = {
      namespaceURI: Ge,
      tagName: "template"
    });
    const Q = cs(w.tagName), St = cs(W.tagName);
    return Rs[w.namespaceURI] ? w.namespaceURI === Vn ? W.namespaceURI === he ? Q === "svg" : W.namespaceURI === $n ? Q === "svg" && (St === "annotation-xml" || Gn[St]) : !!oa[Q] : w.namespaceURI === $n ? W.namespaceURI === he ? Q === "math" : W.namespaceURI === Vn ? Q === "math" && Hn[St] : !!la[Q] : w.namespaceURI === he ? W.namespaceURI === Vn && !Hn[St] || W.namespaceURI === $n && !Gn[St] ? !1 : !la[Q] && (el[Q] || !oa[Q]) : !!(un === "application/xhtml+xml" && Rs[w.namespaceURI]) : !1;
  }, re = function(w) {
    pn(t.removed, {
      element: w
    });
    try {
      y(w).removeChild(w);
    } catch {
      g(w);
    }
  }, Be = function(w, W) {
    try {
      pn(t.removed, {
        attribute: W.getAttributeNode(w),
        from: W
      });
    } catch {
      pn(t.removed, {
        attribute: null,
        from: W
      });
    }
    if (W.removeAttribute(w), w === "is")
      if (et || yt)
        try {
          re(W);
        } catch {
        }
      else
        try {
          W.setAttribute(w, "");
        } catch {
        }
  }, ca = function(w) {
    let W = null, Q = null;
    if (Te)
      w = "<remove></remove>" + w;
    else {
      const At = gr(w, /^[\r\n\t ]+/);
      Q = At && At[0];
    }
    un === "application/xhtml+xml" && Ge === he && (w = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + w + "</body></html>");
    const St = E ? E.createHTML(w) : w;
    if (Ge === he)
      try {
        W = new u().parseFromString(St, un);
      } catch {
      }
    if (!W || !W.documentElement) {
      W = T.createDocument(Ge, "template", null);
      try {
        W.documentElement.innerHTML = Is ? x : St;
      } catch {
      }
    }
    const It = W.body || W.documentElement;
    return w && Q && It.insertBefore(e.createTextNode(Q), It.childNodes[0] || null), Ge === he ? V.call(W, U ? "html" : "body")[0] : U ? W.documentElement : It;
  }, ua = function(w) {
    return C.call(
      w.ownerDocument || w,
      w,
      // eslint-disable-next-line no-bitwise
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT | l.SHOW_PROCESSING_INSTRUCTION | l.SHOW_CDATA_SECTION,
      null
    );
  }, Ns = function(w) {
    return w instanceof d && (typeof w.nodeName != "string" || typeof w.textContent != "string" || typeof w.removeChild != "function" || !(w.attributes instanceof h) || typeof w.removeAttribute != "function" || typeof w.setAttribute != "function" || typeof w.namespaceURI != "string" || typeof w.insertBefore != "function" || typeof w.hasChildNodes != "function");
  }, ha = function(w) {
    return typeof o == "function" && w instanceof o;
  };
  function de(tt, w, W) {
    Jn(tt, (Q) => {
      Q.call(t, w, W, He);
    });
  }
  const da = function(w) {
    let W = null;
    if (de(A.beforeSanitizeElements, w, null), Ns(w))
      return re(w), !0;
    const Q = Ct(w.nodeName);
    if (de(A.uponSanitizeElement, w, {
      tagName: Q,
      allowedTags: X
    }), B && w.hasChildNodes() && !ha(w.firstElementChild) && $t(/<[/\w!]/g, w.innerHTML) && $t(/<[/\w!]/g, w.textContent) || w.nodeType === vn.progressingInstruction || B && w.nodeType === vn.comment && $t(/<[/\w]/g, w.data))
      return re(w), !0;
    if (!X[Q] || Y[Q]) {
      if (!Y[Q] && fa(Q) && (j.tagNameCheck instanceof RegExp && $t(j.tagNameCheck, Q) || j.tagNameCheck instanceof Function && j.tagNameCheck(Q)))
        return !1;
      if (Le && !Ve[Q]) {
        const St = y(w) || w.parentNode, It = S(w) || w.childNodes;
        if (It && St) {
          const At = It.length;
          for (let zt = At - 1; zt >= 0; --zt) {
            const pe = m(It[zt], !0);
            pe.__removalCount = (w.__removalCount || 0) + 1, St.insertBefore(pe, v(w));
          }
        }
      }
      return re(w), !0;
    }
    return w instanceof c && !al(w) || (Q === "noscript" || Q === "noembed" || Q === "noframes") && $t(/<\/no(script|embed|frames)/i, w.innerHTML) ? (re(w), !0) : (z && w.nodeType === vn.text && (W = w.textContent, Jn([H, N, M], (St) => {
      W = fn(W, St, " ");
    }), w.textContent !== W && (pn(t.removed, {
      element: w.cloneNode()
    }), w.textContent = W)), de(A.afterSanitizeElements, w, null), !1);
  }, pa = function(w, W, Q) {
    if (Wt && (W === "id" || W === "name") && (Q in e || Q in il))
      return !1;
    if (!(ct && !K[W] && $t(L, W))) {
      if (!(ot && $t(P, W))) {
        if (!Z[W] || K[W]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(fa(w) && (j.tagNameCheck instanceof RegExp && $t(j.tagNameCheck, w) || j.tagNameCheck instanceof Function && j.tagNameCheck(w)) && (j.attributeNameCheck instanceof RegExp && $t(j.attributeNameCheck, W) || j.attributeNameCheck instanceof Function && j.attributeNameCheck(W)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            W === "is" && j.allowCustomizedBuiltInElements && (j.tagNameCheck instanceof RegExp && $t(j.tagNameCheck, Q) || j.tagNameCheck instanceof Function && j.tagNameCheck(Q)))
          ) return !1;
        } else if (!_s[W]) {
          if (!$t(q, fn(Q, k, ""))) {
            if (!((W === "src" || W === "xlink:href" || W === "href") && w !== "script" && vd(Q, "data:") === 0 && sa[w])) {
              if (!(st && !$t($, fn(Q, k, "")))) {
                if (Q)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, fa = function(w) {
    return w !== "annotation-xml" && gr(w, G);
  }, ga = function(w) {
    de(A.beforeSanitizeAttributes, w, null);
    const {
      attributes: W
    } = w;
    if (!W || Ns(w))
      return;
    const Q = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: Z,
      forceKeepAttr: void 0
    };
    let St = W.length;
    for (; St--; ) {
      const It = W[St], {
        name: At,
        namespaceURI: zt,
        value: pe
      } = It, hn = Ct(At), Ps = pe;
      let Rt = At === "value" ? Ps : yd(Ps);
      if (Q.attrName = hn, Q.attrValue = Rt, Q.keepAttr = !0, Q.forceKeepAttr = void 0, de(A.uponSanitizeAttribute, w, Q), Rt = Q.attrValue, ln && (hn === "id" || hn === "name") && (Be(At, w), Rt = cn + Rt), B && $t(/((--!?|])>)|<\/(style|title)/i, Rt)) {
        Be(At, w);
        continue;
      }
      if (Q.forceKeepAttr)
        continue;
      if (!Q.keepAttr) {
        Be(At, w);
        continue;
      }
      if (!it && $t(/\/>/i, Rt)) {
        Be(At, w);
        continue;
      }
      z && Jn([H, N, M], (va) => {
        Rt = fn(Rt, va, " ");
      });
      const ma = Ct(w.nodeName);
      if (!pa(ma, hn, Rt)) {
        Be(At, w);
        continue;
      }
      if (E && typeof p == "object" && typeof p.getAttributeType == "function" && !zt)
        switch (p.getAttributeType(ma, hn)) {
          case "TrustedHTML": {
            Rt = E.createHTML(Rt);
            break;
          }
          case "TrustedScriptURL": {
            Rt = E.createScriptURL(Rt);
            break;
          }
        }
      if (Rt !== Ps)
        try {
          zt ? w.setAttributeNS(zt, At, Rt) : w.setAttribute(At, Rt), Ns(w) ? re(w) : fr(t.removed);
        } catch {
          Be(At, w);
        }
    }
    de(A.afterSanitizeAttributes, w, null);
  }, rl = function tt(w) {
    let W = null;
    const Q = ua(w);
    for (de(A.beforeSanitizeShadowDOM, w, null); W = Q.nextNode(); )
      de(A.uponSanitizeShadowNode, W, null), da(W), ga(W), W.content instanceof a && tt(W.content);
    de(A.afterSanitizeShadowDOM, w, null);
  };
  return t.sanitize = function(tt) {
    let w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, W = null, Q = null, St = null, It = null;
    if (Is = !tt, Is && (tt = "<!-->"), typeof tt != "string" && !ha(tt))
      if (typeof tt.toString == "function") {
        if (tt = tt.toString(), typeof tt != "string")
          throw gn("dirty is not a string, aborting");
      } else
        throw gn("toString is not a function");
    if (!t.isSupported)
      return tt;
    if (wt || Ds(w), t.removed = [], typeof tt == "string" && (ne = !1), ne) {
      if (tt.nodeName) {
        const pe = Ct(tt.nodeName);
        if (!X[pe] || Y[pe])
          throw gn("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (tt instanceof o)
      W = ca("<!---->"), Q = W.ownerDocument.importNode(tt, !0), Q.nodeType === vn.element && Q.nodeName === "BODY" || Q.nodeName === "HTML" ? W = Q : W.appendChild(Q);
    else {
      if (!et && !z && !U && // eslint-disable-next-line unicorn/prefer-includes
      tt.indexOf("<") === -1)
        return E && Zt ? E.createHTML(tt) : tt;
      if (W = ca(tt), !W)
        return et ? null : Zt ? x : "";
    }
    W && Te && re(W.firstChild);
    const At = ua(ne ? tt : W);
    for (; St = At.nextNode(); )
      da(St), ga(St), St.content instanceof a && rl(St.content);
    if (ne)
      return tt;
    if (et) {
      if (yt)
        for (It = _.call(W.ownerDocument); W.firstChild; )
          It.appendChild(W.firstChild);
      else
        It = W;
      return (Z.shadowroot || Z.shadowrootmode) && (It = R.call(n, It, !0)), It;
    }
    let zt = U ? W.outerHTML : W.innerHTML;
    return U && X["!doctype"] && W.ownerDocument && W.ownerDocument.doctype && W.ownerDocument.doctype.name && $t(Yo, W.ownerDocument.doctype.name) && (zt = "<!DOCTYPE " + W.ownerDocument.doctype.name + `>
` + zt), z && Jn([H, N, M], (pe) => {
      zt = fn(zt, pe, " ");
    }), E && Zt ? E.createHTML(zt) : zt;
  }, t.setConfig = function() {
    let tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ds(tt), wt = !0;
  }, t.clearConfig = function() {
    He = null, wt = !1;
  }, t.isValidAttribute = function(tt, w, W) {
    He || Ds({});
    const Q = Ct(tt), St = Ct(w);
    return pa(Q, St, W);
  }, t.addHook = function(tt, w) {
    typeof w == "function" && pn(A[tt], w);
  }, t.removeHook = function(tt, w) {
    if (w !== void 0) {
      const W = gd(A[tt], w);
      return W === -1 ? void 0 : md(A[tt], W, 1)[0];
    }
    return fr(A[tt]);
  }, t.removeHooks = function(tt) {
    A[tt] = [];
  }, t.removeAllHooks = function() {
    A = Sr();
  }, t;
}
var Ji = Zo();
const ts = (i) => Ji.sanitize(i, {
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), Rd = (i) => Ji.sanitize(i, {
  NAMESPACE: "http://www.w3.org/2000/svg",
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), ue = (i) => Ji.sanitize(i, { ALLOWED_TAGS: [] }), bs = class bs extends dt {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = at.HTML;
  }
  init() {
    const t = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(b.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", t);
    }), this.services.events.addEventListener(b.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", t);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "toolbar"
    }).attr("role", "group");
    if (O(this.getOptions(), "data", "loading"))
      e.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = e.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: s, overflowMenuItemList: a } = this.getControlConfigs();
      a && s.push(this.getOverflowButtonConfig());
      const r = e.selectAll("div.toolbar-control").data(s, (l) => l.id);
      r.exit().remove();
      const o = r.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), c = this;
      o.merge(r).classed("disabled", (l) => l.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html((l) => `
			<button
	 			type="button"
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
        `control-${ue(l.id)}`
      )}" aria-label="${ue(l.title)}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${Rd(l.iconSVG.content)}
				</svg>
			</button>`).each(function(l, h) {
        D(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), D(this).select("button").on("mouseover focus", function(d) {
          const u = D(this);
          u.classed("hovered", !0), c.services.events.dispatchEvent(b.Toolbar.SHOW_TOOLTIP, {
            event: d,
            hoveredElement: u,
            content: l.title,
            noWrap: !0,
            placements: ["top", "bottom"]
          });
        }).on("mouseout blur", function() {
          c.services.events.dispatchEvent(b.Toolbar.HIDE_TOOLTIP);
        }).on("click", (d) => {
          l.shouldBeDisabled() || c.triggerFunctionAndEvent(l, d, this);
        }).on("keydown", (d) => {
          d.key && d.key === "Enter" || d.key === " " ? (d.preventDefault(), c.triggerFunctionAndEvent(l, d, this)) : d.key && d.key === "ArrowLeft" ? c.focusOnPreviousEnabledToolbarItem(h) : d.key && d.key === "ArrowRight" && c.focusOnNextEnabledToolbarItem(h);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: t } = this.getControlConfigs(), e = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (s) => O(s, "id"));
    e.exit().remove();
    const n = e.enter().append("li").attr("id", (s) => this.services.domUtils.generateElementIDString(`control-${s.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    n.append("button").attr("type", "button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), n.merge(e).classed("cds--overflow-menu-options__option--disabled", (s) => s.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (s) => s.shouldBeDisabled()).attr("aria-disabled", (s) => s.shouldBeDisabled()).selectAll("button").text((s) => s.title);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(t) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), D(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(b.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(b.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(t) {
    const e = this.getToolbarButtonItems();
    let n = e.length;
    for (let s = t - 1; s >= 0; s--)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n < e.length) {
      const s = D(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )}`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnNextEnabledToolbarItem(t) {
    const e = this.getToolbarButtonItems();
    let n = -1;
    for (let s = t + 1; s < e.length; s++)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n > -1) {
      const s = D(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )}`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(t) {
    const e = this.getOverflowMenuItems();
    let n = e.length;
    for (let s = t - 1; s >= 0; s--)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n < e.length) {
      const s = D(
        `#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )} button`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnNextEnabledMenuItem(t) {
    const e = this.getOverflowMenuItems();
    let n = -1;
    for (let s = t + 1; s < e.length; s++)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n > -1) {
      const s = D(
        `#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )} button`
      ).node();
      "focus" in s && s.focus();
    }
  }
  toggleOverflowMenu(t) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const e = this;
      this.getOverflowMenuItems().forEach((s, a) => {
        const r = D(
          `#${this.services.domUtils.generateElementIDString(`control-${s.id}`)}`
        );
        r !== null && (r.on("click", () => {
          e.triggerFunctionAndEvent(s, t, r.node()), e.updateOverflowMenu(!1);
        }), r.on("keydown", (o) => {
          o && o.key === "Enter" ? e.triggerFunctionAndEvent(s, t, r.node()) : o && o.key === "ArrowUp" ? e.focusOnPreviousEnabledMenuItem(a) : o && o.key === "ArrowDown" ? e.focusOnNextEnabledMenuItem(a) : o && o.key === "Escape" && e.updateOverflowMenu(!1), o.preventDefault();
        }));
      }), e.focusOnNextEnabledMenuItem(-1);
    }
    t && t.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(t, e, n) {
    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(e), this.services.events.dispatchEvent(b.Toolbar.BUTTON_CLICK, {
      control: t,
      event: e,
      element: n
    }));
  }
  getControlConfigs() {
    const t = O(this.getOptions(), "toolbar", "numberOfIcons") - 1, e = O(this.getOptions(), "toolbar", "controls"), n = [], s = [], a = [];
    return e.forEach((r) => {
      let o = null;
      if (r.type === Tt.CUSTOM)
        O(r, "id") === null && (r.id = `toolbar-button-${bs.buttonID++}`), O(r, "shouldBeDisabled") === null && (r.shouldBeDisabled = () => !1), o = r;
      else {
        const c = this.services.domUtils.isFullScreenMode();
        r.type === Tt.MAKE_FULLSCREEN && c ? r.type = Tt.EXIT_FULLSCREEN : r.type === Tt.EXIT_FULLSCREEN && !c && (r.type = Tt.MAKE_FULLSCREEN), o = this.getControlConfigByType(r.type);
      }
      o && (o.text = r.text ? r.text : r.type, o.id.indexOf("toolbar-export") !== -1 ? n.push(o) : s.length < t ? O(o, "iconSVG", "content") === null ? a.push(o) : s.push(o) : a.push(o));
    }), a.push(...n), a.length ? {
      buttonList: s,
      overflowMenuItemList: a
    } : {
      buttonList: s
    };
  }
  getToolbarButtonItems() {
    const { buttonList: t, overflowMenuItemList: e } = this.getControlConfigs();
    return e && t.push(this.getOverflowButtonConfig()), t || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: t } = this.getControlConfigs();
    return t || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    const { moreOptions: t } = O(
      this.model.getOptions(),
      "locale",
      "translations",
      "toolbar"
    );
    return {
      id: "toolbar-overflow-menu",
      title: t,
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (e) => this.toggleOverflowMenu(e)
    };
  }
  getControlConfigByType(t) {
    const e = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), n = this.model.getDisplayData(), s = this.model.getOptions(), {
      exportAsCSV: a,
      exportAsJPG: r,
      exportAsPNG: o,
      zoomIn: c,
      zoomOut: l,
      resetZoom: h,
      makeFullScreen: d,
      exitFullScreen: u,
      showAsTable: p
    } = O(s, "locale", "translations", "toolbar");
    let f;
    switch (t) {
      case Tt.ZOOM_IN:
        e && (f = {
          id: "toolbar-zoomIn",
          title: c,
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case Tt.ZOOM_OUT:
        e && (f = {
          id: "toolbar-zoomOut",
          title: l,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case Tt.RESET_ZOOM:
        e && (f = {
          id: "toolbar-resetZoom",
          title: h,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case Tt.MAKE_FULLSCREEN:
        f = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: d,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case Tt.EXIT_FULLSCREEN:
        f = {
          id: "toolbar-exitfullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: u,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case Tt.SHOW_AS_DATATABLE:
        f = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          title: p,
          shouldBeDisabled: () => n.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(b.Modal.SHOW)
        };
        break;
      case Tt.EXPORT_CSV:
        f = {
          id: "toolbar-export-CSV",
          title: a,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case Tt.EXPORT_PNG:
        f = {
          id: "toolbar-export-PNG",
          title: o,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case Tt.EXPORT_JPG:
        f = {
          id: "toolbar-export-JPG",
          title: r,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      // add more toolbar control configuration here
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
    return f;
  }
  getControlIconByType(t) {
    switch (t) {
      case Tt.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case Tt.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case Tt.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case Tt.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case Tt.EXIT_FULLSCREEN:
        return '<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>';
      case Tt.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case Tt.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case Tt.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case Tt.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      // add more icons here
      // svg icon must be with 32x32 viewBox
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
  }
};
bs.buttonID = 0;
let Tr = bs;
const Os = class Os extends dt {
  constructor(t, e, n, s) {
    super(t, e, s), this.type = "layout", this.configs = s, this.children = n, this._instanceID = Os.instanceID++, this.init();
  }
  init() {
    this.children.forEach((t) => {
      t.components.forEach((e) => {
        e.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const t = this.parent;
    let e = 0;
    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((n) => {
      const s = O(n, "growth");
      return s === be.PREFERRED || s === be.FIXED;
    }).each(function(n) {
      e += n.size;
    }), e;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((e) => O(e, "growth") === be.STRETCH).size();
  }
  render(t = !0) {
    const e = this.model.getOptions(), n = this.parent, { width: s, height: a } = I.getHTMLElementSize(n.node()), r = this.configs.direction === ze.ROW || this.configs.direction === ze.ROW_REVERSE, o = O(this.model.getOptions(), "style", "prefix"), c = n.classed(
      `${Kt}--${o}--layout-row`,
      this.configs.direction === ze.ROW
    ).classed(
      `${Kt}--${o}--layout-row-reverse`,
      this.configs.direction === ze.ROW_REVERSE
    ).classed(
      `${Kt}--${o}--layout-column`,
      this.configs.direction === ze.COLUMN
    ).classed(
      `${Kt}--${o}--layout-column-reverse`,
      this.configs.direction === ze.COLUMN_REVERSE
    ).classed(
      `${Kt}--${o}--layout-alignitems-center`,
      this.configs.alignItems === Tl.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    c.enter().append("div").merge(n.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (d) => `layout-child layout-child-${this._instanceID} ${d.id}`).each(function(d) {
      d.components.forEach((u) => {
        const p = D(this), m = O(d, "renderType") === at.SVG;
        u.setParent(
          m ? I.appendOrSelect(p, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : p
        ), m && !p.select("svg.layout-svg-wrapper").attr("aria-label") && p.select("svg.layout-svg-wrapper").attr("aria-label", e?.accessibility?.svgAriaLabel || e?.title);
        const g = O(d, "growth");
        (g === be.PREFERRED || g === be.FIXED) && u.render(t);
      });
    }), n.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(d) {
      const u = O(d, "growth"), f = O(d, "renderType") === at.SVG ? I.getSVGElementSize(D(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : I.getHTMLElementSize(this);
      if (u === be.PREFERRED) {
        const m = r ? f.width : f.height, g = r ? s : a;
        d.size = m / g * 100;
      }
    }), c.exit().remove(), this.children.filter((d) => O(d, "growth") === be.STRETCH).forEach((d) => {
      d.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const h = n.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    r ? h.style("width", (d) => `${d.size / 100 * s}px`).style("height", "100%") : h.style("height", (d) => `${d.size / 100 * a}px`).style("width", "100%"), h.each(function(d) {
      d.components.forEach((u) => {
        O(d, "growth") === be.STRETCH && u.render(t);
      });
    });
  }
  // Pass on model to children as well
  setModel(t) {
    super.setModel(t), this.children.forEach((e) => {
      e.components.forEach((n) => n.setModel(t));
    });
  }
  // Pass on essentials to children as well
  setServices(t) {
    super.setServices(t), this.children.forEach((e) => {
      e.components.forEach((n) => n.setServices(t));
    });
  }
  destroy() {
    this.children.forEach((t) => {
      t.components.forEach((e) => e.destroy());
    });
  }
};
Os.instanceID = Math.floor(Math.random() * 99999999999);
let br = Os;
class lm extends dt {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    this.getComponentContainer({
      isPresentational: !0
    }).style("width", `${this.configs.size || Ea.default.size}px`).style("height", `${this.configs.size || Ea.default.size}px`).attr("opacity", 0);
  }
}
class cm extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      const s = this.services.domUtils.getChartID();
      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${s}__modal-title`).attr("aria-describedby", `${s}__modal-description`).attr("tabindex", -1).style("opacity", 1).style("visibility", "visible"), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), this.modal.on("click", this.handleHideModal), this.modal.select(".cds--modal-container").on("click", (a) => {
        a.stopPropagation();
      }), this.modal.select(".cds--modal-close").on("click", this.handleHideModal), typeof window < "u" && window.addEventListener("keydown", this.handleEscapeKey);
    }, this.handleEscapeKey = (s) => {
      s.key === "Escape" && this.handleHideModal();
    }, this.handleHideModal = () => {
      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null).style("opacity", 0).style("visibility", "hidden"), this.modal.on("click", null), this.modal.select(".cds--modal-container").on("click", null), this.modal.select(".cds--modal-close").on("click", null), typeof window < "u" && window.removeEventListener("keydown", this.handleEscapeKey);
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(b.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(b.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const t = this.services.domUtils.getChartID(), e = this.model.getOptions(), { title: n, downloadAsCSV: s } = O(e, "locale", "translations", "tabularRep"), a = O(e, "style", "prefix"), r = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container">
			<div class="cds--modal-header">

				<p class="cds--modal-header__label cds--type-delta" id="${t}__modal-title">${n}</p>

				<p class="cds--modal-header__heading cds--type-beta" id="${t}__modal-description">${ue(
      e.title
    )}</p>

				<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${Et(r, 0).map(
      (o) => `<th scope="col">
								<div class="cds--table-header-label">${ue(o)}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${r.slice(1).map(
      (o) => `
							<tr>
								${o.map((c) => `<td>${ue(c)}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer">
			  <div class="${Kt}--${a}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${s}</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const n = D(this.services.domUtils.getHolder()), s = O(e, "style", "prefix");
      this.modal = I.appendOrSelect(n, `div.${Kt}--${s}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class Dd extends dt {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = at.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getComponentContainer(), n = O(this.getOptions(), "title"), s = e.selectAll("p.title").data([n]);
    if (s.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(s).html((a) => ue(a)), s.node() && s.node().offsetWidth < s.node().scrollWidth) {
      const a = this;
      s.on("mouseover", function(r) {
        a.services.events.dispatchEvent(b.Tooltip.SHOW, {
          event: r,
          hoveredElement: s,
          content: s.text()
        });
      }).on("mousemove", function(r) {
        a.services.events.dispatchEvent(b.Tooltip.MOVE, {
          event: r
        });
      }).on("mouseout", function() {
        a.services.events.dispatchEvent(b.Tooltip.HIDE);
      });
    }
    s.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(t, e) {
    if (e <= 0)
      return;
    const n = t.text();
    if (t.node().getComputedTextLength() > e) {
      t.append("tspan").text("...");
      const s = I.appendOrSelect(t, "tspan").node().getComputedTextLength(), a = t.text(), r = this.getSubstringIndex(
        t.node(),
        0,
        a.length - 1,
        e - s
      );
      t.html(a.substring(0, r - 1)).append("tspan").text("...");
      const o = this;
      t.on("mouseover", function(c) {
        o.services.events.dispatchEvent(b.Tooltip.SHOW, {
          event: c,
          hoveredElement: t,
          content: n
        });
      }).on("mousemove", function(c) {
        o.services.events.dispatchEvent(b.Tooltip.MOVE, {
          event: c
        });
      }).on("mouseout", function() {
        o.services.events.dispatchEvent(b.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return I.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(t, e, n, s) {
    const a = Math.floor((n + e) / 2);
    return t.getSubStringLength(0, a) > s ? this.getSubstringIndex(t, e, a, s) : t.getSubStringLength(0, a) < s ? t.getSubStringLength(0, a + 1) > s ? a : this.getSubstringIndex(t, a, n, s) : a;
  }
}
class Nd extends dt {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = at.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = O(e, "legend"), s = O(n, "alignment"), a = O(e, "legend", "orientation");
    let r = this.model.getDataGroups();
    const { DISABLED: o } = Mt.items.status, c = r.some((S) => S.status === o), l = O(n, "order"), h = this.getComponentContainer().classed("center-aligned", s === te.CENTER).classed("right-aligned", s === te.RIGHT).classed(a || "horizontal", !0).classed("has-deactivated-items", c).attr("role", lt.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    l && (r = this.sortDataGroups(r, l));
    const d = h.selectAll("div.legend-item").data(r, (S) => S.name), u = d.enter().append("div").attr("class", "legend-item");
    u.merge(h.selectAll("div.legend-item")).classed("active", function(S) {
      return S.status === Mt.items.status.ACTIVE;
    });
    const p = O(this.getOptions(), "legend", "clickable");
    h.classed("clickable", p && r.length > 1);
    const f = Mt.checkbox.radius, m = u.append("div").classed("checkbox", !0), g = m.merge(d.select("div.checkbox")).attr("role", lt.CHECKBOX).attr("tabindex", p ? 0 : -1).attr(
      "aria-labelledby",
      (S, y) => this.services.domUtils.generateElementIDString(`legend-datagroup-${y}-title`)
    ).attr("aria-checked", ({ status: S }) => S === Mt.items.status.ACTIVE).attr("width", f * 2).attr("height", f * 2).attr(
      "class",
      (S) => this.model.getColorClassName({
        classNameTypes: [nt.BACKGROUND],
        dataGroupName: S.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (S) => S.status === Mt.items.status.ACTIVE ? this.model.getFillColor(S.name) || this.model.getStrokeColor(S.name) : null
    ).classed("active", function(S) {
      return S.status === Mt.items.status.ACTIVE;
    });
    m.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), u.append("p").merge(d.select("p"));
    const v = O(e, "legend", "additionalItems");
    if (v && r.length) {
      const S = this, y = h.selectAll("div.additional-item").data(v);
      y.exit().remove();
      const E = y.enter().append("div").merge(y).classed("legend-item", !0).classed("additional", !0).attr("role", "img").attr(
        "aria-labelledby",
        (C, _) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${g.size() + _}-title`
        )
      );
      E.selectAll("*").remove();
      let x, T = 1;
      E.append("svg").classed("icon", !0).each(function(C) {
        const _ = D(this);
        !x || x != C.type ? (x = C.type, T = 1) : T++, S.addAdditionalItem(_, C, T);
      }), E.append("p").merge(E.select("p")), this.truncateLegendText();
    }
    d.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), p && u.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(t, e) {
    if (t.sort(
      (n, s) => e.indexOf(n.name) - e.indexOf(s.name)
    ), e.length < t.length) {
      const n = t.length - e.length;
      return t.slice(n).concat(t.slice(0, n));
    }
    return t;
  }
  addAdditionalItem(t, e, n) {
    const { width: s, height: a } = Mt.area;
    if (e.type === Me.RADIUS ? t.style("width", `${a}px`).style("height", `${a}px`) : t.style("width", `${s}px`).style("height", `${a}px`), e.type === Me.RADIUS) {
      const { iconData: r, fill: o, stroke: c } = Mt.radius;
      t.attr("fill", "none").selectAll("circle").data(r).enter().append("circle").classed("radius", !0).attr("role", lt.IMG).attr("aria-label", "radius").attr("cx", (h) => h.cx).attr("cy", (h) => h.cy).attr("r", (h) => h.r).style("fill", e.fill ? e.fill : o).style("stroke", e.stroke ? e.stroke : c);
    } else if (e.type === Me.LINE) {
      const r = Mt.line;
      t.select("line.line").empty() && t.append("line").classed(`line-${n}`, !0).attr("role", lt.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", r.yPosition).attr("x2", s).attr("y2", r.yPosition).style("stroke", e.stroke ? e.stroke : r.stroke).style("stroke-width", r.strokeWidth);
    } else if (e.type === Me.AREA)
      t.select("rect.area").empty() && t.append("rect").classed(`area-${n}`, !0).attr("role", lt.IMG).attr("aria-label", "area").attr("width", s).attr("height", a).style(
        "fill",
        n > 3 && !e.fill ? Mt.area.fill : e.fill
      ).style("stroke", e.stroke);
    else if (e.type === Me.SIZE) {
      const { iconData: r, fill: o, stroke: c } = Mt.size;
      t.attr("fill", "none").attr("role", lt.IMG).attr("aria-label", "size").selectAll("rect").data(r).enter().append("rect").classed("size", !0).attr("width", (h) => h.width).attr("height", (h) => h.height).attr("y", () => 0).style("fill", e.fill ? e.fill : o).style("stroke", e.stroke ? e.stroke : c).style("stroke-width", 1);
    } else if (e.type === Me.QUARTILE) {
      const { iconData: r } = Mt.quartile;
      t.selectAll("rect").attr("role", lt.IMG).attr("aria-label", "quartile").data(r).enter().append("rect").attr("class", (c, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height);
    } else if (e.type === Me.ZOOM) {
      const { iconData: r, color: o } = O(Mt, "zoom"), c = t.attr("role", lt.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(r).enter();
      c.append("g").attr("x", (l) => l.x).attr("y", (l) => l.y).attr("width", (l) => l.width).attr("height", (l) => l.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => e.color ? e.color : o), c.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => e.color ? e.color : o);
    }
  }
  truncateLegendText() {
    const t = this.getComponentContainer(), e = O(this.getOptions(), "legend", "truncation"), n = O(e, "type"), s = O(e, "threshold"), a = O(e, "numCharacter"), r = t.selectAll("div.legend-item p");
    r.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), n !== Qe.NONE ? r.html(function(o) {
      const c = ue(o.name);
      return c.length > s && c.length !== a ? kn(c, n, a) : c;
    }) : r.html((o) => ue(o.name));
  }
  addEventListeners() {
    const t = this, e = this.getComponentContainer(), n = this.getOptions(), s = O(n, "legend"), a = O(s, "truncation");
    e.selectAll("div.legend-item").on("mouseover", function(r) {
      t.services.events.dispatchEvent(b.Legend.ITEM_HOVER, {
        hoveredElement: D(this)
      });
      const o = D(this);
      o.select("div.checkbox").classed("hovered", !0);
      const c = o.datum();
      c.name.length > a.threshold && a.numCharacter < c.name.length && a.type !== Qe.NONE && t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        content: c.name
      });
    }).on("mousemove", function(r) {
      D(this).datum().name.length > a.threshold && a.type !== Qe.NONE && t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function() {
      t.services.events.dispatchEvent(b.Legend.ITEM_CLICK, {
        clickedElement: D(this)
      });
      const o = D(this).datum();
      t.model.toggleDataLabel(o.name);
    }).on("mouseout", function() {
      const r = D(this);
      r.select("div.checkbox").classed("hovered", !1), r.datum().name.length > a.threshold && a.type !== Qe.NONE && t.services.events.dispatchEvent(b.Tooltip.HIDE), t.services.events.dispatchEvent(b.Legend.ITEM_MOUSEOUT, {
        hoveredElement: r
      });
    }), e.selectAll("div.legend-item div.checkbox").on("keyup", function(r) {
      r.key && r.key === "Tab" && t.services.events.dispatchEvent(b.Legend.ITEM_HOVER, {
        hoveredElement: D(this)
      });
    }), e.selectAll("div.legend-item div.checkbox").on("keydown", function(r, o) {
      r.key && r.key === " " ? (r.preventDefault(), t.model.toggleDataLabel(o.name)) : r.key && r.key === "Tab" && t.services.events.dispatchEvent(b.Legend.ITEM_MOUSEOUT, {
        hoveredElement: D(this)
      });
    }), e.selectAll("g.additional-item").on("mouseover", function(r) {
      const o = D(this), c = o.datum();
      c.name.length > a.threshold && t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        content: c.name
      });
    });
  }
}
class Pd extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "chart-clip", this.renderType = at.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const t = this.parent, { cartesianScales: e } = this.services;
    if (!e) throw new Error("Service cartesianScales was undefined");
    const n = e.getMainXScale(), s = e.getMainYScale(), [a, r] = n.range(), [o, c] = s.range();
    if (!t)
      throw new Error("svg is undefined");
    this.chartClipPath = I.appendOrSelect(
      t,
      `clipPath.${this.type}`
    ).attr("id", this.chartClipId);
    const l = I.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    r - a > 0 && l.attr("x", a).attr("y", c).attr("width", r - a).attr("height", o - c), this.chartClipPath.merge(l).lower();
  }
}
class um extends Pd {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const t = this.parent, { width: e, height: n } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = I.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const s = I.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    s.attr("x", 0).attr("y", 0).attr("width", e).attr("height", n), this.chartClipPath.merge(s).lower();
  }
}
var Ye, Lt;
(function(i) {
  i.LEFT = "left", i.RIGHT = "right", i.TOP = "top", i.BOTTOM = "bottom";
})(Lt || (Lt = {}));
var Or = (Ye = {}, Ye[Lt.LEFT] = function(i, t, e) {
  return {
    top: i.top - Math.round(t.offsetHeight / 2) + Math.round(e.height / 2),
    left: Math.round(i.left - t.offsetWidth)
  };
}, Ye[Lt.RIGHT] = function(i, t, e) {
  return {
    top: i.top - Math.round(t.offsetHeight / 2) + Math.round(e.height / 2),
    left: Math.round(i.left + e.width)
  };
}, Ye[Lt.TOP] = function(i, t, e) {
  return {
    top: Math.round(i.top - t.offsetHeight),
    left: i.left - Math.round(t.offsetWidth / 2) + Math.round(e.width / 2)
  };
}, Ye[Lt.BOTTOM] = function(i, t, e) {
  return {
    top: Math.round(i.top + e.height),
    left: i.left - Math.round(t.offsetWidth / 2) + Math.round(e.width / 2)
  };
}, Ye), Lr = typeof window < "u" ? window : {
  innerHeight: 0,
  innerWidth: 0
}, ks = (
  /** @class */
  function() {
    function i(t) {
      t === void 0 && (t = {}), this.positions = Or, this.positions = Object.assign({}, Or, t);
    }
    return i.prototype.getRelativeOffset = function(t) {
      for (var e = {
        left: t.offsetLeft,
        top: t.offsetTop
      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )
        e.left += t.offsetLeft, e.top += t.offsetTop, t = t.offsetParent;
      return e;
    }, i.prototype.getAbsoluteOffset = function(t) {
      for (var e = t, n = {
        top: 0,
        left: 0
      }; e.offsetParent; ) {
        var s = getComputedStyle(e.offsetParent);
        s.position === "static" && s.marginLeft && s.marginTop && (parseInt(s.marginTop, 10) && (n.top += parseInt(s.marginTop, 10)), parseInt(s.marginLeft, 10) && (n.left += parseInt(s.marginLeft, 10))), e = e.offsetParent;
      }
      var a = t.getBoundingClientRect(), r = document.body.getBoundingClientRect();
      return {
        top: a.top - r.top + n.top,
        left: a.left - r.left + n.left
      };
    }, i.prototype.findRelative = function(t, e, n) {
      var s = this.getRelativeOffset(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, e, n);
    }, i.prototype.findAbsolute = function(t, e, n) {
      var s = this.getAbsoluteOffset(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, e, n);
    }, i.prototype.findPosition = function(t, e, n, s) {
      s === void 0 && (s = this.getAbsoluteOffset.bind(this));
      var a = s(t), r = t.getBoundingClientRect();
      return this.calculatePosition(a, r, e, n);
    }, i.prototype.findPositionAt = function(t, e, n) {
      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, e, n);
    }, i.prototype.getPlacementBox = function(t, e) {
      var n = t.offsetHeight + e.top, s = t.offsetWidth + e.left;
      return {
        top: e.top,
        bottom: n,
        left: e.left,
        right: s
      };
    }, i.prototype.addOffset = function(t, e, n) {
      return e === void 0 && (e = 0), n === void 0 && (n = 0), Object.assign({}, t, {
        top: t.top + e,
        left: t.left + n
      });
    }, i.prototype.setElement = function(t, e) {
      t.style.top = e.top + "px", t.style.left = e.left + "px";
    }, i.prototype.findBestPlacement = function(t, e, n, s, a) {
      var r = this;
      s === void 0 && (s = this.defaultContainerFunction.bind(this)), a === void 0 && (a = this.findPosition.bind(this));
      var o = n.map(function(c) {
        var l = a(t, e, c), h = r.getPlacementBox(e, l), d = 0, u = 0, p = s();
        h.top < p.top ? d = p.top - h.top : h.bottom > p.height && (d = h.bottom - p.height), h.left < p.left ? u = p.left - h.left : h.right > p.width && (u = h.right - p.width), d && !u ? u = 1 : u && !d && (d = 1);
        var f = e.offsetHeight * e.offsetWidth, m = d * u, g = f - m, v = g / f;
        return {
          placement: c,
          weight: v
        };
      });
      return o.sort(function(c, l) {
        return l.weight - c.weight;
      }), o[0].placement;
    }, i.prototype.findBestPlacementAt = function(t, e, n, s) {
      var a = this;
      s === void 0 && (s = this.defaultContainerFunction.bind(this));
      var r = function(o, c, l) {
        return a.findPositionAt(t, c, l);
      };
      return this.findBestPlacement(null, e, n, s, r);
    }, i.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: Lr.innerHeight,
        width: Lr.innerWidth
      };
    }, i.prototype.calculatePosition = function(t, e, n, s) {
      return this.positions[s] ? this.positions[s](t, n, e) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, i;
  }()
);
new ks();
class $d extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "tooltip", this.renderType = at.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new ks(), this.handleShowTooltip = (s) => {
      const a = s.detail.data || s.detail.items, r = D(s.detail.event.target).datum();
      let o;
      const c = this.formatItems(this.getItems(s));
      s.detail.content ? o = `<div class="title-tooltip"><p>${ts(s.detail.content)}</p></div>` : o = ts(this.getTooltipHTML(c));
      const l = I.appendOrSelect(this.tooltip, "div.content-box");
      if (O(this.getOptions(), "tooltip", "customHTML"))
        if (s.detail.content) {
          const h = `<div class="title-tooltip"><p>${ts(
            s.detail.content
          )}</p></div>`;
          l.html(h);
        } else
          l.html(
            `<div class="title-tooltip"><p>${ts(
              this.model.getOptions().tooltip.customHTML(a, o, r)
            )}</p></div>`
          );
      else
        l.html(o);
      l.selectAll(".datapoint-tooltip").each(function(h, d) {
        const u = c[d];
        c[d] && c[d].color && D(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", u.color);
      }), this.positionTooltip(s), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = s.type;
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(b.Tooltip.MOVE, (t) => {
      this.lastTriggeredEventType !== b.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);
    }), this.services.events.addEventListener(b.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(b.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(b.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(b.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(b.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(b.Tooltip.MOVE, null), this.services.events.removeEventListener(b.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(b.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(b.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(b.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(b.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  getItems(t) {
    return t.detail.items ? t.detail.items : [];
  }
  formatItems(t) {
    const e = this.getOptions(), n = O(e, "tooltip", "truncation", "type"), s = O(e, "tooltip", "truncation", "threshold"), a = O(e, "tooltip", "truncation", "numCharacter");
    return n !== Qe.NONE ? t.map((r) => {
      const o = r.labelIcon ? 12 : 0;
      return r.value = this.valueFormatter(r.value, r.label), r.label && r.label.length + o > s && (r.label = kn(r.label, n, a)), r.value && r.value.length > s && (r.value = kn(r.value, n, a)), r;
    }) : t.map((r) => (r.value = this.valueFormatter(r.value, r.label), r));
  }
  getTooltipHTML(t) {
    return '<ul class="multi-tooltip">' + t.map(
      (e) => `<li>
					<div class="datapoint-tooltip${e.bold ? " bold" : ""}">
						${e.class || e.color ? `<div class="tooltip-color ${e.class}"></div>` : ""}
						<div class="label">
						<p>${e.label || ""}</p>
						${e.labelIcon ? `<span class="label-icon"/>${e.labelIcon}</span>` : ""}
						</div>
						${e.value === void 0 || e.value === null ? "" : `<p class="value"/>${e.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  isDate(t) {
    return t instanceof Date;
  }
  valueFormatter(t, e) {
    const n = this.getOptions(), s = O(n, "tooltip", "valueFormatter"), {
      code: a,
      number: r,
      date: o
    } = O(n, "locale");
    if (s)
      return s(t, e);
    if (this.isDate(t))
      return o(t, a, { month: "short", day: "numeric", year: "numeric" });
    try {
      if (typeof t == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(t)) {
        const c = new Date(t);
        return o(c, a, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }
    } catch {
    }
    return r(t, a);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = O(e, "tooltip", "enabled");
    if (n) {
      const s = D(this.services.domUtils.getHolder()), a = O(e, "style", "prefix");
      this.tooltip = I.appendOrSelect(s, `div.${Kt}--${a}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else !n && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  addOffsetByPlacement(t, e, n) {
    const s = Object.assign({}, t);
    return e == Lt.LEFT ? s.left -= n : e == Lt.RIGHT ? s.left += n : e == Lt.TOP ? s.top -= n : e == Lt.BOTTOM && (s.top += n), s;
  }
  positionTooltip(t) {
    const e = this.services.domUtils.getHolder(), n = e.offsetWidth, s = e.offsetHeight, a = this.tooltip.node(), r = this.getOptions(), o = O(r, "zoomBar", "top", "enabled"), c = !!O(t, "detail", "noWrap"), l = Array.isArray(O(t, "detail", "placements")), h = l ? O(t, "detail", "placements") : [Lt.RIGHT, Lt.LEFT, Lt.TOP, Lt.BOTTOM];
    let d, { horizontalOffset: u } = xa;
    const { defaultOffset: p } = xa;
    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", c), l) {
      const g = O(t, "detail", "event", "target"), v = this.services.domUtils.getElementOffset(g, !0);
      d = this.positionService.findBestPlacementAt(
        v,
        a,
        h,
        () => ({
          top: 0,
          left: 0,
          width: n,
          height: s
        })
      );
      let S = this.positionService.findPosition(
        g,
        a,
        d,
        () => this.services.domUtils.getElementOffset(g)
      );
      S = this.addOffsetByPlacement(S, d, p), this.positionService.setElement(a, S);
      return;
    }
    let f = O(t, "detail", "mousePosition");
    if (!f)
      f = an(O(t, "detail", "event"), e);
    else {
      const g = O(r, "zoomBar", "top", "type"), v = jt.height[g];
      o && (f[1] += v + jt.spacerHeight);
    }
    f[0] / n > 0.9 ? d = Lt.LEFT : f[0] / n < 0.1 ? d = Lt.RIGHT : d = this.positionService.findBestPlacementAt(
      {
        left: f[0],
        top: f[1]
      },
      a,
      h,
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: n,
        height: s
      })
    ), d === Lt.LEFT && (u *= -1);
    const m = this.positionService.findPositionAt(
      {
        left: f[0] + u,
        top: f[1]
      },
      a,
      d
    );
    this.positionService.setElement(a, m);
  }
}
const nn = class nn extends dt {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = at.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.parent, n = this.getComponentContainer({
      isPresentational: !0
    });
    if (!e) throw new Error("SVG was not defined");
    const s = I.appendOrSelect(
      e,
      "svg.chart-grid-backdrop"
    ), a = I.appendOrSelect(s, `g.${this.type}`), r = I.appendOrSelect(a, this.selectionSelector), { width: o, height: c } = I.getSVGElementSize(s, {
      useAttrs: !0
    }), { cartesianScales: l } = this.services, h = l.getMainXScaleType(), d = l.getMainXScale(), [u] = d.range();
    n.attr("transform", `translate(${u},0)`);
    const p = I.appendOrSelect(n, this.frontSelectionSelector);
    if (d && h === kt.TIME) {
      let f = this.model.get("zoomDomain");
      f === void 0 && (f = this.services.zoom.getDefaultZoomBarDomain(), f && this.model.set({ zoomDomain: f }, { animate: !1 }));
      const m = (x) => {
        const T = x[1] - x[0];
        let C = "0," + T.toString();
        const _ = Math.floor(c / nn.DASH_LENGTH), V = _ * nn.DASH_LENGTH;
        for (let R = 0; R < _; R++)
          C += "," + nn.DASH_LENGTH;
        C += "," + (c - V), _ % 2 === 1 && (C += ",0"), C += "," + T.toString(), C += "," + c.toString(), p.attr("stroke-dasharray", C);
      }, g = (x) => {
        const T = x.selection;
        T === null || T[0] === T[1] || (p.attr("x", parseFloat(r.attr("x")) + parseFloat(s.attr("x"))).attr("y", r.attr("y")).attr("width", r.attr("width")).attr("height", r.attr("height")).style("cursor", "pointer").style("display", null), m(T));
      }, v = (x, T) => {
        const C = Ml().range([0, o]).domain(f);
        let _ = [C.invert(x), C.invert(T)], V = "manual";
        _[0].valueOf() === _[1].valueOf() ? (_ = this.services.zoom.getDefaultZoomBarDomain(), V = "reset") : V = "manual", (f[0].valueOf() !== _[0].valueOf() || f[1].valueOf() !== _[1].valueOf()) && this.services.zoom.handleDomainChange(_, { dispatchEvent: !0, type: V });
      };
      let S;
      const y = (x) => {
        const T = x.selection;
        T !== null && (v(T[0], T[1]), a.call(S.move, null), p.style("display", "none"));
      };
      c != 0 && o != 0 && (S = fo().extent([
        [0, 0],
        [o - 1, c]
      ]).on("start brush end", g).on("end.brushed", y), a.call(S));
      const E = this.services.zoom.getZoomRatio();
      s.on("click", function(x) {
        if (x.shiftKey) {
          const T = this.services.domUtils.getHolder(), C = an(a.node(), T)[0];
          let _ = C - o * E / 2;
          _ < 0 && (_ = 0);
          let V = C + o * E / 2;
          V > o && (V = o), v(_, V);
        }
      });
    }
  }
};
nn.DASH_LENGTH = 4;
let Ar = nn;
class hm extends dt {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = at.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = fo(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(b.ZoomBar.UPDATE, this.render.bind(this));
    const t = O(this.getOptions(), "zoomBar", J.TOP, "data");
    this.model.setZoomBarData(t);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "zoom bar"
    }), n = this.services.zoom.isZoomBarLoading(J.TOP), s = this.services.zoom.isZoomBarLocked(J.TOP), a = O(this.getOptions(), "zoomBar", J.TOP, "type"), r = O(this.getOptions(), "axes", J.BOTTOM, "highlights"), o = jt.height[a], { width: c } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (c === 0)
      return;
    let l = 0;
    const h = this.model.get("axesMargins");
    h && h.left && (l = h.left);
    const d = I.appendOrSelect(e, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1).attr("role", "presentation");
    if (I.appendOrSelect(e, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", jt.spacerHeight).attr("opacity", 1).attr("fill", "none"), a === Ue.GRAPH_VIEW ? I.appendOrSelect(d, "rect.zoom-bg").attr("x", l).attr("y", 0).attr("width", c - l).attr("height", "100%").classed("zoom-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : a === Ue.SLIDER_VIEW && I.appendOrSelect(d, "rect.zoom-slider-bg").attr("x", l).attr("y", o / 2 - 1).attr("width", c - l).attr("height", 2).classed("zoom-slider-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), n) {
      this.renderSkeleton(d, l, c);
      return;
    }
    const { cartesianScales: u } = this.services, p = u.getMainXScale(), f = u.getMainYScale(), m = u.getMainXScaleType();
    if (p && m === kt.TIME) {
      let g = this.services.zoom.getZoomBarData();
      if (Wr(g) || g.length === 1)
        return;
      this.xScale = p.copy(), this.yScale = f.copy();
      const v = this.services.zoom.getDefaultZoomBarDomain(g);
      g = this.compensateDataForDefaultDomain(g, v);
      const S = this.model.get("initialZoomDomain"), y = O(
        this.getOptions(),
        "zoomBar",
        J.TOP,
        "initialZoomDomain"
      );
      y && y[0] && y[1] && (y[0] = new Date(y[0]), y[1] = new Date(y[1])), y && !(S && S[0].valueOf() === y[0].valueOf() && S[1].valueOf() === y[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: sn([], y),
          zoomDomain: y ? sn([], y) : v
        },
        { skipUpdate: !0 }
      ) : y === null && S !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: sn([], v)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([l, c]).domain(v), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(Ls(g, (T) => T.value));
      const E = this.model.get("zoomDomain");
      if (a === Ue.GRAPH_VIEW && (this.renderZoomBarArea(d, "path.zoom-graph-area-unselected", g, null), this.updateClipPath(e, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(d, "path.zoom-graph-area", g, this.clipId), this.renderZoomBarBaseline(d, l, c), r)) {
        const T = r.highlightStartMapsTo, C = r.highlightEndMapsTo, _ = r.color, V = r.labelMapsTo;
        r.data.forEach((R, A) => {
          I.appendOrSelect(d, `rect.highlight-${A}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(R[T])).attr(
            "width",
            this.xScale(R[C]) - this.xScale(R[T])
          ).style(
            "fill",
            _ && _.scale[R[V]] ? _.scale[R[V]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            _ && _.scale[R[V]] ? _.scale[R[V]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(E, l, c);
      const x = I.appendOrSelect(e, this.brushSelector).call(this.brush);
      if (E !== void 0) if (E[0].valueOf() === E[1].valueOf())
        x.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
      else {
        const T = E.map((C) => this.xScale(C));
        T[1] - T[0] < this.MIN_SELECTION_DIFF || (x.call(this.brush.move, T), this.updateBrushHandle(this.getComponentContainer(), T));
      }
      s && (this.brush.filter(() => !1), x.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(t, e, n) {
    const s = (o) => {
      const c = o.selection;
      c === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : c[0] === c[1] || this.handleBrushedEvent(o, t, this.xScale, c);
    }, a = O(this.getOptions(), "zoomBar", J.TOP, "type"), r = jt.height[a];
    this.brush.extent([
      [e, 0],
      [n, r]
    ]).on("start brush end", null).on("start brush end", s);
  }
  // brush event listener
  handleBrushedEvent(t, e, n, s) {
    const a = [n.invert(s[0]), n.invert(s[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), s), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {
      let r = "manual";
      if (e && e[0] && e[1]) {
        const c = this.services.zoom.getDefaultZoomBarDomain();
        a[0].valueOf() === c[0].valueOf() && a[1].valueOf() === c[1].valueOf() ? r = "reset" : r = "manual";
      }
      (e === void 0 || e[0] !== a[0] || e[1] !== a[1]) && this.services.zoom.handleDomainChange(a, {
        dispatchEvent: !1,
        type: r
      });
      let o;
      t.type === "start" ? o = b.ZoomBar.SELECTION_START : t.type === "brush" ? o = b.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (o = b.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(b.ZoomDomain.CHANGE, {
        newDomain: a,
        type: r
      })), this.services.events.dispatchEvent(o, {
        selection: s,
        newDomain: a
      });
    }
  }
  updateBrushHandle(t, e) {
    const n = this, s = jt.handleWidth, a = O(this.getOptions(), "zoomBar", J.TOP, "type"), r = jt.height[a], o = -s / 2, c = jt.handleBarWidth, l = a === Ue.GRAPH_VIEW ? jt.handleBarHeight : 6, h = -c / 2, d = (r - l) / 2;
    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(p) {
      if (p.type === "w")
        return Math.max(e[0] + o, n.maxSelectionRange[0]);
      if (p.type === "e")
        return Math.min(e[1] + o, n.maxSelectionRange[1] - s);
    }).attr("y", 0).attr("width", s).attr("height", r).attr("cursor", "ew-resize").style("display", null);
    const u = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    u.enter().append("rect").attr("class", function(p) {
      return "handle-bar handle-bar--" + p.type;
    }), u.attr("x", function(p) {
      if (p.type === "w")
        return Math.max(
          e[0] + h,
          n.maxSelectionRange[0] - o + h
        );
      if (p.type === "e")
        return Math.min(
          e[1] + h,
          n.maxSelectionRange[1] + o + h
        );
    }).attr("y", d).attr("width", c).attr("height", l).attr("cursor", "ew-resize"), a === Ue.SLIDER_VIEW && this.updateSliderSelectedArea(e), this.updateClipPath(
      t,
      this.clipId,
      e[0],
      0,
      e[1] - e[0],
      r
    );
  }
  updateSliderSelectedArea(t) {
    const e = O(this.getOptions(), "zoomBar", J.TOP, "type"), n = jt.height[e], a = this.getComponentContainer().select("svg.zoom-container");
    I.appendOrSelect(a, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", n / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);
  }
  renderZoomBarArea(t, e, n, s) {
    const { cartesianScales: a } = this.services, r = a.getMainXAxisPosition(), o = a.getMainYAxisPosition(), c = a.getMainXScaleType(), l = a.getMainYScaleType(), h = (v, S, y) => (E) => a.getValueFromScale(v, S, y, E), d = h(this.xScale, c, r), u = h(this.yScale, l, o), p = O(this.getOptions(), "zoomBar", J.TOP, "type"), f = jt.height[p], m = Ki().x((v) => d(v)).y0(f).y1((v) => f - u(v)), g = I.appendOrSelect(t, e).datum(n).attr("d", m);
    s && g.attr("clip-path", `url(#${s})`);
  }
  updateClipPath(t, e, n, s, a, r) {
    const o = I.appendOrSelect(t, "clipPath").attr("id", e);
    I.appendOrSelect(o, "rect").attr("x", n).attr("y", s).attr("width", a).attr("height", r);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(t, e) {
    if (!t || t.length < 2)
      return;
    const n = fl(t), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier();
    if (Number(e[0]) < Number(n[0][s])) {
      const r = {};
      r[s] = e[0], r[a] = 0, n.unshift(r);
    }
    if (Number(e[1]) > Number(n[n.length - 1][s])) {
      const r = {};
      r[s] = e[1], r[a] = 0, n.push(r);
    }
    return n;
  }
  renderZoomBarBaseline(t, e, n, s = !1) {
    const a = O(
      this.model.getOptions(),
      "zoomBar",
      J.TOP,
      "type"
    ), r = jt.height[a], o = Pn()([
      [e, r],
      [n, r]
    ]);
    I.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", s).style(
      "stroke",
      s ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(t, e, n) {
    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), I.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), O(this.getOptions(), "zoomBar", J.TOP, "type") === Ue.GRAPH_VIEW && this.renderZoomBarBaseline(t, e, n, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(b.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class dm extends dt {
  constructor(t, e) {
    super(t, e), this.type = "threshold", this.renderType = at.SVG, this.positionService = new ks();
  }
  render(t = !1) {
    const e = O(this.getOptions(), "axes"), n = [];
    Object.keys(e).forEach((u) => {
      if (Object.values(J).includes(u)) {
        const p = e[u];
        p.thresholds && p.thresholds.length > 0 && n.push({
          axisPosition: u,
          thresholds: p.thresholds,
          correspondingDatasets: p?.correspondingDatasets,
          mapsTo: p?.mapsTo
        });
      }
    });
    const a = this.getComponentContainer({
      ariaLabel: "threshold lines",
      withinChartClip: !0
    }).selectAll("g.axis-thresholds").data(n, (u) => u.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g").merge(a);
    o.attr("class", (u) => `axis-thresholds ${u.axisPosition}`);
    const c = o.selectAll("g.threshold-group").data(
      (u) => u.thresholds.map((p) => (p.axisPosition = u.axisPosition, p.datum = this.constructDatumObj(u, p), p))
    );
    c.exit().attr("opacity", 0).remove();
    const l = c.enter().append("g");
    l.append("line").attr("class", "threshold-line"), l.append("rect").attr("class", "threshold-hoverable-area"), l.merge(c).attr("class", "threshold-group");
    const d = this;
    o.each(function({ axisPosition: u }) {
      const p = d.services.cartesianScales.getScaleByPosition(
        u
      ), f = d.services.cartesianScales.getScaleTypeByPosition(u);
      let m = null, g = null;
      u === J.LEFT || u === J.RIGHT ? (g = p, m = d.services.cartesianScales.getMainXScale()) : (m = p, g = d.services.cartesianScales.getMainYScale());
      const v = f === kt.LABELS, [S, y] = m.range(), [E, x] = g.range(), { cartesianScales: T } = d.services, C = T.getOrientation(), _ = (N) => T.getDomainValue(N), V = (N) => T.getRangeValue(N), [R, A] = xe(
        _,
        V,
        C
      ), H = D(this);
      u === J.TOP || u === J.BOTTOM ? (H.selectAll("line.threshold-line").transition().call(
        (N) => d.services.transitions.setupTransition({
          transition: N,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("y1", x).attr("y2", E).attr(
        "x1",
        ({ datum: N }) => R(N) + (v ? p.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: N }) => R(N) + (v ? p.step() / 2 : 0)
      ).style("stroke", ({ fillColor: N }) => N), H.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: N }) => -R(N)).attr("width", Math.abs(E - x)).classed("rotate", !0)) : (H.selectAll("line.threshold-line").transition().call(
        (N) => d.services.transitions.setupTransition({
          transition: N,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("x1", S).attr("x2", y).attr(
        "y1",
        ({ datum: N }) => A(N) + (v ? p.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: N }) => A(N) + (v ? p.step() / 2 : 0)
      ).style("stroke", ({ fillColor: N }) => N), H.selectAll("rect.threshold-hoverable-area").attr("x", S).attr("y", ({ datum: N }) => A(N)).attr("width", Math.abs(y - S)).classed("rotate", !1));
    }), this.services.events.addEventListener(b.Threshold.SHOW, (u) => {
      this.setThresholdLabelPosition(u.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(b.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(t) {
    const { value: e, axisPosition: n } = t, s = this.getOptions(), a = this.services.cartesianScales.getScaleTypeByPosition(n), { code: r, number: o } = O(s, "locale");
    if (a === kt.TIME) {
      const c = [J.LEFT, J.RIGHT].includes(n), l = this.services.cartesianScales.getMainXScale(), h = this.services.cartesianScales.getMainYScale(), d = c ? h : l, u = O(s, "timeScale"), p = di(
        d.ticks(),
        O(u, "timeInterval")
      );
      return pi(e, 0, d.ticks(), p, u, s.locale);
    }
    return o(e, r);
  }
  appendThresholdLabel() {
    const t = D(this.services.domUtils.getHolder()), e = O(this.getOptions(), "style", "prefix");
    this.label = I.appendOrSelect(
      t,
      `div.${Kt}--${e}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: t, datum: e }) {
    const n = this.services.domUtils.getHolder(), s = an(t, n), a = e.valueFormatter ? e.valueFormatter(e.value) : this.getFormattedValue(e);
    this.label.html(ue(`${e.label || "Threshold"}: ${a}`)).style("background-color", e.fillColor);
    const r = this.label.node(), o = this.positionService.findBestPlacementAt(
      {
        left: s[0],
        top: s[1]
      },
      r,
      [Lt.RIGHT, Lt.LEFT, Lt.TOP, Lt.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: n.offsetWidth,
        height: n.offsetHeight
      })
    ), c = this.positionService.findPositionAt(
      {
        left: s[0],
        top: s[1]
      },
      r,
      o
    );
    this.positionService.setElement(r, c);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(t, e) {
    const n = {};
    return t.correspondingDatasets && (n.group = O(t, "correspondingDatasets", 0)), n[t.mapsTo] = e.value, n;
  }
  addEventListeners() {
    const t = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      D(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(b.Threshold.SHOW, {
        event: n,
        hoveredElement: D(this),
        datum: D(this).datum()
      });
    }).on("mouseout", function(n) {
      D(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(b.Threshold.HIDE, {
        event: n,
        hoveredElement: D(this),
        datum: D(this).datum()
      });
    });
  }
}
class pm extends dt {
  constructor(t, e) {
    super(t, e), this.type = "highlight", this.renderType = at.SVG, this.positionService = new ks(), this.highlightStrokeWidth = 1;
  }
  render(t = !1) {
    const e = O(this.getOptions(), "axes"), n = [];
    Object.keys(e).forEach((u) => {
      if (Object.values(J).includes(u)) {
        const p = e[u];
        p.highlights && p.highlights.data.length > 0 && n.push({
          axisPosition: u,
          highlightStartMapsTo: p.highlights.highlightStartMapsTo,
          highlightEndMapsTo: p.highlights.highlightEndMapsTo,
          labelMapsTo: p.highlights.labelMapsTo,
          highlight: p.highlights.data,
          color: p.highlights.color
        });
      }
    });
    const a = this.getComponentContainer({
      ariaLabel: "highlight areas",
      withinChartClip: !0
    }).selectAll("g.axis-highlight").data(n, (u) => u.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g").merge(a);
    o.attr("class", (u) => `axis-highlight ${u.axisPosition}`);
    const c = o.selectAll("g.highlight-group").data(
      (u) => u.highlight.map((p) => (p.axisPosition = u.axisPosition, p.highlightStartMapsTo = u.highlightStartMapsTo, p.labelMapsTo = u.labelMapsTo, p.color = u.color, p.highlightEndMapsTo = u.highlightEndMapsTo, p))
    );
    c.exit().attr("opacity", 0).remove();
    const l = c.enter().append("g");
    l.append("rect").attr("class", "highlight-bar"), l.append("line").attr("class", "highlight-line"), l.merge(c).attr("class", "highlight-group");
    const d = this;
    o.each(function({ axisPosition: u }) {
      const p = d.services.cartesianScales.getMainXScale(), f = d.services.cartesianScales.getMainYScale(), [m, g] = p.range(), [v, S] = f.range(), { cartesianScales: y } = d.services, E = y.getOrientation(), x = (R) => y.getDomainValue(R), T = (R) => y.getRangeValue(R), [C, _] = xe(
        x,
        T,
        E
      ), V = D(this);
      u === J.TOP || u === J.BOTTOM ? V.selectAll("rect.highlight-bar").transition().call(
        (R) => d.services.transitions.setupTransition({
          transition: R,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("y", Math.max(S + d.highlightStrokeWidth, 0)).attr("height", Math.max(v - 2 * d.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: R, ...A }) => C(A[R])).attr(
        "width",
        ({ highlightStartMapsTo: R, highlightEndMapsTo: A, ...H }) => Math.max(C(H[A]) - C(H[R]), 0)
      ).style("stroke", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", d.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null) : V.selectAll("rect.highlight-bar").transition().call(
        (R) => d.services.transitions.setupTransition({
          transition: R,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("x", m).attr("width", Math.max(g - m, 0)).attr("y", ({ highlightEndMapsTo: R, ...A }) => _(A[R])).attr(
        "height",
        ({ highlightStartMapsTo: R, highlightEndMapsTo: A, ...H }) => Math.max(_(H[R]) - _(H[A]), 0)
      ).style("stroke", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", d.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null);
    });
  }
}
class fm extends $d {
  getItems(t) {
    if (t.detail.items)
      return t.detail.items;
    const { data: e } = t.detail;
    if (!e || !e.length || !e[0])
      return [];
    const n = this.getOptions(), { cartesianScales: s } = this.services, a = s.getDomainIdentifier(), r = s.isDualAxes(), { groupMapsTo: o } = n.data, c = s.getDomainLabel();
    let l = s.getRangeLabel();
    const h = e[0][a];
    let d;
    if (e.length === 1) {
      const u = e[0], p = s.getRangeIdentifier(u);
      if (r) {
        const m = s.getRangeAxisPosition({
          datum: u,
          groups: [u[o]]
        });
        l = s.getScaleLabel(m);
      }
      const f = u[p];
      d = [
        {
          label: c,
          value: h
        },
        ...Array.isArray(f) && f.length === 2 ? [
          {
            label: "Start",
            value: f[0]
          },
          {
            label: "End",
            value: f[1]
          }
        ] : [
          {
            label: l,
            value: u[p]
          }
        ]
      ], t.detail.additionalItems && t.detail.additionalItems.forEach(
        (m) => d.push({
          label: m.label,
          value: m.value
        })
      ), d.push({
        label: Et(n, "locale.translations.group") || Et(n, "tooltip.groupLabel"),
        value: u[o],
        color: this.model.getFillColor(u[o]),
        class: this.model.getColorClassName({
          classNameTypes: [nt.TOOLTIP],
          dataGroupName: u[o]
        })
      });
    } else if (e.length > 1 && (d = [
      {
        label: c,
        value: h
      }
    ], d = d.concat(
      e.map((u) => {
        const p = u[s.getRangeIdentifier(u)];
        return {
          label: u[o],
          value: Array.isArray(p) && p.length === 2 ? `${p[0]} - ${p[1]}` : p,
          color: this.model.getFillColor(u[o]),
          class: this.model.getColorClassName({
            classNameTypes: [nt.TOOLTIP],
            dataGroupName: u[o]
          })
        };
      }).sort((u, p) => p.value - u.value)
    ), !r && O(n, "tooltip", "showTotal") === !0)) {
      const u = s.getRangeIdentifier(), p = O(n, "tooltip", "customTotalCalculation");
      let f;
      p ? f = p(e) : f = e.reduce(
        (m, g) => m + g[u],
        0
      ), d.push({
        label: Et(n, "tooltip.totalLabel") || Et(n, "locale.translations.total") || "Total",
        value: f,
        bold: !0
      });
    }
    return d;
  }
}
function Mr(i, t) {
  let e;
  if (t === void 0)
    for (const n of i)
      n != null && (e < n || e === void 0 && n >= n) && (e = n);
  else {
    let n = -1;
    for (let s of i)
      (s = t(s, ++n, i)) != null && (e < s || e === void 0 && s >= s) && (e = s);
  }
  return e;
}
function Vd(i, t) {
  let e;
  if (t === void 0)
    for (const n of i)
      n != null && (e > n || e === void 0 && n >= n) && (e = n);
  else {
    let n = -1;
    for (let s of i)
      (s = t(s, ++n, i)) != null && (e > s || e === void 0 && s >= s) && (e = s);
  }
  return e;
}
function ci(i, t) {
  let e = 0;
  if (t === void 0)
    for (let n of i)
      (n = +n) && (e += n);
  else {
    let n = -1;
    for (let s of i)
      (s = +t(s, ++n, i)) && (e += s);
  }
  return e;
}
function Gd(i) {
  return i.depth;
}
function Hd(i, t) {
  return t - 1 - i.height;
}
function qo(i, t) {
  return i.sourceLinks.length ? i.depth : t - 1;
}
function es(i) {
  return function() {
    return i;
  };
}
function wr(i, t) {
  return Ts(i.source, t.source) || i.index - t.index;
}
function Cr(i, t) {
  return Ts(i.target, t.target) || i.index - t.index;
}
function Ts(i, t) {
  return i.y0 - t.y0;
}
function ui(i) {
  return i.value;
}
function Bd(i) {
  return i.index;
}
function zd(i) {
  return i.nodes;
}
function Ud(i) {
  return i.links;
}
function kr(i, t) {
  const e = i.get(t);
  if (!e) throw new Error("missing: " + t);
  return e;
}
function _r({ nodes: i }) {
  for (const t of i) {
    let e = t.y0, n = e;
    for (const s of t.sourceLinks)
      s.y0 = e + s.width / 2, e += s.width;
    for (const s of t.targetLinks)
      s.y1 = n + s.width / 2, n += s.width;
  }
}
function Fd() {
  let i = 0, t = 0, e = 1, n = 1, s = 24, a = 8, r, o = Bd, c = qo, l, h, d = zd, u = Ud, p = 6;
  function f() {
    const L = { nodes: d.apply(null, arguments), links: u.apply(null, arguments) };
    return m(L), g(L), v(L), S(L), x(L), _r(L), L;
  }
  f.update = function(L) {
    return _r(L), L;
  }, f.nodeId = function(L) {
    return arguments.length ? (o = typeof L == "function" ? L : es(L), f) : o;
  }, f.nodeAlign = function(L) {
    return arguments.length ? (c = typeof L == "function" ? L : es(L), f) : c;
  }, f.nodeSort = function(L) {
    return arguments.length ? (l = L, f) : l;
  }, f.nodeWidth = function(L) {
    return arguments.length ? (s = +L, f) : s;
  }, f.nodePadding = function(L) {
    return arguments.length ? (a = r = +L, f) : a;
  }, f.nodes = function(L) {
    return arguments.length ? (d = typeof L == "function" ? L : es(L), f) : d;
  }, f.links = function(L) {
    return arguments.length ? (u = typeof L == "function" ? L : es(L), f) : u;
  }, f.linkSort = function(L) {
    return arguments.length ? (h = L, f) : h;
  }, f.size = function(L) {
    return arguments.length ? (i = t = 0, e = +L[0], n = +L[1], f) : [e - i, n - t];
  }, f.extent = function(L) {
    return arguments.length ? (i = +L[0][0], e = +L[1][0], t = +L[0][1], n = +L[1][1], f) : [[i, t], [e, n]];
  }, f.iterations = function(L) {
    return arguments.length ? (p = +L, f) : p;
  };
  function m({ nodes: L, links: P }) {
    for (const [k, G] of L.entries())
      G.index = k, G.sourceLinks = [], G.targetLinks = [];
    const $ = new Map(L.map((k, G) => [o(k, G, L), k]));
    for (const [k, G] of P.entries()) {
      G.index = k;
      let { source: q, target: X } = G;
      typeof q != "object" && (q = G.source = kr($, q)), typeof X != "object" && (X = G.target = kr($, X)), q.sourceLinks.push(G), X.targetLinks.push(G);
    }
    if (h != null)
      for (const { sourceLinks: k, targetLinks: G } of L)
        k.sort(h), G.sort(h);
  }
  function g({ nodes: L }) {
    for (const P of L)
      P.value = P.fixedValue === void 0 ? Math.max(ci(P.sourceLinks, ui), ci(P.targetLinks, ui)) : P.fixedValue;
  }
  function v({ nodes: L }) {
    const P = L.length;
    let $ = new Set(L), k = /* @__PURE__ */ new Set(), G = 0;
    for (; $.size; ) {
      for (const q of $) {
        q.depth = G;
        for (const { target: X } of q.sourceLinks)
          k.add(X);
      }
      if (++G > P) throw new Error("circular link");
      $ = k, k = /* @__PURE__ */ new Set();
    }
  }
  function S({ nodes: L }) {
    const P = L.length;
    let $ = new Set(L), k = /* @__PURE__ */ new Set(), G = 0;
    for (; $.size; ) {
      for (const q of $) {
        q.height = G;
        for (const { source: X } of q.targetLinks)
          k.add(X);
      }
      if (++G > P) throw new Error("circular link");
      $ = k, k = /* @__PURE__ */ new Set();
    }
  }
  function y({ nodes: L }) {
    const P = Mr(L, (G) => G.depth) + 1, $ = (e - i - s) / (P - 1), k = new Array(P);
    for (const G of L) {
      const q = Math.max(0, Math.min(P - 1, Math.floor(c.call(null, G, P))));
      G.layer = q, G.x0 = i + q * $, G.x1 = G.x0 + s, k[q] ? k[q].push(G) : k[q] = [G];
    }
    if (l) for (const G of k)
      G.sort(l);
    return k;
  }
  function E(L) {
    const P = Vd(L, ($) => (n - t - ($.length - 1) * r) / ci($, ui));
    for (const $ of L) {
      let k = t;
      for (const G of $) {
        G.y0 = k, G.y1 = k + G.value * P, k = G.y1 + r;
        for (const q of G.sourceLinks)
          q.width = q.value * P;
      }
      k = (n - k + r) / ($.length + 1);
      for (let G = 0; G < $.length; ++G) {
        const q = $[G];
        q.y0 += k * (G + 1), q.y1 += k * (G + 1);
      }
      H($);
    }
  }
  function x(L) {
    const P = y(L);
    r = Math.min(a, (n - t) / (Mr(P, ($) => $.length) - 1)), E(P);
    for (let $ = 0; $ < p; ++$) {
      const k = Math.pow(0.99, $), G = Math.max(1 - k, ($ + 1) / p);
      C(P, k, G), T(P, k, G);
    }
  }
  function T(L, P, $) {
    for (let k = 1, G = L.length; k < G; ++k) {
      const q = L[k];
      for (const X of q) {
        let F = 0, Z = 0;
        for (const { source: j, value: Y } of X.targetLinks) {
          let K = Y * (X.layer - j.layer);
          F += N(j, X) * K, Z += K;
        }
        if (!(Z > 0)) continue;
        let rt = (F / Z - X.y0) * P;
        X.y0 += rt, X.y1 += rt, A(X);
      }
      l === void 0 && q.sort(Ts), _(q, $);
    }
  }
  function C(L, P, $) {
    for (let k = L.length, G = k - 2; G >= 0; --G) {
      const q = L[G];
      for (const X of q) {
        let F = 0, Z = 0;
        for (const { target: j, value: Y } of X.sourceLinks) {
          let K = Y * (j.layer - X.layer);
          F += M(X, j) * K, Z += K;
        }
        if (!(Z > 0)) continue;
        let rt = (F / Z - X.y0) * P;
        X.y0 += rt, X.y1 += rt, A(X);
      }
      l === void 0 && q.sort(Ts), _(q, $);
    }
  }
  function _(L, P) {
    const $ = L.length >> 1, k = L[$];
    R(L, k.y0 - r, $ - 1, P), V(L, k.y1 + r, $ + 1, P), R(L, n, L.length - 1, P), V(L, t, 0, P);
  }
  function V(L, P, $, k) {
    for (; $ < L.length; ++$) {
      const G = L[$], q = (P - G.y0) * k;
      q > 1e-6 && (G.y0 += q, G.y1 += q), P = G.y1 + r;
    }
  }
  function R(L, P, $, k) {
    for (; $ >= 0; --$) {
      const G = L[$], q = (G.y1 - P) * k;
      q > 1e-6 && (G.y0 -= q, G.y1 -= q), P = G.y0 - r;
    }
  }
  function A({ sourceLinks: L, targetLinks: P }) {
    if (h === void 0) {
      for (const { source: { sourceLinks: $ } } of P)
        $.sort(Cr);
      for (const { target: { targetLinks: $ } } of L)
        $.sort(wr);
    }
  }
  function H(L) {
    if (h === void 0)
      for (const { sourceLinks: P, targetLinks: $ } of L)
        P.sort(Cr), $.sort(wr);
  }
  function N(L, P) {
    let $ = L.y0 - (L.sourceLinks.length - 1) * r / 2;
    for (const { target: k, width: G } of L.sourceLinks) {
      if (k === P) break;
      $ += G + r;
    }
    for (const { source: k, width: G } of P.targetLinks) {
      if (k === L) break;
      $ -= G;
    }
    return $;
  }
  function M(L, P) {
    let $ = P.y0 - (P.targetLinks.length - 1) * r / 2;
    for (const { source: k, width: G } of P.targetLinks) {
      if (k === L) break;
      $ += G + r;
    }
    for (const { target: k, width: G } of L.sourceLinks) {
      if (k === P) break;
      $ -= G;
    }
    return $;
  }
  return f;
}
var Gi = Math.PI, Hi = 2 * Gi, _e = 1e-6, Wd = Hi - _e;
function Bi() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function jo() {
  return new Bi();
}
Bi.prototype = jo.prototype = {
  constructor: Bi,
  moveTo: function(i, t) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(i, t) {
    this._ += "L" + (this._x1 = +i) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(i, t, e, n) {
    this._ += "Q" + +i + "," + +t + "," + (this._x1 = +e) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(i, t, e, n, s, a) {
    this._ += "C" + +i + "," + +t + "," + +e + "," + +n + "," + (this._x1 = +s) + "," + (this._y1 = +a);
  },
  arcTo: function(i, t, e, n, s) {
    i = +i, t = +t, e = +e, n = +n, s = +s;
    var a = this._x1, r = this._y1, o = e - i, c = n - t, l = a - i, h = r - t, d = l * l + h * h;
    if (s < 0) throw new Error("negative radius: " + s);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = i) + "," + (this._y1 = t);
    else if (d > _e) if (!(Math.abs(h * o - c * l) > _e) || !s)
      this._ += "L" + (this._x1 = i) + "," + (this._y1 = t);
    else {
      var u = e - a, p = n - r, f = o * o + c * c, m = u * u + p * p, g = Math.sqrt(f), v = Math.sqrt(d), S = s * Math.tan((Gi - Math.acos((f + d - m) / (2 * g * v))) / 2), y = S / v, E = S / g;
      Math.abs(y - 1) > _e && (this._ += "L" + (i + y * l) + "," + (t + y * h)), this._ += "A" + s + "," + s + ",0,0," + +(h * u > l * p) + "," + (this._x1 = i + E * o) + "," + (this._y1 = t + E * c);
    }
  },
  arc: function(i, t, e, n, s, a) {
    i = +i, t = +t, e = +e, a = !!a;
    var r = e * Math.cos(n), o = e * Math.sin(n), c = i + r, l = t + o, h = 1 ^ a, d = a ? n - s : s - n;
    if (e < 0) throw new Error("negative radius: " + e);
    this._x1 === null ? this._ += "M" + c + "," + l : (Math.abs(this._x1 - c) > _e || Math.abs(this._y1 - l) > _e) && (this._ += "L" + c + "," + l), e && (d < 0 && (d = d % Hi + Hi), d > Wd ? this._ += "A" + e + "," + e + ",0,1," + h + "," + (i - r) + "," + (t - o) + "A" + e + "," + e + ",0,1," + h + "," + (this._x1 = c) + "," + (this._y1 = l) : d > _e && (this._ += "A" + e + "," + e + ",0," + +(d >= Gi) + "," + h + "," + (this._x1 = i + e * Math.cos(s)) + "," + (this._y1 = t + e * Math.sin(s))));
  },
  rect: function(i, t, e, n) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +t) + "h" + +e + "v" + +n + "h" + -e + "Z";
  },
  toString: function() {
    return this._;
  }
};
function Ir(i) {
  return function() {
    return i;
  };
}
function Xd(i) {
  return i[0];
}
function Yd(i) {
  return i[1];
}
var Zd = Array.prototype.slice;
function qd(i) {
  return i.source;
}
function jd(i) {
  return i.target;
}
function Kd(i) {
  var t = qd, e = jd, n = Xd, s = Yd, a = null;
  function r() {
    var o, c = Zd.call(arguments), l = t.apply(this, c), h = e.apply(this, c);
    if (a || (a = o = jo()), i(a, +n.apply(this, (c[0] = l, c)), +s.apply(this, c), +n.apply(this, (c[0] = h, c)), +s.apply(this, c)), o) return a = null, o + "" || null;
  }
  return r.source = function(o) {
    return arguments.length ? (t = o, r) : t;
  }, r.target = function(o) {
    return arguments.length ? (e = o, r) : e;
  }, r.x = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : Ir(+o), r) : n;
  }, r.y = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : Ir(+o), r) : s;
  }, r.context = function(o) {
    return arguments.length ? (a = o ?? null, r) : a;
  }, r;
}
function Jd(i, t, e, n, s) {
  i.moveTo(t, e), i.bezierCurveTo(t = (t + n) / 2, e, t, s, n, s);
}
function Qd() {
  return Kd(Jd);
}
function tp(i) {
  return [i.source.x1, i.y0];
}
function ep(i) {
  return [i.target.x0, i.y1];
}
function np() {
  return Qd().source(tp).target(ep);
}
class gm extends dt {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = at.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ ariaLabel: "alluvial graphs", withinChartClip: !0 });
    e.html("");
    const { width: n, height: s } = I.getSVGElementSize(e, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    const a = this.model.getOptions(), r = this.model.getDisplayData(), o = O(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let c = se.minNodePadding;
    a.alluvial.nodePadding > se.minNodePadding && (c = a.alluvial.nodePadding);
    const l = O(a, "alluvial", "nodeAlignment");
    let h = qo;
    l === te.LEFT ? h = Gd : l === te.RIGHT && (h = Hd);
    const d = Fd().nodeId((y) => y.name).nodeWidth(se.nodeWidth).nodePadding(c).nodeAlign(h).extent([
      [2, 30],
      [n - 2, s]
    ]);
    this.graph = d({
      nodes: a.alluvial.nodes.map((y) => Object.assign({}, y)),
      links: r.map((y) => Object.assign({}, y))
    }), this.graph.nodes = this.graph.nodes.filter((y) => y.value !== 0);
    const u = {};
    this.graph.nodes.forEach((y) => {
      const E = y.x0;
      y.category && (u[E] = y?.category);
    }), e.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(u)).join("g").attr("transform", (y) => `translate(${y}, 0)`).append("text").attr(
      "id",
      (y, E) => this.services.domUtils.generateElementIDString(`alluvial-category-${E}`)
    ).style("font-size", "14px").text((y) => u[y] ? u[y] : "").attr("y", 20).attr("x", (y, E) => {
      const x = this.services.domUtils.generateElementIDString(
        `alluvial-category-${E}`
      ), { width: T } = I.getSVGElementSize(D(`text#${x}`), {
        useBBox: !0
      });
      let C = 0;
      return y + C >= T && (C = -T + 4), C;
    });
    const f = e.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (f.exit().remove(), o) {
      const y = O(this.getOptions(), "color", "scale");
      y && f.enter().append("linearGradient").attr("id", (E) => `${this.gradient_id}-link-${E.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (E) => E.append("stop").attr("offset", "0%").attr("stop-color", (x) => y[x.source.name])
      ).call(
        (E) => E.append("stop").attr("offset", "100%").attr("stop-color", (x) => y[x.target.name])
      ), f.exit().remove();
    }
    f.enter().append("path").classed("link", !0).attr("d", np()).attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-line-${y.index}`)
    ).attr("class", (y) => a.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [nt.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [nt.STROKE],
      dataGroupName: y.source.index,
      originalClassName: "link"
    })).style("stroke", (y) => o ? `url(#${this.gradient_id}-link-${y.index})` : this.model.getFillColor(y.source.name, null, {
      ...y,
      source: y.source.name,
      target: y.target.name
    })).attr("stroke-width", (y) => Math.max(1, y.width)).style("stroke-opacity", se.opacity.default).attr(
      "aria-label",
      (y) => `${y.source.name} → ${y.target.name} (${y.value}${a.alluvial.units ? " " + a.alluvial.units : ""})`
    );
    const m = e.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-${y.index}`)
    ).classed("node-group", !0).attr("transform", (y) => `translate(${y.x0}, ${y.y0})`);
    m.append("rect").classed("node", !0).attr("height", (y) => y.y1 - y.y0).attr("width", (y) => y.x1 - y.x0).attr("fill", "black");
    const g = m.append("g").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${y.index}`)
    ), { code: v, number: S } = O(a, "locale");
    g.append("text").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${y.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((y) => `${y.name} (${S(y.value, v)})`).attr("aria-label", (y) => `${y.name} (${y.value})`), g.append("rect").classed("node-text-bg", !0).attr("width", (y, E) => {
      const x = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${E}`
      ), { width: T } = I.getSVGElementSize(D(`text#${x}`), {
        useBBox: !0
      });
      return T + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), g.attr("transform", (y, E) => {
      const x = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${E}`
      ), { width: T } = I.getSVGElementSize(D(`text#${x}`), {
        useBBox: !0
      }), C = (y.y1 - y.y0) / 2 - 9;
      let _ = y.x1 - y.x0;
      return y.x1 >= T ? _ = _ - (T + 16) : _ += 4, `translate(${_}, ${C})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const t = this.getOptions(), e = this, { number: n, code: s } = O(this.getOptions(), "locale"), a = gi((r, o = "mouseover") => {
      const c = e.parent.selectAll("path.link").transition().call(
        (l) => e.services.transitions.setupTransition({
          transition: l,
          name: "alluvial-links-mouse-highlight"
        })
      );
      o === "mouseout" ? (D(r).lower(), c.style("stroke-opacity", se.opacity.default)) : c.style("stroke-opacity", function() {
        return r === this ? (D(this).raise(), se.opacity.selected) : se.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(r, o) {
      const c = D(this);
      a(this, "mouseover"), c.classed("link-hovered", !0);
      const l = getComputedStyle(this).getPropertyValue("stroke");
      e.services.events.dispatchEvent(b.Alluvial.LINE_MOUSEOVER, {
        event: r,
        element: c,
        datum: o
      }), e.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: r,
        hoveredElement: c,
        items: [
          {
            label: o.target.name,
            value: (n(o.value, s) ? `${n(o.value, s)}` : "-") + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),
            color: l,
            labelIcon: e.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(r, o) {
      e.services.events.dispatchEvent(b.Alluvial.LINE_MOUSEMOVE, {
        event: r,
        element: D(this),
        datum: o
      }), e.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, o) {
      e.services.events.dispatchEvent(b.Alluvial.LINE_CLICK, {
        event: r,
        element: D(this),
        datum: o
      });
    }).on("mouseout", function(r, o) {
      const c = D(this);
      a(this, "mouseout"), c.classed("link-hovered", !1), e.services.events.dispatchEvent(b.Alluvial.LINE_MOUSEOUT, {
        event: r,
        element: c,
        datum: o
      }), e.services.events.dispatchEvent(b.Tooltip.HIDE, {
        event: r,
        hoveredElement: c
      });
    });
  }
  addNodeEventListener() {
    const t = this, e = gi((n = [], s = "mouseover") => {
      if (s === "mouseout" || n.length === 0) {
        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (r) => r.index).order().style("stroke-opacity", se.opacity.default);
        return;
      }
      t.parent.selectAll("path.link").transition().call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(r) {
        return n.some((o) => o === r.index) ? (D(this).classed("link-hovered", !0).raise(), se.opacity.selected) : se.opacity.unfocus;
      });
    }, 66);
    t.parent.selectAll(".node-group").on("mouseover", function(n, s) {
      const a = D(this), r = [];
      if (t.traverse({ link: "sourceLinks", node: "target" }, s, r), t.traverse({ link: "targetLinks", node: "source" }, s, r), r.length) {
        const o = yn(a.attr("transform"));
        if (a.attr("transform", `translate(${o.x - 2}, ${o.y})`), a.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), s.x0 - 2 === 0) {
          const l = t.services.domUtils.generateElementIDString(
            `alluvial-node-title-${s.index}`
          ), h = t.parent.select(`g#${l}`), d = yn(h.attr("transform"));
          h.attr("transform", `translate(${d.x + 4},${d.y})`);
        }
        const c = t.services.domUtils.generateElementIDString(
          `alluvial-node-text-${s.index}`
        );
        t.parent.select(`text#${c}`).style("font-weight", "bold"), e(r, "mouseover"), t.services.events.dispatchEvent(b.Alluvial.NODE_MOUSEOVER, {
          event: n,
          element: a,
          datum: s
        });
      }
    }).on("mousemove", function(n, s) {
      t.services.events.dispatchEvent(b.Alluvial.NODE_MOUSEMOVE, {
        event: n,
        element: D(this),
        datum: s
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      t.services.events.dispatchEvent(b.Alluvial.NODE_CLICK, {
        event: n,
        element: D(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      const a = D(this), r = yn(a.attr("transform"));
      if (a.classed("node-hovered", !1).attr("transform", `translate(${r.x + 2}, ${r.y})`).select("rect.node").attr("width", se.nodeWidth), s.x0 - 2 === 0) {
        const c = t.services.domUtils.generateElementIDString(
          `alluvial-node-title-${s.index}`
        ), l = t.parent.select(`g#${c}`), h = yn(l.attr("transform"));
        l.attr("transform", `translate(${h.x - 4},${h.y})`);
      }
      const o = t.services.domUtils.generateElementIDString(
        `alluvial-node-text-${s.index}`
      );
      t.parent.select(`text#${o}`).style("font-weight", "normal"), e([], "mouseout"), t.services.events.dispatchEvent(b.Alluvial.NODE_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(t, e, n = []) {
    e[t.link].map((a) => (n.push(a.index), a[t.node])).forEach((a) => this.traverse(t, a, n));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class mm extends dt {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = at.SVG;
  }
  render(t = !0) {
    const e = O(this.getOptions(), "grid", "x", "enabled"), n = O(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(e, n), !(!e && !n) && (e && (I.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), n && (I.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));
  }
  drawXGrid(t) {
    const e = this.parent, n = this.backdrop.attr("height"), s = this.services.cartesianScales.getMainXScale(), a = Fi(s).tickSizeInner(-n).tickSizeOuter(0);
    if (O(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const c = this.services.cartesianScales.getDomainAxisPosition(), l = O(this.getOptions(), "axes", c, "ticks", "values");
      l && a.tickValues(l);
    } else {
      const c = O(this.getOptions(), "grid", "x", "numberOfTicks");
      a.ticks(c);
    }
    const o = e.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${n})`);
    t ? o.transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "grid-update",
        animate: t
      })
    ).call(a) : o.call(a), this.cleanGrid(o);
  }
  drawYGrid(t) {
    const e = this.parent, n = this.backdrop.attr("width"), s = this.services.cartesianScales.getMainYScale(), a = po(s).tickSizeInner(-n).tickSizeOuter(0);
    if (O(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const c = this.services.cartesianScales.getRangeAxisPosition(), l = O(this.getOptions(), "axes", c, "ticks", "values");
      l && a.tickValues(l);
    } else {
      const c = O(this.getOptions(), "grid", "y", "numberOfTicks");
      a.ticks(c);
    }
    const o = e.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    t ? o.transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "grid-update",
        animate: t
      })
    ).call(a) : o.call(a), this.cleanGrid(o);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(t) {
    const e = this.parent, n = e.selectAll(".x.grid .tick").nodes().sort((h, d) => Number(ge(h).tx) - Number(ge(d).tx));
    let s = -1;
    if (!n.length)
      return;
    n.forEach((h) => {
      t[0] >= +ge(h).tx && s++;
    });
    const a = s + 1 < n.length ? s + 1 : n.length, r = n[s], o = n[a];
    let c;
    if (!r)
      c = +ge(o).tx;
    else if (o)
      c = +ge(o).tx - +ge(r).tx;
    else {
      const h = e.select("rect.chart-grid-backdrop").node();
      c = I.getSVGElementSize(h).width - +ge(r).tx;
    }
    const { threshold: l } = this.getOptions().tooltip.gridline;
    return c * l;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(t) {
    const e = O(this.getOptions, "tooltip", "gridline", "threshold"), n = e || this.getGridlineThreshold(t);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const r = ge(this), o = {
        min: Number(r.tx) - n,
        max: Number(r.tx) + n
      };
      return o.min <= t[0] && t[0] <= o.max;
    });
  }
  drawBackdrop(t, e) {
    const n = this.parent, s = this.services.cartesianScales.getMainXScale(), a = this.services.cartesianScales.getMainYScale(), [r, o] = s.range(), [c, l] = a.range();
    this.backdrop = I.appendOrSelect(n, "svg.chart-grid-backdrop").attr(
      "role",
      "presentation"
    );
    const h = I.appendOrSelect(
      this.backdrop,
      t || e ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(h).attr("x", r).attr("y", l).attr("width", Math.abs(o - r)).attr("height", Math.abs(c - l)).lower(), h.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(t) {
    t.selectAll("text").remove(), t.select(".domain").remove();
  }
}
class vm extends dt {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = at.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-area"
        })
      ).attr("opacity", (n) => n.name !== e.datum().name ? ye.opacity.unselected : ye.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", ye.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({ ariaLabel: "area graphs", withinChartClip: !0 }), n = this.getOptions();
    let s = [0, 0];
    const { cartesianScales: a } = this.services, r = a.getOrientation(), o = Ki().curve(this.services.curves.getD3Curve()).defined((x) => {
      const T = a.getRangeIdentifier(), C = x[T];
      return C != null;
    }), c = this.model.getGroupedData(this.configs.groups), l = O(n, "bounds"), h = l && c && c.length === 1;
    !h && l && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${c.length}`
    );
    let d = 0;
    const u = (x, T) => {
      O(n, "axes", x, "includeZero") === !1 && T[0] > 0 && T[1] > 0 && (d = T[0]);
    }, p = (x) => h ? a.getBoundedScaledValues(x)[0] : a.getRangeValue(d), f = (x) => h ? a.getBoundedScaledValues(x)[1] : a.getRangeValue(x);
    r === Xt.VERTICAL ? (s = a.getMainYScale().domain(), u(a.getMainYAxisPosition(), s), o.x((x) => a.getDomainValue(x)).y0((x) => p(x)).y1((x) => f(x))) : (s = a.getMainXScale().domain(), u(a.getMainXAxisPosition(), s), o.x0((x) => p(x)).x1((x) => f(x)).y((x) => a.getDomainValue(x)));
    const m = O(n, "color", "gradient", "enabled"), g = c && c.length === 1 && m;
    c.length > 1 && m && console.error("Gradients can only be enabled when having 1 single dataset");
    const v = e.selectAll("path.area").data(c, (x) => x.name), S = D(this.services.domUtils.getMainContainer());
    if (v.exit().attr("opacity", 0).remove(), !c.length)
      return;
    if (g) {
      const x = S.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [nt.STROKE],
          dataGroupName: c[0].name
        })}`
      ).node();
      let T;
      if (x)
        T = getComputedStyle(x, null).getPropertyValue(
          "stroke"
        );
      else {
        const C = O(this.model.getOptions(), "color", "scale");
        if (C !== null) {
          const _ = Object.keys(C);
          T = C[_[0]];
        }
      }
      Ca.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${c[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: Ca.getStops(s, T)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const y = this, E = v.enter().append("path");
    g ? E.merge(v).style(
      "fill",
      (x) => `url(#${this.services.domUtils.generateElementIDString(
        `${x.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: x.name,
        originalClassName: "area"
      })
    ).attr("d", (x) => {
      const { data: T } = x;
      return o(T);
    }) : (E.attr("opacity", 0).merge(v).attr("class", "area").attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        dataGroupName: x.name,
        originalClassName: "area"
      })
    ).style("fill", (x) => y.model.getFillColor(x.name, null, x.data)).transition().call(
      (x) => this.services.transitions.setupTransition({
        transition: x,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", h ? 1 : ye.opacity.selected).attr("d", (x) => {
      const { data: T } = x;
      return o(T);
    }), h && E.attr("fill-opacity", ye.opacity.selected).style("stroke", (x) => y.model.getStrokeColor(x.name, null, x.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class ym extends dt {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-line"
        })
      ).attr("opacity", (n) => n.name !== e.datum().name ? ve.opacity.unselected : ve.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ve.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = navigator.userAgent.toLowerCase().indexOf("firefox") > -1, n = this.model.get("zoomDomain") !== void 0, s = e && n ? this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !1 }) : this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), { cartesianScales: a, curves: r } = this.services, o = (v) => a.getDomainValue(v), c = (v) => a.getRangeValue(v), [l, h] = xe(
      o,
      c,
      a.getOrientation()
    ), d = this.getOptions(), u = Pn().x(l).y(h).curve(r.getD3Curve()).defined((v) => {
      const S = a.getRangeIdentifier(v), y = v[S];
      return y != null;
    });
    let p = [];
    if (this.configs.stacked) {
      const v = Object.keys(d.axes).some((E) => d.axes[E].percentage), { groupMapsTo: S } = d.data;
      p = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: v
      }).map((E) => {
        const x = this.services.cartesianScales.getDomainIdentifier(E), T = this.services.cartesianScales.getRangeIdentifier(E);
        return {
          name: O(E, 0, S),
          data: E.map((C) => ({
            [x]: C.data.sharedStackKey,
            [S]: C[S],
            [T]: C[1]
          })),
          hidden: !kc(E, (C) => C[0] !== C[1])
        };
      });
    } else
      p = this.model.getGroupedData(this.configs.groups);
    const f = s.selectAll("path.line").data(p, (v) => v.name);
    f.exit().attr("opacity", 0).remove();
    const g = f.enter().append("path").classed("line", !0).attr("opacity", 0).merge(f).data(p, (v) => v.name).attr(
      "class",
      (v) => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        dataGroupName: v.name,
        originalClassName: "line"
      })
    ).style("stroke", (v) => this.model.getStrokeColor(v.name, null, v.data)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (v) => {
      const { data: S } = v;
      return S.map((y) => {
        const E = this.services.cartesianScales.getRangeIdentifier(y);
        return y[E];
      }).join(",");
    });
    if (e && n) {
      const v = a.getMainXScale(), S = a.getMainYScale();
      if (v && S) {
        const [y, E] = v.range(), [x, T] = S.range();
        s.style("overflow", "hidden").style("clip", `rect(${T}px, ${E}px, ${x}px, ${y}px)`);
      }
    }
    g.transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "line-update-enter",
        animate: t
      })
    ).attr("opacity", (v) => v.hidden ? 0 : 1).attr("d", (v) => {
      const { data: S } = v;
      return u(S);
    });
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const Rr = 5;
function sp(i, t) {
  return i > t - Rr && i < t + Rr;
}
class Ko extends dt {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = at.SVG, this.isXGridEnabled = O(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = O(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = O(this.getOptions(), "ruler", "enabled"), n = O(this.getOptions(), "tooltip", "alwaysShowRulerTooltip"), s = e || n;
    this.drawBackdrop(), s && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !s && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(t) {
    return t;
  }
  showRuler(t, [e, n]) {
    const s = this.parent, a = this.services.cartesianScales.getOrientation(), r = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [c, l] = o.range(), h = a === Xt.HORIZONTAL ? n : e, d = I.appendOrSelect(s, "g.ruler").attr("aria-label", "ruler"), u = I.appendOrSelect(d, "line.ruler-line"), p = s.selectAll("[role=graphics-symbol]"), f = r.map((g) => ({
      domainValue: this.services.cartesianScales.getDomainValue(g),
      originalData: g
    })).filter((g) => sp(g.domainValue, h));
    if (this.pointsWithinLine && f.length === this.pointsWithinLine.length && f.map((g) => g.domainValue).join() === this.pointsWithinLine.map((g) => g.domainValue).join())
      return this.pointsWithinLine = f, this.services.events.dispatchEvent(b.Tooltip.MOVE, {
        mousePosition: [e, n]
      });
    this.pointsWithinLine = f;
    const m = this.pointsWithinLine.reduce((g, v) => {
      if (g.length === 0)
        return g.push(v), g;
      const S = g[0].domainValue, y = Math.abs(h - v.domainValue), E = Math.abs(h - S);
      return y > E || (y < E ? g = [v] : g.push(v)), g;
    }, []);
    if (m.length > 0) {
      const g = m.map((E) => E.originalData).filter((E) => {
        const x = this.services.cartesianScales.getRangeIdentifier(E), T = E[x];
        return T != null;
      }), v = m.map(
        (E) => E.domainValue
      ), S = p.filter((E) => {
        const x = this.services.cartesianScales.getDomainValue(E);
        return v.includes(x);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !uo(this.elementsToHighlight, S) && this.hideRuler(), S.dispatch("mouseover"), this.elementsToHighlight = S, this.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: t,
        mousePosition: [e, n],
        hoveredElement: u,
        data: this.formatTooltipData(g)
      }), d.attr("opacity", 1);
      const y = m[0];
      a === "horizontal" ? u.attr("x1", l).attr("x2", c).attr("y1", y.domainValue).attr("y2", y.domainValue) : u.attr("y1", l).attr("y2", c).attr("x1", y.domainValue).attr("x2", y.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const t = this.parent, e = I.appendOrSelect(t, "g.ruler");
    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(b.Tooltip.HIDE), e.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const t = this, e = this.services.domUtils.getHolder(), n = this.model.getDisplayData();
    let s = function(a) {
      const r = an(a, t.parent.node());
      t.showRuler(a, r);
    };
    if (n.length > 100) {
      const a = n.length % 50 * 12.5;
      s = gl(
        function(r) {
          const { mousePosition: o } = this;
          t.showRuler(r, o);
        },
        a,
        e
      );
    }
    this.backdrop.on("mousemove mouseover", s).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const t = this.parent;
    this.backdrop = I.appendOrSelect(t, "svg.chart-grid-backdrop");
  }
}
class Qi extends dt {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = at.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (t) => this.services.transitions?.setupTransition({
          transition: t,
          name: "chart-holder-hover-scatter"
        })
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (t) => this.services.transitions?.setupTransition({
          transition: t,
          name: "chart-holder-mouseout-scatter"
        })
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (s) => this.services.transitions?.setupTransition({
          transition: s,
          name: "legend-hover-scatter"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (t) => this.services.transitions?.setupTransition({
          transition: t,
          name: "legend-mouseout-scatter"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    if (!t) throw new Error("Services events are undefined.");
    t.addEventListener(
      b.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: e } = this.configs;
    e && (t.addEventListener(b.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(b.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(t) {
    const { cartesianScales: e } = this.services;
    if (!e) throw new Error("Services cartesianScales are undefined.");
    const n = e.getDomainIdentifier(t), s = this.model.get("zoomDomain");
    return s !== void 0 ? t.filter(
      (a) => a[n].getTime() >= s[0].getTime() && a[n].getTime() <= s[1].getTime()
    ) : t;
  }
  getScatterData() {
    const t = this.getOptions(), { stacked: e } = this.configs;
    let n;
    if (e) {
      const s = Object.keys(t.axes).some((a) => t.axes[a].percentage);
      n = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: s
      });
    } else {
      const { cartesianScales: s } = this.services;
      if (!s) throw new Error("Services cartesianScales are undefined.");
      n = this.model.getDisplayData(this.configs.groups).filter((a) => {
        const r = s.getRangeIdentifier(a);
        return a[r] !== void 0 && a[r] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(n);
  }
  render(t) {
    if (!(O(this.getOptions(), "points", "enabled") || O(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.services.zoom?.isZoomBarEnabled() || !1, s = this.getComponentContainer({
      ariaLabel: "scatter points",
      withinChartClip: n
    }), a = this.getOptions(), { groupMapsTo: r } = a.data, { cartesianScales: o } = this.services;
    if (!o) throw new Error("Services cartesianScales are undefined.");
    const c = o.getDomainIdentifier(), l = s.selectAll("circle.dot").data(
      this.getScatterData(),
      (u) => `${u[r]}-${u[c]}`
    );
    l.exit().attr("opacity", 0).remove();
    const d = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l);
    this.styleCircles(d, t), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(t) {
    const { handleThresholds: e } = this.configs;
    if (!e)
      return !1;
    const { cartesianScales: n } = this.services;
    if (!n) throw new Error("Cartesian scales service is undefined");
    const s = n.getOrientation(), [a, r] = xe(
      n.getHighestDomainThreshold(),
      n.getHighestRangeThreshold(),
      s
    ), [o, c] = xe(
      (d) => n.getDomainValue(d),
      (d) => n.getRangeValue(d),
      s
    ), l = o(t), h = c(t);
    return r && a ? h <= r.scaleValue && l >= a.scaleValue : r ? h <= r.scaleValue : a ? l >= a.scaleValue : !1;
  }
  styleCircles(t, e) {
    const n = this.getOptions(), { filled: s, fillOpacity: a } = n.points, { cartesianScales: r } = this.services;
    if (!r) throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: o } = n.data, c = (p) => r.getDomainValue(p), l = (p) => r.getRangeValue(p), [h, d] = xe(
      c,
      l,
      r.getOrientation()
    ), { fadeInOnChartHolderMouseover: u } = this.configs;
    t.raise().classed("dot", !0).attr("class", (p) => {
      const f = r.getDomainIdentifier(p), g = this.model.getIsFilled(p[o], p[f], p, s) ? [nt.FILL, nt.STROKE] : [nt.STROKE];
      return this.model.getColorClassName({
        classNameTypes: g,
        dataGroupName: p[o],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (p) => this.isDatapointThresholdAnomaly(p)).classed("filled", (p) => {
      const f = r.getDomainIdentifier(p);
      return this.model.getIsFilled(p[o], p[f], p, s);
    }).classed("unfilled", (p) => {
      const f = r.getDomainIdentifier(p);
      return !this.model.getIsFilled(p[o], p[f], p, s);
    }).transition().call(
      (p) => this.services.transitions?.setupTransition({
        transition: p,
        name: "scatter-update-enter",
        animate: e
      })
    ).attr("cx", h).attr("cy", d).attr("r", n.points.radius).style("fill", (p) => {
      const f = r.getDomainIdentifier(p);
      if (this.model.getIsFilled(p[o], p[f], p, s))
        return this.model.getFillColor(p[o], p[f], p);
    }).style("stroke", (p) => {
      const f = r.getDomainIdentifier(p);
      return this.model.getStrokeColor(p[o], p[f], p);
    }).attr("fill-opacity", s ? a : 1).attr("opacity", u ? 0 : 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (p) => {
      const f = r.getRangeIdentifier(p);
      return p[f];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(t) {
    return null;
  }
  addEventListeners() {
    const t = this, { groupMapsTo: e } = t.getOptions().data, n = O(
      this.getOptions(),
      "tooltip",
      "alwaysShowRulerTooltip"
    );
    if (!this.parent) throw new Error("Parent not defined");
    const s = this.parent.selectAll("circle");
    n ? s.style("pointer-events", "none") : s.style("pointer-events", null), s.on("mouseover", function(a, r) {
      const o = D(this);
      o.classed("hovered", !0).attr(
        "class",
        (c) => t.model.getColorClassName({
          classNameTypes: [nt.FILL],
          dataGroupName: c[e],
          originalClassName: o.attr("class")
        })
      ).style("fill", (c) => {
        const l = t.services.cartesianScales?.getDomainIdentifier(c);
        return t.model.getFillColor(c[e], c[l], c);
      }).classed("unfilled", !1), n || t.services.events?.dispatchEvent(b.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        data: [r],
        additionalItems: t.getTooltipAdditionalItems(r)
      }), t.services.events?.dispatchEvent(b.Scatter.SCATTER_MOUSEOVER, {
        event: a,
        element: o,
        datum: r
      });
    }).on("mousemove", function(a, r) {
      const o = D(this);
      t.services.events?.dispatchEvent(b.Scatter.SCATTER_MOUSEMOVE, {
        event: a,
        element: o,
        datum: r
      }), t.services.events?.dispatchEvent(b.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      t.services.events?.dispatchEvent(b.Scatter.SCATTER_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      if (o.classed("hovered", !1), !t.configs.filled) {
        const { filled: c } = t.getOptions().points, l = t.services.cartesianScales?.getDomainIdentifier(r), h = t.model.getIsFilled(
          r[e],
          r[l],
          r,
          c
        );
        o.classed("unfilled", !h).style("fill", (d) => h || c ? t.model.getFillColor(d[e], d[l], d) : null);
      }
      t.services.events?.dispatchEvent(b.Scatter.SCATTER_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), t.services.events?.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
  destroy() {
    this.parent?.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: t } = this.services;
    if (!t) throw new Error("Services events undefined");
    t.removeEventListener(
      b.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(b.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.removeEventListener(b.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class Jo extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "axes", this.renderType = at.SVG, this.truncation = {
      [J.LEFT]: !1,
      [J.RIGHT]: !1,
      [J.TOP]: !1,
      [J.BOTTOM]: !1
    }, n && (this.configs = n), this.margins = this.configs.margins;
  }
  render(t = !0) {
    const { position: e } = this.configs, n = this.getOptions(), s = O(n, "axes", e, "visible"), a = this.getComponentContainer({
      ariaLabel: "axes"
    }), { width: r, height: o } = I.getSVGElementSize(a, {
      useAttrs: !0
    }), c = I.appendOrSelect(a, `g.axis.${e}`);
    let l, h;
    if (e === J.BOTTOM || e === J.TOP ? (l = this.configs.axes[J.LEFT] ? this.margins.left : 0, h = this.configs.axes[J.RIGHT] ? r - this.margins.right : r) : (l = o - this.margins.bottom, h = this.margins.top), !this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const d = this.services.cartesianScales.getScaleByPosition(e);
    this.scaleType === kt.LABELS || this.scaleType === kt.LABELS_RATIO ? d.rangeRound([l, h]) : d.range([l, h]);
    let u;
    switch (e) {
      case J.LEFT:
        u = po;
        break;
      case J.BOTTOM:
        u = Fi;
        break;
      case J.RIGHT:
        u = Gc;
        break;
      case J.TOP:
        u = Vc;
        break;
    }
    c.attr("aria-label", `${e} axis`);
    const p = !c.select("g.ticks").empty();
    let f = I.appendOrSelect(c, "g.ticks");
    p || (f.attr("role", `${lt.GRAPHICS_OBJECT} ${lt.GROUP}`), f.attr("aria-label", `${e} ticks`));
    const m = I.appendOrSelect(c, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${e} ticks`), g = O(n, "axes", e), v = this.scaleType === kt.TIME || g.scaleType === kt.TIME, S = e === J.LEFT || e === J.RIGHT, y = this.model.get("zoomDomain");
    if (y && v && !S && d.domain(y), !s) {
      f.attr("aria-hidden", !0);
      return;
    }
    const E = O(g, "scaleType"), x = O(n, "data", "loading"), T = O(g, "ticks", "number"), C = O(g, "ticks", "values"), _ = O(g, "truncation", "type"), V = O(g, "truncation", "threshold"), R = O(g, "truncation", "numCharacter"), A = T !== null, H = O(n, "timeScale"), N = I.appendOrSelect(m, "g.tick"), M = I.appendOrSelect(N, "text").text("0"), L = I.getSVGElementSize(M.node(), {
      useBBox: !0
    }).height;
    N.remove();
    const P = this.scaleType || g.scaleType || kt.LINEAR, $ = u(d).tickSizeOuter(0);
    if (d.ticks) {
      let Y;
      if (A ? Y = T : (Y = Je.ticks.number, S && (Y = this.getNumberOfFittingTicks(
        o,
        L,
        Je.ticks.verticalSpaceRatio
      ))), d.ticks().length === 1 && d.ticks()[0] === 0 && (Y = 0), $.ticks(Y), v)
        if (!d.ticks(Y).length)
          $.tickValues([]);
        else {
          const K = O(n, "timeScale", "addSpaceOnEdges"), ot = O(n, "axes", e, "domain"), ct = d.copy();
          K && !ot && ct.nice(Y);
          const st = ct.ticks(Y);
          K && st.length > 2 && !ot && (st.splice(st.length - 1, 1), st.splice(0, 1)), $.tickValues(st);
        }
    }
    let k;
    const G = O(g, "ticks", "formatter"), { code: q, number: X } = O(n, "locale");
    if (v) {
      const Y = di(
        $.tickValues(),
        O(n, "timeScale", "timeInterval")
      );
      G === null ? k = (K, ot) => pi(K, ot, $.tickValues(), Y, H, n.locale) : k = (K, ot) => {
        const ct = pi(
          K,
          ot,
          $.tickValues(),
          Y,
          H,
          n.locale
        );
        return G(K, ot, ct);
      };
    } else
      G === null ? P === kt.LINEAR && (k = (Y) => X(Y, q)) : k = G;
    $.tickFormat(k);
    const [F, Z] = this.services.cartesianScales.getScaleByPosition(e).domain();
    let rt;
    if (C) {
      if (v)
        C.forEach((Y, K) => {
          Y.getTime === void 0 && (C[K] = new Date(Y));
        }), rt = C.filter((Y) => {
          const K = Y.getTime();
          return K >= new Date(F).getTime() && K <= new Date(Z).getTime();
        });
      else if (E === kt.LABELS) {
        const Y = this.services.cartesianScales.getScaleByPosition(e).domain();
        rt = C.filter((K) => Y.includes(K));
      } else
        rt = C.filter(
          (Y) => Y >= F && Y <= Z
        );
      $.tickValues(rt);
    }
    switch (e) {
      case J.LEFT:
        f.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case J.BOTTOM:
        f.attr("transform", `translate(0, ${o - this.margins.bottom})`);
        break;
      case J.RIGHT:
        f.attr("transform", `translate(${r - this.margins.right}, 0)`);
        break;
      case J.TOP:
        f.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const j = this.model.isDataEmpty();
    if (g.title) {
      const Y = I.appendOrSelect(c, "text.axis-title").html(
        j || x ? "" : ue(g.title)
      ), K = O(g, "titleOrientation");
      let ot;
      switch (e) {
        case J.LEFT:
          K === ba.RIGHT ? Y.attr("transform", "rotate(90)").attr("y", 0).attr("x", d.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : Y.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(d.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case J.BOTTOM:
          const ct = o - Xr;
          Y.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${ct})`
          );
          break;
        case J.RIGHT:
          K === ba.LEFT ? Y.attr("transform", "rotate(-90)").attr("y", r).attr("x", -(d.range()[0] / 2)).style("text-anchor", "middle") : Y.attr("transform", "rotate(90)").attr("y", -r).attr("x", d.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case J.TOP:
          ot = I.getSVGElementSize(Y, {
            useBBox: !0
          }).height, Y.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${ot / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (v) {
      const Y = di(
        $.tickValues(),
        O(n, "timeScale", "timeInterval")
      ), K = H.showDayName, ot = f;
      t && (f = f.transition().call(
        (st) => this.services.transitions.setupTransition({
          transition: st,
          name: "axis-update",
          animate: t
        })
      )), f = f.call($), ot.selectAll(".tick").data($.tickValues(), d).order().select("text").attr(
        "class",
        (st, it) => ml(st, it, $.tickValues(), Y, K) ? "tick-label--primary" : "tick-label"
      );
    } else
      !t || !p ? f = f.call($) : f = f.transition().call(
        (Y) => this.services.transitions.setupTransition({
          transition: Y,
          name: "axis-update",
          animate: t
        })
      ).call($);
    if (m.call($), e === J.BOTTOM || e === J.TOP) {
      let Y = !1;
      const K = O(g, "ticks", "rotation");
      if (K === Vs.ALWAYS)
        Y = !0;
      else if (K === Vs.NEVER)
        Y = !1;
      else if (!K || K === Vs.AUTO)
        if (d.step)
          Y = m.selectAll("g.tick text").nodes().some(
            (ct) => I.getSVGElementSize(ct, {
              useBBox: !0
            }).width >= d.step()
          );
        else {
          Y = !1;
          const ot = m.append("text").text("A"), ct = I.getSVGElementSize(ot.node(), {
            useBBox: !0
          }).width;
          let st;
          m.selectAll("g.tick").each(function() {
            const it = D(this), z = parseFloat(O(ge(this), "tx"));
            z !== null && st + it.text().length * ct * 0.8 >= z && (Y = !0), st = z;
          }), ot.remove();
        }
      Y ? (A || ($.ticks(
        this.getNumberOfFittingTicks(r, L, Je.ticks.horizontalSpaceRatio)
      ), m.call($), f.call($)), c.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", e === J.TOP ? "start" : "end")) : c.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (x ? c.attr("opacity", 0) : c.attr("opacity", 1), f.selectAll("g.tick").attr("aria-label", (Y) => Y), m.selectAll("g.tick").attr("aria-label", (Y) => Y), _ !== Qe.NONE && E === kt.LABELS && !C) {
      const Y = this.services.cartesianScales.getScaleDomain(e);
      if (Y.length > 0) {
        const K = a.select(`g.axis.${e} g.ticks g.tick`).html();
        c.selectAll("g.ticks g.tick").html(K);
        const ot = this;
        c.selectAll("g.tick text").data(Y).text(function(ct) {
          return ct.length > V ? (ot.truncation[e] = !0, kn(ct, _, R)) : ct;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(Y).text(function(ct) {
          return ct.length > V ? kn(ct, _, R) : ct;
        }), c.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), c.selectAll("g.tick text").data(Y);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: e } = this.configs, n = I.appendOrSelect(t, `g.axis.${e}`), s = this.getOptions(), a = O(s, "axes", e), r = O(a, "scaleType"), o = O(a, "truncation", "threshold"), c = this;
    n.selectAll("g.tick text").on("mouseover", function(l, h) {
      c.services.events.dispatchEvent(b.Axis.LABEL_MOUSEOVER, {
        event: l,
        element: D(this),
        datum: h
      }), r === kt.LABELS && h.length > o && c.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: l,
        hoveredElement: D(this),
        content: h
      });
    }).on("mousemove", function(l, h) {
      c.services.events.dispatchEvent(b.Axis.LABEL_MOUSEMOVE, {
        event: l,
        element: D(this),
        datum: h
      }), r === kt.LABELS && h.length > o && c.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l, h) {
      c.services.events.dispatchEvent(b.Axis.LABEL_CLICK, {
        event: l,
        element: D(this),
        datum: h
      });
    }).on("mouseout", function(l, h) {
      c.services.events.dispatchEvent(b.Axis.LABEL_MOUSEOUT, {
        event: l,
        element: D(this),
        datum: h
      }), r === kt.LABELS && c.services.events.dispatchEvent(b.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);
  }
  getNumberOfFittingTicks(t, e, n) {
    const s = Math.floor(t / (e * n));
    return co(s, 2, Je.ticks.number);
  }
  destroy() {
    const t = this.getComponentContainer(), { position: e } = this.configs;
    I.appendOrSelect(t, `g.axis.${e}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class ip extends Jo {
  constructor(t, e, n) {
    super(t, e, n);
  }
  render(t = !0) {
    super.render(t), super.destroy();
    const e = this.configs.position, n = this.getComponentContainer({
      ariaLabel: "axes"
    }), s = I.appendOrSelect(n, `g.axis.${e}`), a = this;
    s.selectAll("g.tick").each(function(r, o) {
      const c = D(this);
      c.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);
      const l = c.select("text"), { width: h, height: d } = I.getSVGElementSize(l, {
        useBBox: !0
      }), u = I.appendOrSelect(c, "rect.axis-holder");
      let p = 0, f = 0;
      switch (e) {
        case J.LEFT:
          p = -h + Number(l.attr("x")), f = -(d / 2);
          break;
        case J.RIGHT:
          p = Math.abs(Number(l.attr("x"))), f = -(d / 2);
          break;
        case J.TOP:
          p = -(h / 2), f = -d + Number(l.attr("y")) / 2, a.truncation[e] && (p = 0, u.attr("transform", "rotate(-45)"));
          break;
        case J.BOTTOM:
          p = -(h / 2), f = d / 2 - 2, a.truncation[e] && (p = -h, u.attr("transform", "rotate(-45)"));
          break;
      }
      u.attr("x", p - Je.hover.rectanglePadding).attr("y", f).attr("width", h + Je.hover.rectanglePadding * 2).attr("height", d).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: e } = this.configs, n = I.appendOrSelect(t, `g.axis.${e}`), s = this.getOptions(), a = O(s, "axes", e), r = O(a, "scaleType"), o = O(a, "truncation", "threshold"), c = this;
    n.selectAll("g.tick.tick-hover").on("mouseover", function(l) {
      const h = D(this).select("text"), d = h.datum();
      c.services.events.dispatchEvent(b.Axis.LABEL_MOUSEOVER, {
        event: l,
        element: h,
        datum: d
      }), r === kt.LABELS && d.length > o && c.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: l,
        element: h,
        datum: d
      });
    }).on("mousemove", function(l) {
      const h = D(this).select("text"), d = h.datum();
      c.services.events.dispatchEvent(b.Axis.LABEL_MOUSEMOVE, {
        event: l,
        element: h,
        datum: d
      }), c.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l) {
      c.services.events.dispatchEvent(b.Axis.LABEL_CLICK, {
        event: l,
        element: D(this).select("text"),
        datum: D(this).select("text").datum()
      });
    }).on("mouseout", function(l) {
      c.services.events.dispatchEvent(b.Axis.LABEL_MOUSEOUT, {
        event: l,
        element: D(this).select("text"),
        datum: D(this).select("text").datum()
      }), r === kt.LABELS && c.services.events.dispatchEvent(b.Tooltip.HIDE);
    }).on("focus", function(l) {
      const h = { clientX: 0, clientY: 0 };
      if (l.target) {
        l.target.focus();
        const d = l.target.getBoundingClientRect();
        h.clientX = d.x, h.clientY = d.y;
      }
      c.services.events.dispatchEvent(b.Axis.LABEL_FOCUS, {
        event: { ...l, ...h },
        element: D(this),
        datum: D(this).select("text").datum()
      });
    }).on("blur", function(l) {
      c.services.events.dispatchEvent(b.Axis.LABEL_BLUR, {
        event: l,
        element: D(this),
        datum: D(this).select("text").datum()
      });
    }).on("keydown", function(l) {
      l.key && l.key === "Escape" && (c.services.events.dispatchEvent(b.Tooltip.HIDE), c.services.events.dispatchEvent(b.Axis.LABEL_BLUR, {
        event: l,
        element: D(this),
        datum: D(this).select("text").datum()
      })), e === J.LEFT || e === J.RIGHT ? l.key && l.key === "ArrowUp" ? c.goNext(this, l) : l.key && l.key === "ArrowDown" && c.goPrevious(this, l) : l.key && l.key === "ArrowLeft" ? c.goPrevious(this, l) : l.key && l.key === "ArrowRight" && c.goNext(this, l);
    });
  }
  // Focus on the next HTML element sibling
  goNext(t, e) {
    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), e.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(t, e) {
    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), e.preventDefault();
  }
  destroy() {
    const t = this.getComponentContainer(), { position: e } = this.configs;
    I.appendOrSelect(t, `g.axis.${e}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class Em extends dt {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = at.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(t = !1) {
    const e = {}, n = Object.keys(J), s = O(this.getOptions(), "axes");
    n.forEach((o) => {
      s[J[o]] && (e[J[o]] = !0);
    }), this.configs.axes = e, n.forEach((o) => {
      const c = J[o];
      if (this.configs.axes[c] && !this.children[c]) {
        const l = {
          position: c,
          axes: this.configs.axes,
          margins: this.margins
        }, h = this.model.axisFlavor === bl.DEFAULT ? new Jo(this.model, this.services, l) : new ip(this.model, this.services, l);
        h.setModel(this.model), h.setServices(this.services), h.setParent(this.parent), this.children[c] = h;
      }
    }), Object.keys(this.children).forEach((o) => {
      this.children[o].render(t);
    });
    const a = {};
    Object.keys(this.children).forEach((o) => {
      const c = this.children[o], l = c.configs.position, h = c.getInvisibleAxisRef(), { width: d, height: u } = I.getSVGElementSize(
        h,
        { useBBox: !0 }
      );
      let p = 0;
      if (!c.getTitleRef().empty()) {
        const g = I.getSVGElementSize(c.getTitleRef(), {
          useBBox: !0
        }).height;
        l === J.LEFT || l === J.RIGHT ? p = g + 5 : l === J.BOTTOM ? p = g + Xr : p = g;
      }
      const f = d, m = u;
      switch (l) {
        case J.TOP:
          a.top = m + p;
          break;
        case J.BOTTOM:
          a.bottom = m + p;
          break;
        case J.LEFT:
          a.left = f + p;
          break;
        case J.RIGHT:
          a.right = f + p;
          break;
      }
    }), this.services.events.dispatchEvent(b.Axis.RENDER_COMPLETE), Object.keys(a).some(
      (o) => this.margins[o] !== a[o]
    ) && (this.margins = Object.assign(this.margins, a), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(b.ZoomBar.UPDATE), Object.keys(this.children).forEach((o) => {
      const c = this.children[o];
      c.margins = this.margins;
    }), this.render(!0));
  }
}
class ap extends dt {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = O(this.getOptions(), "data", "loading");
    e ? this.renderSkeleton(e) : this.removeSkeleton();
  }
  renderSkeleton(t) {
    if (this.configs.skeleton === zn.GRID)
      this.renderGridSkeleton(t);
    else if (this.configs.skeleton === zn.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(t);
    else if (this.configs.skeleton === zn.PIE)
      this.renderPieSkeleton(t);
    else if (this.configs.skeleton === zn.DONUT)
      this.renderDonutSkeleton(t);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(t) {
    const e = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(t), e === Xt.VERTICAL && this.drawYGrid(t), e === Xt.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(t) {
    const e = this.computeOuterRadius();
    this.drawRing(e, 0, t), t && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(t) {
    const e = this.computeOuterRadius(), n = this.computeInnerRadius();
    this.drawRing(e, n, t), t && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const t = this.services.cartesianScales.getMainXScale().range(), e = this.services.cartesianScales.getMainYScale().range();
    this.xScale = Re().domain([0, 1]).range(t), this.yScale = Re().domain([0, 1]).range(e);
  }
  drawBackdrop(t) {
    const e = this.parent, { width: n, height: s } = I.getSVGElementSize(e, {
      useAttrs: !0
    });
    this.backdrop = I.appendOrSelect(e, "svg.chart-skeleton.DAII").attr("role", "presentation").attr("width", n).attr("height", s);
    const a = I.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    a.attr("width", "100%").attr("height", "100%");
    const [r] = this.xScale.range(), [, o] = this.yScale.range();
    this.backdrop.merge(a).attr("x", r).attr("y", o), a.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(t) {
    const e = +this.backdrop.attr("width"), n = O(this.getOptions(), "grid", "x", "numberOfTicks"), s = this.xScale.ticks(n).map((o) => o * e), a = I.appendOrSelect(this.backdrop, "g.x.skeleton"), r = a.selectAll("line").data(s);
    r.enter().append("line").merge(r).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(t) {
    const e = +this.backdrop.attr("height"), n = this.backdrop.attr("width"), s = O(this.getOptions(), "grid", "y", "numberOfTicks"), a = this.xScale.ticks(s).map((c) => c * e), r = I.appendOrSelect(this.backdrop, "g.y.skeleton"), o = r.selectAll("line").data(a);
    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", n).attr("y1", (c) => c).attr("y2", (c) => c), r.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(t, e, n = !0) {
    const s = this.parent, { width: a, height: r } = I.getSVGElementSize(s, {
      useAttrs: !0
    }), o = I.appendOrSelect(s, "svg.chart-skeleton").attr("width", a).attr("height", r).attr("role", "presentation"), c = e === 0 ? "pie" : "donut", l = O(this.getOptions(), c, "alignment");
    I.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", a).attr("height", r).attr("fill", "none");
    const h = Dn().innerRadius(e).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), d = t + Math.abs(xt.radiusOffset), u = t + (Math.min(a, r) - t * 2) / 2, p = I.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${d}, ${u})`).attr("d", h).classed("shimmer-effect-areas", n).classed("empty-state-areas", !n).style(
      "fill",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let f = t + xt.xOffset;
    l === te.CENTER ? f = a / 2 : l === te.RIGHT && (f = a - t - xt.xOffset);
    const m = t + xt.yOffset;
    p.attr("transform", `translate(${f}, ${m})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: t, height: e } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(t, e) / 2 + xt.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(t) {
    const a = "stop-bg-shimmer", r = "stop-shimmer", o = this.parent.select(".chart-skeleton"), { width: c } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), l = 0, h = c, d = I.appendOrSelect(o, "defs").lower(), u = I.appendOrSelect(d, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", l - 3 * 0.2 * c).attr("x2", h).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), p = `
			<stop class="${a}" offset="${l}"></stop>
			<stop class="${r}" offset="${l + 0.2}"></stop>
			<stop class="${a}" offset="${l + 2 * 0.2}"></stop>
		`;
    u.html(p), f();
    function f() {
      u.attr("gradientTransform", `translate(${l - 3 * 0.2 * c}, 0)`).transition().duration(2e3).delay(1e3).ease(Uc).attr("gradientTransform", `translate(${h + 3 * 0.2 * c}, 0)`).on("end", f);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class xm extends dt {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = at.SVG;
  }
  render(t) {
    const e = this.getComponentContainer({ ariaLabel: "box plots", withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: s } = n.data, a = this.model.getDataGroupNames(), r = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [c, l] = r.range(), [h, d] = o.range(), u = l - c, p = h - d;
    if (u === 0)
      return;
    const { cartesianScales: f } = this.services, m = f.getOrientation(), g = m === Xt.VERTICAL, [v, S] = xe(
      (A) => this.services.cartesianScales.getDomainValue(A),
      (A) => this.services.cartesianScales.getRangeValue(A),
      m
    ), y = Math.floor((g ? u : p) / a.length), E = Math.min(y / 2, 16), x = this.model.getBoxplotData(), T = e.selectAll(".box-group").data(x);
    T.exit().remove();
    const C = T.enter().append("g").attr("class", "box-group"), _ = T.merge(C);
    C.append("path").merge(T.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", qt.strokeWidth.default).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-verticalstartline",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]), N = H, M = f.getRangeValue(A.whiskers.min), L = f.getRangeValue(A.quartiles.q_25);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, m);
    }), C.append("path").merge(T.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", qt.strokeWidth.default).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-verticalendline",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]), N = H, M = f.getRangeValue(A.whiskers.max), L = f.getRangeValue(A.quartiles.q_75);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, m);
    }), C.append("path").merge(T.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", qt.box.opacity.default).attr("stroke-width", qt.strokeWidth.default).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (A) => A[s]).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-quartiles",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 2, N = H + E, M = f.getRangeValue(
        Math[g ? "max" : "min"](A.quartiles.q_75, A.quartiles.q_25)
      ), L = M + Math.abs(
        f.getRangeValue(A.quartiles.q_75) - f.getRangeValue(A.quartiles.q_25)
      );
      return Gt({ x0: H, x1: N, y0: M, y1: L }, m);
    }), C.append("path").merge(T.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 2, N = H + E, M = f.getRangeValue(A.whiskers.min), L = f.getRangeValue(A.whiskers.max);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, m);
    }), C.append("path").merge(T.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", qt.strokeWidth.thicker).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-startingwhisker",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 4, N = H + E / 2, M = f.getRangeValue(A.whiskers.min), L = f.getRangeValue(A.whiskers.min);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, m);
    }), C.append("path").merge(T.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-median",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 2, N = H + E, M = f.getRangeValue(A.quartiles.q_50);
      return Gt({ x0: H, x1: N, y0: M, y1: M }, m);
    }), C.append("path").merge(T.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", qt.strokeWidth.thicker).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-endingwhisker",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 4, N = H + E / 2, M = f.getRangeValue(A.whiskers.max), L = f.getRangeValue(A.whiskers.max);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, m);
    });
    const V = _.selectAll("circle.outlier").data(
      (A) => A.outliers.map((H) => ({
        min: A.whiskers.min,
        max: A.whiskers.max,
        [s]: A[s],
        value: H
      }))
    );
    V.exit().remove();
    const R = V.enter().append("circle");
    V.merge(R).attr("r", qt.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", qt.circle.opacity.default).attr("cx", v).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-circles",
        animate: t
      })
    ).attr("cy", S), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(s, a) {
      const r = D(this);
      D(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", qt.box.opacity.hovered), t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: s,
        hoveredElement: r,
        items: [
          {
            label: O(e, "locale", "translations", "group") || O(e, "tooltip", "groupLabel") || "Group",
            value: a[n],
            class: t.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: a.whiskers.min
          },
          {
            label: "Q1",
            value: a.quartiles.q_25
          },
          {
            label: "Median",
            value: a.quartiles.q_50
          },
          {
            label: "Q3",
            value: a.quartiles.q_75
          },
          {
            label: "Maximum",
            value: a.whiskers.max
          },
          {
            label: "IQR",
            value: a.quartiles.q_75 - a.quartiles.q_25
          }
        ]
      }), t.services.events.dispatchEvent(b.Boxplot.BOX_MOUSEOVER, {
        event: s,
        element: r,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const r = D(this);
      t.services.events.dispatchEvent(b.Boxplot.BOX_MOUSEMOVE, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(b.Boxplot.BOX_CLICK, {
        event: s,
        element: D(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const r = D(this);
      D(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", qt.box.opacity.default), t.services.events.dispatchEvent(b.Boxplot.BOX_MOUSEOUT, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  addCircleEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(a, r) {
      const o = D(this);
      o.classed("hovered", !0).attr("fill-opacity", qt.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        items: [
          {
            label: O(e, "locale", "translations", "group") || O(e, "tooltip", "groupLabel") || "Group",
            value: r[n],
            class: t.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: r[s]
          }
        ]
      }), t.services.events.dispatchEvent(b.Boxplot.OUTLIER_MOUSEOVER, {
        event: a,
        element: o,
        datum: r
      });
    }).on("mousemove", function(a, r) {
      const o = D(this);
      t.services.events.dispatchEvent(b.Boxplot.OUTLIER_MOUSEMOVE, {
        event: a,
        element: o,
        datum: r
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      t.services.events.dispatchEvent(b.Boxplot.OUTLIER_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      o.classed("hovered", !1).attr("fill-opacity", qt.circle.opacity.default), t.services.events.dispatchEvent(b.Boxplot.OUTLIER_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class Sm extends dt {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = at.SVG;
  }
  render(t) {
    const e = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), n = this.services.cartesianScales.getScaleByPosition(e), [s, a] = n.domain(), r = s > 0 && a < 0 || s < 0 && a > 0, o = this.getComponentContainer({
      isPresentational: !0
    });
    if (!r) {
      o.selectAll("line.domain").remove();
      return;
    }
    const [c, l] = this.services.cartesianScales.getDomainScale().range();
    let h = +n(0) + 0.5;
    h || (h = n.range()[0]);
    const d = vl(
      {
        x0: c,
        x1: l,
        y0: h,
        y1: h
      },
      this.services.cartesianScales.getOrientation()
    );
    I.appendOrSelect(o, "line.domain").transition().call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "zero-line-update",
        animate: t
      })
    ).attr("y1", d.y0).attr("y2", d.y1).attr("x1", d.x0).attr("x2", d.x1);
  }
}
class Tm extends Qi {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = at.SVG;
  }
  getRadiusScale(t) {
    const e = this.getOptions(), { radiusMapsTo: n } = e.bubble, s = t.data(), a = s.map((l) => l[n]).filter((l) => l), r = I.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = a.length > 0, c = o ? Ls(a) : [1, 1];
    return Re().domain(c).range(o ? e.bubble.radiusRange(r, s) : [4, 4]);
  }
  styleCircles(t, e) {
    const n = this.getOptions(), { radiusMapsTo: s } = n.bubble, a = this.getRadiusScale(t), { groupMapsTo: r } = n.data, { cartesianScales: o } = this.services, c = (u) => o.getDomainValue(u), l = (u) => o.getRangeValue(u), [h, d] = xe(
      c,
      l,
      o.getOrientation()
    );
    t.raise().classed("dot", !0).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-label", (u) => {
      const p = o.getRangeIdentifier(u);
      return u[p];
    }).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bubble-update-enter",
        animate: e
      })
    ).attr("cx", h).attr("cy", d).attr("r", (u) => a(u[s] || 1)).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        dataGroupName: u[r],
        originalClassName: "dot"
      })
    ).style("fill", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[r], u[p], u);
    }).style("stroke", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getStrokeColor(u[r], u[p], u);
    }).attr("fill-opacity", n.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(t) {
    const e = O(this.getOptions(), "bubble");
    return [
      {
        label: O(e, "radiusLabel"),
        value: t[O(e, "radiusMapsTo")]
      }
    ];
  }
}
class bm extends dt {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.getComponentContainer({ ariaLabel: "bullet graphs", withinChartClip: !0 }), a = this.model.getDisplayData(this.configs.groups), r = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [c, l] = r.range(), [, h] = r.domain(), d = () => {
      const m = [];
      a.forEach((S) => {
        S.ranges ? S.ranges.forEach((y, E) => {
          y != null && y < h && m.push({
            datum: S,
            value: y,
            order: E + 1
          });
        }) : m.push({
          datum: S,
          order: 1
        });
      });
      const g = I.appendOrSelect(s, "g.range-boxes").selectAll("path.range-box").data(m, (S) => `${S[n]}-${S.order}`);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).attr("class", (S) => `range-box order-${S.order}`).transition().call(
        (S) => this.services.transitions.setupTransition({
          transition: S,
          name: "bullet-range-box-update-enter",
          animate: t
        })
      ).attr("d", (S) => {
        let E, x, T, C;
        return S.order === 1 ? (E = this.services.cartesianScales.getDomainValue(S.datum) - 16 / 2, x = E + 16, T = l - 2, C = c + 1) : (E = this.services.cartesianScales.getDomainValue(S.datum) - 16 / 2, x = E + 16, T = this.services.cartesianScales.getRangeValue(S.value), C = l), Gt(
          { x0: E, x1: x, y0: T, y1: C },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, u = () => {
      const m = I.appendOrSelect(s, "g.bars").selectAll("path.bar").data(a, (v) => v[n]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("bar", !0).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-bar-update-enter",
          animate: t
        })
      ).attr(
        "class",
        (v) => this.model.getColorClassName({
          classNameTypes: [nt.FILL],
          dataGroupName: v[n],
          originalClassName: "bar"
        })
      ).style("fill", (v) => {
        const S = this.services.cartesianScales.getDomainIdentifier(v);
        return this.model.getFillColor(v[n], v[S], v);
      }).attr("d", (v) => {
        const y = this.services.cartesianScales.getDomainValue(v) - 4, E = y + 8, x = this.services.cartesianScales.getRangeValue(0) + 1, T = this.services.cartesianScales.getRangeValue(v);
        return Gt(
          { x0: y, x1: E, y0: x, y1: T },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (v) => v.value);
    }, p = () => {
      const m = I.appendOrSelect(s, "g.markers").selectAll("path.marker").data(
        a.filter((v) => O(v, "marker") !== null),
        (v) => v[n]
      );
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("marker", !0).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-marker-update-enter",
          animate: t
        })
      ).attr("d", (v) => {
        const y = this.services.cartesianScales.getDomainValue(v) - 12, E = y + 24, x = this.services.cartesianScales.getRangeValue(v.marker);
        return Gt(
          { x0: y, x1: E, y0: x, y1: x },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, f = () => {
      let m = [];
      a.filter((S) => O(S, "marker") !== null).forEach((S) => {
        const y = S.marker, E = S[o];
        m = m.concat([
          { datum: S, value: y * 0.25, barValue: E },
          { datum: S, value: y * 0.5, barValue: E },
          { datum: S, value: y * 0.75, barValue: E }
        ]);
      });
      const g = I.appendOrSelect(s, "g.quartiles").selectAll("path.quartile").data(m, (S) => S[n]);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).attr("class", (S) => `quartile ${S.value <= S.barValue ? "over-bar" : ""}`).transition().call(
        (S) => this.services.transitions.setupTransition({
          transition: S,
          name: "bullet-quartile-update-enter",
          animate: t
        })
      ).attr("d", ({ datum: S, value: y }) => {
        let E = 4;
        S.ranges && S.ranges.indexOf(y) !== -1 && (E = 8);
        const x = this.services.cartesianScales.getDomainValue(S) - E / 2, T = x + E, C = this.services.cartesianScales.getRangeValue(y);
        return Gt(
          { x0: x, x1: T, y0: C, y1: C },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    d(), u(), p(), f(), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.services.cartesianScales.getRangeIdentifier(), { code: a, number: r } = O(e, "locale");
    this.parent.selectAll("path.bar").on("mouseover", function(o, c) {
      const l = D(this);
      l.classed("hovered", !0), t.services.events.dispatchEvent(b.Bar.BAR_MOUSEOVER, {
        event: o,
        element: l,
        datum: c
      });
      const h = O(e, "bullet", "performanceAreaTitles"), d = t.model.getMatchingRangeIndexForDatapoint(c);
      t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: o,
        hoveredElement: l,
        items: [
          {
            label: O(e, "locale", "translations", "group") || O(e, "tooltip", "groupLabel") || "Group",
            value: c[n],
            class: t.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP],
              dataGroupName: c[n]
            })
          },
          {
            label: "Value",
            value: c[s]
          },
          {
            label: "Target",
            value: c.marker
          },
          {
            label: "Percentage",
            value: `${r(Math.floor(c[s] / c.marker * 100), a)}%`
          },
          {
            label: "Performance",
            value: h[d]
          }
        ]
      });
    }).on("mousemove", function(o, c) {
      t.services.events.dispatchEvent(b.Bar.BAR_MOUSEMOVE, {
        event: o,
        element: D(this),
        datum: c
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: o
      });
    }).on("click", function(o, c) {
      t.services.events.dispatchEvent(b.Bar.BAR_CLICK, {
        event: o,
        element: D(this),
        datum: c
      });
    }).on("mouseout", function(o, c) {
      const l = D(this);
      l.classed("hovered", !1), t.services.events.dispatchEvent(b.Bar.BAR_MOUSEOUT, {
        event: o,
        element: l,
        datum: c
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: l
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function rp(i) {
  return i;
}
function op(i) {
  if (i == null) return rp;
  var t, e, n = i.scale[0], s = i.scale[1], a = i.translate[0], r = i.translate[1];
  return function(o, c) {
    c || (t = e = 0);
    var l = 2, h = o.length, d = new Array(h);
    for (d[0] = (t += o[0]) * n + a, d[1] = (e += o[1]) * s + r; l < h; ) d[l] = o[l], ++l;
    return d;
  };
}
function lp(i, t) {
  for (var e, n = i.length, s = n - t; s < --n; ) e = i[s], i[s++] = i[n], i[n] = e;
}
function cp(i, t) {
  return typeof t == "string" && (t = i.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(e) {
    return Dr(i, e);
  }) } : Dr(i, t);
}
function Dr(i, t) {
  var e = t.id, n = t.bbox, s = t.properties == null ? {} : t.properties, a = ta(i, t);
  return e == null && n == null ? { type: "Feature", properties: s, geometry: a } : n == null ? { type: "Feature", id: e, properties: s, geometry: a } : { type: "Feature", id: e, bbox: n, properties: s, geometry: a };
}
function ta(i, t) {
  var e = op(i.transform), n = i.arcs;
  function s(h, d) {
    d.length && d.pop();
    for (var u = n[h < 0 ? ~h : h], p = 0, f = u.length; p < f; ++p)
      d.push(e(u[p], p));
    h < 0 && lp(d, f);
  }
  function a(h) {
    return e(h);
  }
  function r(h) {
    for (var d = [], u = 0, p = h.length; u < p; ++u) s(h[u], d);
    return d.length < 2 && d.push(d[0]), d;
  }
  function o(h) {
    for (var d = r(h); d.length < 4; ) d.push(d[0]);
    return d;
  }
  function c(h) {
    return h.map(o);
  }
  function l(h) {
    var d = h.type, u;
    switch (d) {
      case "GeometryCollection":
        return { type: d, geometries: h.geometries.map(l) };
      case "Point":
        u = a(h.coordinates);
        break;
      case "MultiPoint":
        u = h.coordinates.map(a);
        break;
      case "LineString":
        u = r(h.arcs);
        break;
      case "MultiLineString":
        u = h.arcs.map(r);
        break;
      case "Polygon":
        u = c(h.arcs);
        break;
      case "MultiPolygon":
        u = h.arcs.map(c);
        break;
      default:
        return null;
    }
    return { type: d, coordinates: u };
  }
  return l(t);
}
function up(i, t) {
  var e = {}, n = {}, s = {}, a = [], r = -1;
  t.forEach(function(l, h) {
    var d = i.arcs[l < 0 ? ~l : l], u;
    d.length < 3 && !d[1][0] && !d[1][1] && (u = t[++r], t[r] = l, t[h] = u);
  }), t.forEach(function(l) {
    var h = o(l), d = h[0], u = h[1], p, f;
    if (p = s[d])
      if (delete s[p.end], p.push(l), p.end = u, f = n[u]) {
        delete n[f.start];
        var m = f === p ? p : p.concat(f);
        n[m.start = p.start] = s[m.end = f.end] = m;
      } else
        n[p.start] = s[p.end] = p;
    else if (p = n[u])
      if (delete n[p.start], p.unshift(l), p.start = d, f = s[d]) {
        delete s[f.end];
        var g = f === p ? p : f.concat(p);
        n[g.start = f.start] = s[g.end = p.end] = g;
      } else
        n[p.start] = s[p.end] = p;
    else
      p = [l], n[p.start = d] = s[p.end = u] = p;
  });
  function o(l) {
    var h = i.arcs[l < 0 ? ~l : l], d = h[0], u;
    return i.transform ? (u = [0, 0], h.forEach(function(p) {
      u[0] += p[0], u[1] += p[1];
    })) : u = h[h.length - 1], l < 0 ? [u, d] : [d, u];
  }
  function c(l, h) {
    for (var d in l) {
      var u = l[d];
      delete h[u.start], delete u.start, delete u.end, u.forEach(function(p) {
        e[p < 0 ? ~p : p] = 1;
      }), a.push(u);
    }
  }
  return c(s, n), c(n, s), t.forEach(function(l) {
    e[l < 0 ? ~l : l] || a.push([l]);
  }), a;
}
function hp(i) {
  for (var t = -1, e = i.length, n, s = i[e - 1], a = 0; ++t < e; ) n = s, s = i[t], a += n[0] * s[1] - n[1] * s[0];
  return Math.abs(a);
}
function dp(i) {
  return ta(i, pp.apply(this, arguments));
}
function pp(i, t) {
  var e = {}, n = [], s = [];
  t.forEach(a);
  function a(c) {
    switch (c.type) {
      case "GeometryCollection":
        c.geometries.forEach(a);
        break;
      case "Polygon":
        r(c.arcs);
        break;
      case "MultiPolygon":
        c.arcs.forEach(r);
        break;
    }
  }
  function r(c) {
    c.forEach(function(l) {
      l.forEach(function(h) {
        (e[h = h < 0 ? ~h : h] || (e[h] = [])).push(c);
      });
    }), n.push(c);
  }
  function o(c) {
    return hp(ta(i, { type: "Polygon", arcs: [c] }).coordinates[0]);
  }
  return n.forEach(function(c) {
    if (!c._) {
      var l = [], h = [c];
      for (c._ = 1, s.push(l); c = h.pop(); )
        l.push(c), c.forEach(function(d) {
          d.forEach(function(u) {
            e[u < 0 ? ~u : u].forEach(function(p) {
              p._ || (p._ = 1, h.push(p));
            });
          });
        });
    }
  }), n.forEach(function(c) {
    delete c._;
  }), {
    type: "MultiPolygon",
    arcs: s.map(function(c) {
      var l = [], h;
      if (c.forEach(function(m) {
        m.forEach(function(g) {
          g.forEach(function(v) {
            e[v < 0 ? ~v : v].length < 2 && l.push(v);
          });
        });
      }), l = up(i, l), (h = l.length) > 1)
        for (var d = 1, u = o(l[0]), p, f; d < h; ++d)
          (p = o(l[d])) > u && (f = l[0], l[0] = l[d], l[d] = f, u = p);
      return l;
    }).filter(function(c) {
      return c.length > 0;
    })
  };
}
class Om extends Ko {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = at.SVG;
  }
  showRuler(t, [e, n]) {
    const s = this.parent, a = this.model.getOptions(), { cartesianScales: r } = this.services, o = r.getOrientation(), c = r.getRangeScale(), [l, h] = c.range(), d = r.getDomainScale(), u = d.invert(
      o === Xt.VERTICAL ? e : n
    ), p = I.appendOrSelect(s, "g.ruler").attr("aria-label", "ruler"), f = I.appendOrSelect(p, "line.ruler-line"), g = s.selectAll("[role=graphics-symbol]").filter((v) => {
      if (parseFloat(Et(v, "data.x0")) <= u && parseFloat(Et(v, "data.x1")) >= u)
        return !0;
    });
    if (g.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !uo(this.elementsToHighlight, g) && this.hideRuler(), g.dispatch("mouseover"), this.elementsToHighlight = g;
      const v = D(g.nodes()[0]).datum(), S = parseFloat(Et(v, "data.x0")), y = parseFloat(Et(v, "data.x1")), E = this.model.getActiveDataGroupNames(), x = E.reverse().map((C) => ({
        label: C,
        value: Et(v, `data.${C}`),
        class: this.model.getColorClassName({
          classNameTypes: [nt.TOOLTIP],
          dataGroupName: C
        })
      })).filter((C) => C.value !== 0);
      if (x.length > 0) {
        this.services.events.dispatchEvent(b.Tooltip.SHOW, {
          event: t,
          mousePosition: [e, n],
          hoveredElement: f,
          items: [
            {
              label: Et(a, "bins.rangeLabel") || "Range",
              value: `${S} – ${y}`
            },
            ...x,
            ...O(a, "tooltip", "showTotal") === !0 ? [
              {
                label: Et(a, "tooltip.totalLabel") || Et(a, "locale.translations.total") || "Total",
                value: (() => {
                  const _ = O(
                    a,
                    "tooltip",
                    "customTotalCalculation"
                  );
                  if (_) {
                    const V = E.map(
                      (R) => ({
                        [R]: parseFloat(Et(v, `data.${R}`))
                      })
                    );
                    return _(V);
                  } else
                    return E.reduce(
                      (V, R) => V + parseFloat(Et(v, `data.${R}`)),
                      0
                    );
                })()
              }
            ] : []
          ]
        }), p.attr("opacity", 1);
        const C = d((S + y) / 2);
        o === "horizontal" ? f.attr("x1", h).attr("x2", l).attr("y1", C).attr("y2", C) : f.attr("y1", h).attr("y2", l).attr("x1", C).attr("x2", C);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class Lm extends Ko {
  formatTooltipData(t) {
    return t.reverse();
  }
}
const Am = (i, t) => {
  const e = i.x, n = i.y, s = t.x, a = t.y, r = Ms();
  return r.moveTo(e, n), r.lineTo(s, a), r.toString();
}, Mm = (i, t, e = 0.5) => {
  const n = i.x, s = i.y, a = t.x, r = t.y, o = Ms();
  return o.moveTo(n, s), o.lineTo(n + (a - n) * e, s), o.lineTo(n + (a - n) * e, r), o.lineTo(a, r), o.toString();
}, wm = (i, t, e, n, s, a) => {
  const r = i.x, o = i.y, c = t.x, l = t.y, h = Ms();
  return h.moveTo(r, o), h.bezierCurveTo(e, n, s, a, c, l), h.toString();
}, Cm = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, km = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, _m = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, Im = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, Rm = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, Dm = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class Nm extends Nd {
  constructor(t, e, n) {
    super(t, e, n), this.type = "color-legend", this.renderType = at.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const s = this.getComponentContainer(), { width: a } = I.getSVGElementSize(s, {
        useAttrs: !0
      }), r = O(this.getOptions(), "data", "loading");
      if (a > Mt.color.barWidth && !r) {
        const o = O(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: c } = this.services, h = c.getMainXScale().range();
        if (h[0] > 1 && (s.select("g.legend").attr("transform", `translate(${h[0]}, 0)`), o)) {
          const { width: d } = I.getSVGElementSize(
            s.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), u = h[0] - d - 9;
          u > 1 ? s.select("g.legend-title").attr("transform", `translate(${u}, 0)`) : (s.select("g.legend").attr("transform", `translate(${h[0]}, 16)`), s.select("g.legend-title").attr("transform", `translate(${h[0]}, 0)`));
        }
      } else
        s.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = n.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(b.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = this.getComponentContainer({
      ariaLabel: "legend"
    }), { width: s } = I.getSVGElementSize(n, {
      useAttrs: !0
    }), a = O(e, "color", "gradient", "colors"), r = O(e, this.chartType, "colorLegend", "type");
    let o = O(e, "color", "pairing", "option");
    const c = O(e, "heatmap", "colorLegend", "title");
    if (O(this.getOptions(), "data", "loading")) {
      n.html("");
      return;
    }
    const h = !Wr(a), d = yl(this.model.getDisplayData()), u = !(s <= Mt.color.barWidth), p = u ? Mt.color.barWidth : s, f = I.appendOrSelect(n, "g.legend"), m = I.appendOrSelect(f, "g.legend-axis");
    if (c) {
      const R = I.appendOrSelect(n, "g.legend-title");
      I.appendOrSelect(R, "text").text(c).attr("dy", "0.7em"), f.attr("transform", "translate(0, 16)");
    }
    const g = d[0] < 0 && d[1] > 0 ? "diverge" : "mono";
    (o < 1 && o > 4 && g === "mono" || o < 1 && o > 2 && g === "diverge") && (o = 1);
    let v = [];
    const S = g === "diverge" ? 17 : 11;
    if (h)
      v = a;
    else
      for (let R = 1; R < S + 1; R++)
        v.push(
          r === Gs.LINEAR ? `stop-color-${g}-${o}-${R}` : `fill-${g}-${o}-${R}`
        );
    const y = Yr(d[0], d[1]), E = zc(y, 3), x = Re().domain(d).range([0, p]), T = Fi(x).tickSize(0).tickValues(E), { code: C, number: _ } = O(e, "locale");
    T.tickFormat((R) => _(R, C));
    let V;
    switch (r) {
      case Gs.LINEAR:
        this.drawLinear(v, f, p);
        break;
      case Gs.QUANTIZE:
        V = this.drawQuantize(
          v,
          g,
          h,
          f,
          p
        ), x.range([V, p]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    m.attr("transform", `translate(0,${Mt.color.axisYTranslation})`).call(T), m.select(".domain").remove(), m.select("g.tick:last-of-type text").style("text-anchor", u ? "middle" : "end"), m.select("g.tick:first-of-type text").style(
      "text-anchor",
      u && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(t, e, n) {
    const s = 100 / (t.length - 1);
    I.appendOrSelect(e, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (o, c) => `${c * s}%`).attr("class", (o, c) => t[c]).attr("stop-color", (o) => o), I.appendOrSelect(e, "rect").attr("width", n).attr("height", Mt.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(t, e, n, s, a) {
    !n && e === "diverge" && t.splice(t.length / 2, 1);
    const r = hs().domain(t).range([0, a]);
    return I.appendOrSelect(s, "g.quantized-rect").selectAll("rect").data(r.domain()).join("rect").attr("x", (c) => r(c)).attr("y", 0).attr("width", Math.max(0, r.bandwidth() - 1)).attr("height", Mt.color.barHeight).attr("class", (c) => c).attr("fill", (c) => c), (!n && e) === "mono" ? r.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(b.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
}
class Pm extends Dd {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = at.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = O(this.model.getDisplayData(), 0), n = this.getOptions(), s = this.getComponentContainer({
      ariaLabel: "meter title"
    }), { groupMapsTo: a } = n.data, r = n.locale.translations.meter.title;
    if (O(n, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const h = s.selectAll("text.meter-title").data(r ? [r] : [e[a]]);
      h.enter().append("text").classed("meter-title", !0).merge(h).attr("x", 0).attr("y", "1em").text((d) => d), h.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const c = this.getMaxTitleWidth(), l = I.appendOrSelect(s, "text.meter-title");
    c > 0 && l.node().getComputedTextLength() > c && this.truncateTitle(l, c);
  }
  displayBreakdownTitle() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = this.model.getMaximumDomain(
      this.model.getDisplayData()
    ), s = O(e, "meter", "proportional", "total"), a = O(e, "meter", "proportional", "unit") ? O(e, "meter", "proportional", "unit") : "";
    let r;
    if (n === s)
      r = null;
    else {
      const h = s !== null ? s - n : n, d = O(e, "meter", "proportional", "breakdownFormatter"), { code: u, number: p } = O(e, "locale");
      r = d !== null ? d({
        datasetsTotal: n,
        total: s
      }) : `${p(n, u)} ${a} used (${p(h, u)} ${a} available)`;
    }
    const o = t.selectAll("text.proportional-meter-title").data([r]);
    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((h) => h), o.exit().remove();
    const c = this.getMaxTitleWidth(), l = I.appendOrSelect(t, "text.proportional-meter-title");
    c > 0 && l.node().getComputedTextLength() > c && this.truncateTitle(l, c);
  }
  // show the total for prop meter
  displayTotal() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = O(e, "meter", "proportional", "total"), s = n ? O(e, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), a = O(e, "meter", "proportional", "unit") ? O(e, "meter", "proportional", "unit") : "", r = O(e, "meter", "proportional", "totalFormatter"), { code: o, number: c } = O(e, "locale"), l = r !== null ? r(s) : `${c(n, o)} ${a} total`, h = I.getHTMLElementSize(this.parent.node()).width, d = t.selectAll("text.proportional-meter-total").data([l]);
    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(
      "x",
      this.model.getStatus() && typeof h != "string" ? h - _t.total.paddingRight : h
    ).attr("y", "1em").attr("text-anchor", "end").text((u) => u), d.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const t = this, e = this.getComponentContainer(), n = I.getHTMLElementSize(this.parent.node()).width || 0, s = this.model.getStatus(), a = _t.status.indicatorSize / 2, r = I.appendOrSelect(e, "g.status-indicator").attr("class", s !== null ? `status-indicator status--${s}` : "").attr("transform", `translate(${n - a}, 0)`), o = s ? [s] : [], c = r.selectAll("circle.status").data(o);
    c.enter().append("circle").merge(c).attr("class", "status").attr("r", a).attr("cx", 0).attr("cy", 8);
    const l = r.selectAll("path.innerFill").data(o);
    l.enter().append("path").merge(l).attr("d", t.getStatusIconPathString(s)).attr("transform", `translate(-${a}, 0)`).attr("class", "innerFill"), l.exit().remove(), c.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const t = O(this.model.getDisplayData(), 0, "value"), { code: e, number: n } = O(this.getOptions(), "locale"), s = this.getComponentContainer(), a = I.appendOrSelect(s, "text.meter-title"), r = O(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], o = s.selectAll("text.percent-value").data(r), c = _t.statusBar.paddingRight;
    o.enter().append("text").classed("percent-value", !0).merge(o).text((l) => `${l != null ? n(l, e) : 0}%`).attr("x", +a.attr("x") + a.node().getComputedTextLength() + c).attr("y", a.attr("y")), o.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param maxWidth the max width the title can take
   */
  truncateTitle(t, e) {
    super.truncateTitle(t, e);
    const n = I.appendOrSelect(this.parent, "tspan"), s = _t.statusBar.paddingRight, a = Math.ceil(n.node().getComputedTextLength());
    I.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +t.attr("x") + t.node().getComputedTextLength() + a + s
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const t = O(this.getOptions(), "meter", "proportional"), e = I.getHTMLElementSize(this.parent.node()).width;
    if (t !== null) {
      const n = I.appendOrSelect(this.parent, "text.proportional-meter-total").node(), s = I.getSVGElementSize(n, {
        useBBox: !0
      }).width;
      return e - s - _t.total.paddingLeft;
    } else {
      const n = I.appendOrSelect(this.parent, "text.percent-value"), s = _t.statusBar.paddingRight, a = n.node().getComputedTextLength(), r = I.appendOrSelect(this.parent, "g.status-indicator").node(), o = I.getSVGElementSize(r, { useBBox: !0 }).width + _t.status.paddingLeft;
      return e - a - s - o;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(t) {
    switch (t) {
      case Hs.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case Hs.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case Hs.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class ea extends dt {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions();
    if (t.bars.width)
      return t.bars.width;
    const e = this.model.getDisplayData().length, n = this.services.cartesianScales.getMainXScale(), s = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!n.step) {
      const a = O(t, "bars", "spacingFactor");
      return Math.min(t.bars.maxWidth, s * a / e);
    }
    return Math.min(t.bars.maxWidth, n.step() / 2);
  }
  isOutsideZoomedDomain(t, e) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const s = this.model.get("zoomDomain");
    if (s !== void 0) {
      const a = this.services.cartesianScales.getDomainScale();
      return t < a(s[0]) || e > a(s[1]);
    }
    return !1;
  }
}
class $m extends dt {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (n) => n.data.dataGroupName === e.datum().name ? 1 : dn.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "circle packs",
      withinChartClip: !0
    }), { width: n, height: s } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    let a = this.model.getDisplayData();
    const r = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), c = this.getOptions(), l = O(c, "canvasZoom", "enabled");
    r && O(a, 0, "children") && (a = O(a, 0, "children"));
    const h = Nn({ children: a }).sum((m) => m.value).sort((m, g) => g.value - m.value), u = Dh().size([n, s]).padding((m) => m.depth >= 1 ? dn.padding.children + 3 : dn.padding.mainGroup + 3)(h).descendants().splice(1).filter((m) => m.depth <= o), p = e.selectAll("circle.node").data(u);
    p.exit().attr("width", 0).attr("height", 0).remove();
    const f = p.enter().append("circle").classed("node", !0);
    f.merge(p).attr("class", (m) => {
      const g = l && o === 3 ? this.getZoomClass(m) : "";
      return this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        dataGroupName: m.data.dataGroupName,
        originalClassName: m.children ? `node ${g}` : `node node-leaf ${g}`
      });
    }).style("fill", (m) => this.model.getFillColor(m.data.dataGroupName, null, m.data)).style("stroke", (m) => this.model.getFillColor(m.data.dataGroupName, null, m.data)).attr("cx", (m) => m.x).attr("cy", (m) => m.y).transition("circlepack-leaf-update-enter").call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (m) => m.r).attr("opacity", 1).attr("fill-opacity", dn.circles.fillOpacity), l === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, f, Bn), this.setBackgroundListeners()), r || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(t) {
    const e = t.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => e.some((s) => s === n.data) && n.depth > 1).style("stroke", (n) => this.model.getFillColor(n.data.dataGroupName, null, n.data));
  }
  // highlight the children circles with a stroke
  highlightChildren(t) {
    const e = t.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => e.some((s) => s === n.data) && n.depth > 1).style("stroke", dn.circles.hover.stroke);
  }
  getZoomClass(t) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((e) => e.data === t.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: t } = this.services;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    D(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const t = D(this.services.domUtils.getMainContainer()), e = this, n = this.parent.selectAll("circle.node");
    t.on("click", () => {
      e.focal = null, e.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), e.services.canvasZoom.zoomOut(n, Bn);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const t = this;
    this.parent.selectAll("circle.node").on("mouseover", function(e, n) {
      const s = D(this);
      s.classed("hovered", !0);
      const a = t.model.getHierarchyLevel(), r = a > 2 && !s.classed("focal"), o = O(t.model.getOptions(), "canvasZoom", "enabled");
      let c = !1;
      if (!r) {
        let l = [], h = [], d = null;
        if (n.children) {
          n.depth > 1 && o && (c = !0, s.classed("clickable", !0)), l = n.children.map((f) => {
            if (f !== null)
              return typeof f.data.value == "number" ? {
                label: f.data.name,
                value: f.data.value
              } : {
                label: f.data.name,
                labelIcon: o && a <= 2 ? t.getZoomIcon() : null,
                value: f.value
              };
          });
          const p = t.model.getOptions();
          h = [
            {
              label: Et(p, "locale.translations.total") || Et(p, "tooltip.totalLabel") || "Total",
              value: n.value,
              bold: !0
            }
          ], t.highlightChildren(n.children);
        } else
          d = n.value;
        const u = getComputedStyle(this, null).getPropertyValue("fill");
        t.services.events.dispatchEvent(b.Tooltip.SHOW, {
          event: e,
          hoveredElement: s,
          items: [
            {
              color: u,
              label: n.data.name,
              labelIcon: c && o && a <= 2 ? t.getZoomIcon() : null,
              value: d
            },
            ...l,
            ...h
          ]
        });
      }
      t.services.events.dispatchEvent(b.CirclePack.CIRCLE_MOUSEOVER, {
        event: e,
        element: s,
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(b.CirclePack.CIRCLE_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: e
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      s.classed("hovered", !1), n.children && t.unhighlightChildren(n.children), t.services.events.dispatchEvent(b.CirclePack.CIRCLE_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: s
      });
    }).on("click", function(e, n) {
      const s = D(this), a = s.classed("non-focal"), r = O(t.model.getOptions(), "canvasZoom", "enabled");
      if (r && t.model.getHierarchyLevel() > 2) {
        const o = t.parent.selectAll("circle.node");
        D(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Bn);
      } else if (n.depth === 2 && n.children && !a && r) {
        const o = t.parent.selectAll("circle.node");
        D(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = n, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(n, o, Bn), e.stopPropagation();
      }
      t.services.events.dispatchEvent(b.CirclePack.CIRCLE_CLICK, {
        event: e,
        element: s,
        datum: n
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function fp(i, t) {
  const e = Fr(this._current, i);
  return (n) => (this._current = e(n), t(this._current));
}
class gp extends dt {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = at.SVG, this.isRendering = !1, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (s) => s.data[n] !== e.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return xt.innerRadius;
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer({
      ariaLabel: "pie graph"
    }), s = this.getOptions(), { groupMapsTo: a } = s.data, { valueMapsTo: r } = s.pie;
    this.isRendering = !0;
    const o = this.model.getDisplayData().filter((M) => M[r] > 0), c = this.computeRadius();
    this.arc = Dn().innerRadius(this.getInnerRadius()).outerRadius(c), this.hoverArc = Dn().innerRadius(this.getInnerRadius()).outerRadius(c + xt.hoverArc.outerRadiusOffset);
    const h = nd().value((M) => M[r]).sort(O(s, "pie", "sortFunction")).padAngle(xt.padAngle)(o), u = I.appendOrSelect(n, "g.slices").attr("role", lt.GROUP).attr("data-name", "slices").selectAll("path.slice").data(h, (M) => M.data[a]);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(
      "class",
      (M) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: M.data[a],
        originalClassName: "slice"
      })
    ).style("fill", (M) => e.model.getFillColor(M.data[a], null, M.data)).attr("d", this.arc).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "pie_slice_enter_update",
        animate: t
      })
    ).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr("aria-label", (M) => [
      M[r],
      $s(M.data[r], o, r) + "%",
      M.data[a]
    ].filter(Boolean).join(", ")).attrTween("d", function(M) {
      return fp.bind(this)(M, e.arc);
    }).on("end", () => {
      e.isRendering = !1;
    });
    const { code: m, number: g } = O(s, "locale"), v = s.pie.labels.enabled, S = v ? h.filter((M) => M.data[r] > 0) : [], E = I.appendOrSelect(n, "g.labels").attr("role", lt.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(S, (M) => M.data[a]);
    E.exit().attr("opacity", 0).remove();
    const x = E.enter().append("text").classed("pie-label", !0), T = [];
    x.merge(E).style("text-anchor", "middle").text((M) => s.pie.labels.formatter ? s.pie.labels.formatter({
      ...M,
      percentageValue: $s(
        M.data[r],
        o,
        r,
        !0
      )
    }) : g(
      $s(M.data[r], o, r),
      m
    ) + "%").datum(function(M) {
      const L = c + 7, P = (M.endAngle - M.startAngle) / 2 + M.startAngle, $ = P / Math.PI * 180, k = this.getComputedTextLength();
      return M.textOffsetX = k / 2, M.textOffsetY = $ > 90 && $ < 270 ? 10 : 0, M.xPosition = (M.textOffsetX + L) * Math.sin(P), M.yPosition = (M.textOffsetY + L) * -Math.cos(P), M;
    }).attr("transform", function(M, L) {
      const P = S.length, $ = (M.endAngle - M.startAngle) * (180 / Math.PI);
      if (L >= P - 2 && $ < xt.callout.minSliceDegree) {
        let k, G;
        return M.index === P - 1 ? (k = M.xPosition + xt.callout.offsetX + xt.callout.textMargin + M.textOffsetX, G = M.yPosition - xt.callout.offsetY, M.direction = Bs.RIGHT, T.push(M)) : (k = M.xPosition - xt.callout.offsetX - M.textOffsetX - xt.callout.textMargin, G = M.yPosition - xt.callout.offsetY, M.direction = Bs.LEFT, T.push(M)), `translate(${k}, ${G})`;
      }
      return `translate(${M.xPosition}, ${M.yPosition})`;
    }), this.renderCallouts(T);
    const C = O(s, "donut") ? "donut" : "pie", _ = O(s, C, "alignment"), { width: V } = I.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), R = v ? xt.xOffset : 0, A = v ? xt.yOffset : 0;
    let H = c + R;
    _ === te.CENTER ? H = V / 2 : _ === te.RIGHT && (H = V - c - xt.xOffset);
    let N = c + A;
    T.length > 0 && (N += xt.yOffsetCallout), n.attr("x", H + 7).attr("y", N), this.addEventListeners();
  }
  renderCallouts(t) {
    const e = I.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", lt.GROUP).attr("data-name", "callouts"), n = e.selectAll("g.callout").data(t);
    n.exit().remove();
    const s = n.enter().append("g").classed("callout", !0).attr("role", lt.GROUP).attr("aria-roledescription", "label callout");
    s.merge(n).datum(function(o) {
      const { xPosition: c, yPosition: l, direction: h } = o;
      return h === Bs.RIGHT ? (o.startPos = {
        x: c,
        y: l + o.textOffsetY
      }, o.endPos = {
        x: c + xt.callout.offsetX,
        y: l - xt.callout.offsetY + o.textOffsetY
      }, o.intersectPointX = o.endPos.x - xt.callout.horizontalLineLength) : (o.startPos = {
        x: c,
        y: l + o.textOffsetY
      }, o.endPos = {
        x: c - xt.callout.offsetX,
        y: l - xt.callout.offsetY + o.textOffsetY
      }, o.intersectPointX = o.endPos.x + xt.callout.horizontalLineLength), o;
    }), s.append("line").classed("vertical-line", !0).merge(e.selectAll("line.vertical-line")).datum(function() {
      return D(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (o) => o.startPos.x).attr("y1", (o) => o.startPos.y).attr("x2", (o) => o.intersectPointX).attr("y2", (o) => o.endPos.y), s.append("line").classed("horizontal-line", !0).merge(e.selectAll("line.horizontal-line")).datum(function() {
      return D(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (o) => o.intersectPointX).attr("y1", (o) => o.endPos.y).attr("x2", (o) => o.endPos.x).attr("y2", (o) => o.endPos.y);
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.slice").on("mouseover", function(e, n) {
      const s = D(this);
      t.isRendering || s.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "pie_slice_mouseover"
        })
      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(b.Pie.SLICE_MOUSEOVER, {
        event: e,
        element: D(this),
        datum: n
      });
      const { groupMapsTo: a } = t.getOptions().data, { valueMapsTo: r } = t.getOptions().pie;
      t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: e,
        hoveredElement: s,
        items: [
          {
            label: n.data[a],
            value: n.data[r]
          }
        ]
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(b.Pie.SLICE_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(b.Pie.SLICE_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      Oc(() => {
        t.isRendering || s.classed("hovered", !1).transition("pie_slice_mouseout").call(
          (a) => t.services.transitions.setupTransition({
            transition: a,
            name: "pie_slice_mouseout"
          })
        ).attr("d", t.arc);
      }, 100), t.services.events.dispatchEvent(b.Pie.SLICE_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: t, height: e } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), n = this.getOptions(), s = Math.min(t, e) / 2;
    return n.pie.labels.enabled ? s + xt.radiusOffset : s;
  }
}
class Vm extends gp {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = at.SVG;
  }
  render(t = !0) {
    super.render(t);
    const e = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer({
        ariaLabel: "donut graph"
      }).select("g.center").remove();
      return;
    }
    const n = I.appendOrSelect(
      this.getComponentContainer({
        ariaLabel: "donut graph"
      }),
      "g.center"
    ), s = this.getOptions(), a = this.computeRadius(), r = O(s, "donut", "center", "label");
    I.appendOrSelect(n, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => r === null || r === "" ? "central" : "initial").style("font-size", () => s.donut.center.numberFontSize(a)).transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "donut-figure-enter-update",
        animate: t
      })
    ).tween("text", function() {
      return e.centerNumberTween(D(this));
    }), r !== null && r !== "" && I.appendOrSelect(n, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => s.donut.center.titleFontSize(a)).attr("y", s.donut.center.titleYPosition(a)).text(r);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(t) {
    const e = this.getOptions();
    let n = O(e, "donut", "center", "number");
    n === null && (n = this.model.getDisplayData().reduce((o, c) => o + c[e.pie.valueMapsTo], 0));
    const s = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;
    let a;
    s % 1 === 0 && n % 1 === 0 ? a = El : a = Yr;
    const r = a(s, n);
    return (o) => {
      const { numberFormatter: c } = e.donut.center;
      if (c)
        t.text(c(r(o)));
      else {
        const { code: l, number: h } = O(e, "locale");
        t.text(h(Math.floor(r(o)), l));
      }
    };
  }
}
const Nr = "4,10 8,6 12,10", Pr = "12,6 8,10 4,6";
class Gm extends dt {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = at.SVG;
  }
  getValue() {
    return this.model.getData().find((n) => n.group === "value")?.value ?? null;
  }
  getValueRatio() {
    return co(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    return this.model.getData().find((n) => n.group === "delta")?.value ?? null;
  }
  getArcRatio() {
    const t = this.getOptions();
    return O(t, "gauge", "type") === Un.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const t = this.getArcSize();
    return t === 2 * Math.PI ? 0 : -t / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(t) {
    const e = this.getOptions();
    switch (O(e, "gauge", "deltaArrow", "direction")) {
      case Oa.UP:
        return Nr;
      case Oa.DOWN:
        return Pr;
      default:
        return t > 0 ? Nr : Pr;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "gauge graph"
    }).attr("width", "100%").attr("height", "100%"), n = this.getOptions(), s = this.getValue(), a = this.getValueRatio(), r = this.getArcSize(), o = this.getStartAngle(), c = a * r, l = o + c, h = o + r, d = this.computeRadius(), u = this.getInnerRadius();
    this.backgroundArc = Dn().innerRadius(u).outerRadius(d).startAngle(l).endAngle(h), this.arc = Dn().innerRadius(u).outerRadius(d).startAngle(o).endAngle(l), I.appendOrSelect(e, "path.arc-background").attr("d", this.backgroundArc);
    const p = e.selectAll("path.arc-foreground").data([s]);
    p.enter().append("path").merge(p).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => O(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (S) => S), this.drawValueNumber(), this.drawDelta(), p.exit().remove();
    const m = O(n, "gauge", "alignment"), { width: g } = I.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let v = d;
    m === te.CENTER ? v = g / 2 : m === te.RIGHT && (v = g - d), e.attr("x", v).attr("y", d), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = O(e, "gauge", "type"), s = this.getValue(), a = this.getDelta(), r = this.computeRadius(), o = O(e, "gauge", "valueFontSize"), c = O(e, "gauge", "deltaFontSize"), l = O(e, "gauge", "numberSpacing"), h = O(e, "gauge", "showPercentageSymbol");
    let d = 0;
    n === Un.FULL && !a ? d = c(r) : n === Un.SEMI && a && (d = -(c(r) + l));
    const u = I.appendOrSelect(t, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${d})`
    ), p = o(r), f = I.appendOrSelect(u, "g.gauge-value-number"), { code: m, number: g } = O(e, "locale"), v = O(e, "gauge", "numberFormatter"), S = f.selectAll("text.gauge-value-number").data([s]);
    S.enter().append("text").attr("class", "gauge-value-number").merge(S).style("font-size", `${p}px`).attr("text-anchor", "middle").text((V) => {
      let R;
      return V != null ? R = Number(V.toFixed(2)) % 1 !== 0 ? V.toFixed(2) : V.toFixed() : R = 0, v ? v(R) : g(Number(R), m);
    });
    const { width: y } = I.getSVGElementSize(
      I.appendOrSelect(t, "text.gauge-value-number"),
      { useBBox: !0 }
    ), E = p / 2, x = h ? "%" : "", T = I.appendOrSelect(f, "text.gauge-value-symbol").style("font-size", `${E}px`).attr("x", y / 2).text(x), { width: C, height: _ } = I.getSVGElementSize(T, {
      useBBox: !0
    });
    T.attr("y", `-${_ / 2}px`), f.attr("transform", `translate(-${C / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const t = this, e = this.getComponentContainer(), n = this.getOptions(), s = this.getDelta(), { code: a, number: r } = O(n, "locale");
    if (s) {
      const o = this.computeRadius(), c = s ? O(n, "gauge", "deltaFontSize") : () => 0, l = s ? O(n, "gauge", "numberFormatter") : () => null, h = O(n, "gauge", "deltaArrow", "size"), d = O(n, "gauge", "numberSpacing"), u = O(n, "gauge", "showPercentageSymbol"), p = I.appendOrSelect(e, "g.gauge-numbers"), f = I.appendOrSelect(p, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${c(o) + d})`
      ), m = I.appendOrSelect(f, "text.gauge-delta-number"), g = u ? "%" : "";
      m.data(s === null ? [] : [s]), m.enter().append("text").classed("gauge-delta-number", !0).merge(m).attr("text-anchor", "middle").style("font-size", `${c(o)}px`).text((E) => {
        let x;
        return E != null ? x = Number(E.toFixed(2)) % 1 !== 0 ? E.toFixed(2) : E.toFixed() : x = 0, l ? `${l(x)}${g}` : `${r(Number(x), a)}${g}`;
      });
      const { width: v } = I.getSVGElementSize(
        I.appendOrSelect(e, ".gauge-delta-number"),
        { useBBox: !0 }
      ), S = O(n, "gauge", "deltaArrow", "enabled"), y = f.selectAll("svg.gauge-delta-arrow").data(s !== null && S ? [s] : []);
      y.enter().append("svg").merge(y).attr("class", "gauge-delta-arrow").attr("x", -h(o) - v / 2).attr("y", -h(o) / 2 - c(o) * 0.35).attr("width", h(o)).attr("height", h(o)).attr("viewBox", "0 0 16 16").each(function() {
        const E = D(this);
        I.appendOrSelect(E, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const x = O(n, "gauge", "status");
        I.appendOrSelect(E, "polygon.gauge-delta-arrow").attr("class", x !== null ? `gauge-delta-arrow status--${x}` : "").attr("points", t.getArrow(s));
      }), y.exit().remove(), m.exit().remove();
    } else {
      const o = e.select("g.gauge-delta");
      o.empty() || o.remove();
    }
  }
  getInnerRadius() {
    const t = this.computeRadius(), e = O(this.getOptions(), "gauge", "arcWidth");
    return t - e;
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(e, n) {
      t.services.events.dispatchEvent(b.Gauge.ARC_MOUSEOVER, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(b.Gauge.ARC_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(b.Gauge.ARC_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(b.Gauge.ARC_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      });
    });
  }
  // Helper functions
  computeRadius() {
    const t = this.getOptions(), e = O(t, "gauge", "type"), { width: n, height: s } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return e === Un.SEMI ? Math.min(n / 2, s) : Math.min(n / 2, s / 2);
  }
}
class Hm extends ea {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = at.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.model.getDisplayData(this.configs.groups), n = this.getOptions(), { groupMapsTo: s } = n.data;
    this.setGroupScale();
    const a = this.getComponentContainer({ ariaLabel: "grouped bar graphs", withinChartClip: !0 }), r = xl(
      e.map((u) => {
        const p = this.services.cartesianScales.getDomainIdentifier(u);
        return u[p] && typeof u[p].toString == "function" ? u[p].toString() : u[p];
      })
    ), o = a.selectAll("g.bars").data(r, (u) => u);
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("bars", !0).attr("role", lt.GROUP).attr("data-name", "bars").merge(o);
    l.transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-group-update-enter",
        animate: t
      })
    ).attr("transform", (u) => {
      const f = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth(u) / 2;
      return this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? `translate(${f}, 0)` : `translate(0, ${f})`;
    });
    const h = l.selectAll("path.bar").data(
      (u) => this.getDataCorrespondingToLabel(u),
      (u) => u[s]
    );
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).classed("bar", !0).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: u[s],
        originalClassName: "bar"
      })
    ).style("fill", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[s], u[p], u);
    }).attr("d", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u), f = u[p] && typeof u[p].toString == "function" ? u[p].toString() : u[p], g = this.getGroupScaleForLabel(f)(u[s]), v = this.getBarWidth(), S = g, y = g + v, E = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), x = this.services.cartesianScales.getDomainLowerBound(E), T = this.services.cartesianScales.getValueThroughAxisPosition(E, x), C = this.services.cartesianScales.getRangeValue(u), _ = this.services.cartesianScales.getDomainValue(u) - v / 2, V = _ + v;
      if (!this.isOutsideZoomedDomain(_, V))
        return Gt(
          { x0: S, x1: y, y0: T, y1: C },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, e = O(this.getOptions(), "tooltip", "alwaysShowRulerTooltip"), n = this.parent.selectAll("path.bar");
    e ? n.style("pointer-events", "none") : n.style("pointer-events", null), n.on("mouseover", function(s, a) {
      const r = D(this);
      r.classed("hovered", !0), t.services.events.dispatchEvent(b.Bar.BAR_MOUSEOVER, {
        event: s,
        element: r,
        datum: a
      }), e || t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: s,
        hoveredElement: r,
        data: [a]
      });
    }).on("mousemove", function(s, a) {
      const r = D(this);
      t.services.events.dispatchEvent(b.Bar.BAR_MOUSEMOVE, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(b.Bar.BAR_CLICK, {
        event: s,
        element: D(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const r = D(this);
      r.classed("hovered", !1), t.services.events.dispatchEvent(b.Bar.BAR_MOUSEOUT, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(t) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const s = this.services.cartesianScales.getDomainIdentifier(n);
      return n[s].toString() === t;
    });
  }
  getGroupWidth(t) {
    const e = this.getOptions();
    if (!(O(e, "bars", "preserveSpaceForMissingBars") !== !1) && t) {
      const r = this.getDataCorrespondingToLabel(t), o = this.getTotalGroupPadding(r.length);
      return this.getBarWidth() * r.length + o;
    }
    const s = this.model.getGroupedData(this.configs.groups), a = this.getTotalGroupPadding();
    return this.getBarWidth() * s.length + a;
  }
  getDomainScaleStep() {
    const t = this.services.cartesianScales.getDomainScale(), e = this.model.getGroupedData(this.configs.groups);
    let n = this.defaultStepFactor;
    if (typeof t.step == "function")
      n = t.step();
    else if (e.length > 0) {
      const s = e.find((a) => a.data?.length > 1);
      if (s) {
        const a = this.services.cartesianScales.getDomainIdentifier(s.data[0]);
        n = Math.abs(
          t(s.data[1][a]) - t(s.data[0][a])
        );
      }
    }
    return n;
  }
  getTotalGroupPadding(t) {
    const e = this.model.getGroupedData(this.configs.groups), n = t !== void 0 ? t : e.length;
    return n === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (n - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions(), e = O(t, "bars", "width"), n = O(t, "bars", "maxWidth");
    if (e !== null && (n === null || e <= n))
      return e;
    const a = this.model.getGroupedData(this.configs.groups).length, r = this.getTotalGroupPadding();
    return Math.min(
      n,
      (this.getDomainScaleStep() - r) / a
    );
  }
  setGroupScale() {
    const t = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = hs().domain(t).rangeRound([0, this.getGroupWidth()]);
  }
  getGroupScaleForLabel(t) {
    const e = this.getOptions();
    if (!(O(e, "bars", "preserveSpaceForMissingBars") !== !1)) {
      const s = this.getDataCorrespondingToLabel(t), { groupMapsTo: a } = e.data, r = s.map((o) => o[a]);
      return hs().domain(r).rangeRound([0, this.getGroupWidth(t)]);
    }
    return this.groupScale;
  }
}
class Bm extends dt {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = at.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (t) => {
      const { detail: e } = t, { datum: n } = e, s = this.model.getUniqueRanges(), a = this.model.getUniqueDomain(), r = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), c = this.services.cartesianScales.getMainXScale(), l = this.services.cartesianScales.getMainYScale();
      let h = "", d = null, u = null, p = null;
      this.matrix[n] !== void 0 ? (h = r, s.forEach((f) => {
        if (typeof this.matrix[n][f].value == "number") {
          const m = this.matrix[n][f].value;
          if (d === null) {
            d = m, u = m, p = m;
            return;
          }
          d += m, u = m < u ? m : u, p = m > p ? m : p;
        }
      })) : (h = o, a.forEach((f) => {
        if (typeof this.matrix[f][n].value == "number") {
          const m = this.matrix[f][n].value;
          if (d === null) {
            d = m, u = m, p = m;
            return;
          }
          d += m, u = m < u ? m : u, p = m > p ? m : p;
        }
      })), c(n) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${c(n)}, ${fi(l.range())})`) : l(n) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${fi(c.range())},${l(n)})`), this.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: e.event,
        hoveredElement: D(t.detail.element),
        items: [
          {
            label: h,
            value: n,
            bold: !0
          },
          {
            label: "Min",
            value: u !== null ? u : "-"
          },
          {
            label: "Max",
            value: p !== null ? p : "-"
          },
          {
            label: "Average",
            value: d !== null ? d / a.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (t) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(b.Tooltip.HIDE, {
        event: t
      });
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(b.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(b.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(b.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ ariaLabel: "heatmap", withinChartClip: !0 });
    e.lower();
    const { cartesianScales: n } = this.services;
    if (this.matrix = this.model.getMatrix(), e.html(""), O(this.getOptions(), "data", "loading"))
      return;
    const s = n.getMainXScale(), a = n.getMainYScale(), r = n.getDomainIdentifier(), o = n.getRangeIdentifier(), c = this.model.getUniqueDomain(), l = this.model.getUniqueRanges(), h = this.model.getMatrixAsArray(), d = s.range(), u = a.range();
    this.xBandwidth = Math.abs((d[1] - d[0]) / c.length), this.yBandwidth = Math.abs((u[1] - u[0]) / l.length);
    const p = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    e.append("defs").append("pattern").attr("id", p).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const f = e.selectAll().data(h).enter().append("g").attr("class", (m) => `heat-${m.index}`).classed("cell", !0).attr(
      "transform",
      (m) => `translate(${s(m[r])}, ${a(m[o])})`
    ).append("rect").attr(
      "class",
      (m) => this.model.getColorClassName({
        value: m.value,
        originalClassName: `heat-${m.index}`
      })
    ).classed("heat", !0).classed("null-state", (m) => m.index === -1 || m.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (m) => {
      const g = this.services.cartesianScales.getDomainIdentifier(m);
      return m.index === -1 || m.value === null ? `url(#${p})` : this.model.getFillColor(Number(m.value), m[g], m);
    }).attr("aria-label", (m) => m.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(u[1] - u[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(d[1] - d[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (f.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(t, e, n) {
    const s = I.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);
    I.appendOrSelect(s, "line.top").attr("x1", -1).attr("x2", e + 1), I.appendOrSelect(s, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", n + 1), I.appendOrSelect(s, "line.down").attr("x1", -1).attr("x2", e + 1).attr("y1", n).attr("y2", n), I.appendOrSelect(s, "line.right").attr("x1", e).attr("x2", e).attr("y1", -1).attr("y2", n + 1);
  }
  determineDividerStatus() {
    const t = O(this.getOptions(), "heatmap", "divider", "state");
    return t !== zs.OFF && (t === zs.AUTO && Sa.minCellDividerDimension <= this.xBandwidth && Sa.minCellDividerDimension <= this.yBandwidth || t === zs.ON);
  }
  addEventListener() {
    const t = this, { cartesianScales: e } = this.services, n = this.getOptions(), s = Et(n, "locale.translations.total") || Et(n, "tooltip.totalLabel") || "Total", a = e.getDomainIdentifier(), r = e.getRangeIdentifier(), o = e.getDomainLabel(), c = e.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(l, h) {
      const d = D(this), u = d.select("rect.heat");
      if (!u.classed("null-state")) {
        const f = yn(d.attr("transform"));
        t.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${f.x + t.translationUnits.x}, ${f.y + t.translationUnits.y})`
        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(b.Heatmap.HEATMAP_MOUSEOVER, {
          event: l,
          element: u,
          datum: h
        }), t.services.events.dispatchEvent(b.Tooltip.SHOW, {
          event: l,
          items: [
            {
              label: o,
              value: h[a]
            },
            {
              label: c,
              value: h[r]
            },
            {
              label: s,
              value: h.value,
              color: u.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(l, h) {
      t.services.events.dispatchEvent(b.Heatmap.HEATMAP_MOUSEMOVE, {
        event: l,
        element: D(this),
        datum: h
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l, h) {
      t.services.events.dispatchEvent(b.Heatmap.HEATMAP_CLICK, {
        event: l,
        element: D(this),
        datum: h
      });
    }).on("mouseout", function(l, h) {
      const u = D(this).select("rect.heat"), p = u.classed("null-state");
      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), p || (t.services.events.dispatchEvent(b.Heatmap.HEATMAP_MOUSEOUT, {
        event: l,
        element: u,
        datum: h
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        event: l,
        hoveredElement: u
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class zm extends dt {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (a) => a[s] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({
      ariaLabel: "histogram bars"
    }), n = this.model.getOptions(), { groupIdentifier: s } = n, { groupMapsTo: a } = n.data, r = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), c = e.selectAll("g.bars").data(r, (h) => Et(h, `0.${a}`));
    c.exit().attr("opacity", 0).remove(), c.enter().append("g").classed("bars", !0).attr("role", lt.GROUP);
    const l = e.selectAll("g.bars").selectAll("path.bar").data((h) => h);
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).attr(s, (h, d) => d).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "histogram-bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: h[a],
        originalClassName: "bar"
      })
    ).style("fill", (h) => this.model.getFillColor(h[a], null, h)).attr("d", (h) => {
      const d = Et(h, "data");
      if (!d)
        return;
      const u = o(d.x1) - o(d.x0) - 1, p = this.services.cartesianScales.getDomainValue(d.x0), f = p + u, m = this.services.cartesianScales.getRangeValue(h[0]);
      let g = this.services.cartesianScales.getRangeValue(h[1]);
      return Math.abs(g - m) > 0 && Math.abs(g - m) > n.bars.dividerSize && (this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? g += 1 : g -= 1), Gt(
        { x0: p, x1: f, y0: m, y1: g },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (h) => O(h, "data", h[a])), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.model.getOptions(), { groupMapsTo: e } = t.data, { code: n, number: s } = O(t, "locale"), a = O(t, "tooltip", "alwaysShowRulerTooltip"), r = this.parent.selectAll("path.bar");
    a ? r.style("pointer-events", "none") : r.style("pointer-events", null);
    const o = this;
    r.on("mouseover", function(c, l) {
      const h = D(this);
      h.classed("hovered", !0);
      const d = s(parseFloat(Et(l, "data.x0")), n), u = s(parseFloat(Et(l, "data.x1")), n), p = o.services.cartesianScales.getRangeAxisPosition(), f = o.services.cartesianScales.getScaleLabel(p);
      a || o.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: c,
        hoveredElement: h,
        items: [
          {
            label: Et(t, "bins.rangeLabel") || "Range",
            value: `${d} – ${u}`
          },
          {
            label: t.tooltip.groupLabel || "Group",
            value: l[e],
            class: o.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP],
              dataGroupName: l[e]
            })
          },
          {
            label: f,
            value: Et(l, `data.${l[e]}`)
          }
        ]
      });
    }).on("mousemove", function(c) {
      o.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: c
      });
    }).on("mouseout", function() {
      D(this).classed("hovered", !1), o.services.events.dispatchEvent(b.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Um extends Qi {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = at.SVG, this.handleScatterOnHover = (t) => {
      const e = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("line.line").attr("stroke-width", (a) => a[s] !== e.datum[s] ? ve.weight.unselected : ve.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", ve.weight.unselected);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-line"
        })
      ).attr("opacity", (a) => a[s] !== e.datum().name ? ve.opacity.unselected : ve.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ve.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), n = this.model.getOptions(), { groupMapsTo: s } = n.data, { cartesianScales: a } = this.services, r = a.getMainXScale(), o = a.getMainYScale(), c = a.getDomainIdentifier(), l = (v) => a.getDomainValue(v), h = (v) => a.getRangeValue(v), d = a.getOrientation(), [u, p] = xe(
      l,
      h,
      d
    ), f = e.selectAll("line.line").data(
      this.getScatterData(),
      (v) => `${v[s]}-${v[c]}`
    );
    f.exit().attr("opacity", 0).remove();
    const g = f.enter().append("line").attr("opacity", 0).merge(f).classed("line", !0).attr(
      "class",
      (v) => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        dataGroupName: v[s],
        originalClassName: "line"
      })
    ).transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "lollipop-line-update-enter",
        animate: t
      })
    ).style("stroke", (v) => this.model.getFillColor(v[s], v[c], v)).attr("opacity", 1);
    d === Xt.HORIZONTAL ? g.attr("y1", p).attr("y2", p).attr("x1", r.range()[0]).attr("x2", (v) => u(v) - n.points.radius) : g.attr("x1", u).attr("x2", u).attr("y1", o.range()[0]).attr("y2", (v) => p(v) + n.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      b.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      b.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(b.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(
      b.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class Fm extends dt {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = at.SVG;
  }
  getStackedBounds(t, e) {
    let n = 0;
    return t.map((a, r) => r !== 0 ? (n += e(a.value), {
      ...a,
      width: Math.abs(e(a.value) - _t.dividerWidth),
      x: n - e(a.value)
    }) : (n = e(a.value), {
      ...a,
      width: Math.abs(e(a.value) - _t.dividerWidth),
      x: 0
    }));
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer({
      ariaLabel: "meter lines"
    }), s = this.getOptions(), a = O(s, "meter", "proportional"), r = this.model.getDisplayData(), o = this.model.getStatus(), { width: c } = I.getSVGElementSize(n, {
      useAttrs: !0
    }), { groupMapsTo: l } = s.data;
    let h;
    if (O(s, "meter", "proportional") === null)
      h = 100;
    else {
      const y = O(s, "meter", "proportional", "total");
      h = y || this.model.getMaximumDomain(this.model.getDisplayData());
    }
    const d = Re().domain([0, h]).range([0, c]), u = this.getStackedBounds(r, d), p = O(s, "meter", "height");
    I.appendOrSelect(n, "rect.container").attr("x", 0).attr("y", 0).attr("width", c).attr(
      "height",
      p || (a ? _t.height.proportional : _t.height.default)
    ), I.appendOrSelect(n, "line.rangeIndicator").attr("x1", c).attr("x2", c).attr("y1", 0).attr(
      "y2",
      p || (a ? _t.height.proportional : _t.height.default)
    );
    const f = n.selectAll("rect.value").data(u), m = o != null && !e.model.isUserProvidedColorScaleValid() && !a ? `value status--${o}` : "value";
    f.enter().append("rect").classed("value", !0).merge(f).attr("x", (y) => y.x).attr("y", 0).attr("height", () => p || (a ? _t.height.proportional : _t.height.default)).attr(
      "class",
      (y) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: y[l],
        originalClassName: m
      })
    ).transition().call(
      (y) => this.services.transitions.setupTransition({
        transition: y,
        name: "meter-bar-update",
        animate: t
      })
    ).attr("width", (y) => y.value > h ? d(h) : Math.max(y.width, 2)).style("fill", (y) => e.model.getFillColor(y[l], null, y)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (y) => y.value), f.exit().remove();
    const g = O(s, "meter", "peak");
    let v = g;
    g !== null && (g > h ? v = h : g < 0 && (v = 0));
    const S = n.selectAll("line.peak").data(v == null ? [] : [v]);
    S.enter().append("line").classed("peak", !0).merge(S).attr("y1", 0).attr("y2", () => p || (a ? _t.height.proportional : _t.height.default)).transition().call(
      (y) => this.services.transitions.setupTransition({
        transition: y,
        name: "peak-line-update",
        animate: t
      })
    ).attr("x1", (y) => d(y)).attr("x2", (y) => d(y)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (y) => y), S.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this, s = O(t, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(b.Meter.METER_MOUSEOVER, {
        event: a,
        element: o,
        datum: r
      }), s && (o.classed("hovered", !0), n.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        items: [
          {
            label: r[e],
            value: r.value
          }
        ]
      }));
    }).on("mousemove", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(b.Meter.METER_MOUSEMOVE, {
        event: a,
        element: o,
        datum: r
      }), s && n.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      n.services.events.dispatchEvent(b.Meter.METER_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(b.Meter.METER_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), s && (o.classed("hovered", !1), n.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: o
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class Wm extends dt {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = at.SVG, this.getLabelDimensions = (t) => {
      const e = I.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), n = I.appendOrSelect(e, "text").text(t), { width: s, height: a } = I.getSVGElementSize(n.node(), { useBBox: !0 });
      return e.remove(), { width: s, height: a };
    }, this.normalizeFlatData = (t) => {
      const e = this.getOptions(), { angle: n, value: s } = O(e, "radar", "axes"), a = O(e, "data", "groupMapsTo"), r = wc(
        this.uniqueKeys.map((o) => this.uniqueGroups.map((c) => ({
          [n]: o,
          [a]: c,
          [s]: null
        })))
      );
      return sn(r, t);
    }, this.normalizeGroupedData = (t) => {
      const e = this.getOptions(), { angle: n, value: s } = O(e, "radar", "axes"), a = O(e, "data", "groupMapsTo");
      return t.map(({ name: r, data: o }) => {
        const c = this.uniqueKeys.map((l) => ({
          [a]: r,
          [n]: l,
          [s]: null
        }));
        return { name: r, data: sn(c, o) };
      });
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (n) => n.name !== e.datum().name ? Ae.opacity.unselected : Ae.opacity.selected).style("stroke-opacity", (n) => n.name !== e.datum().name ? Ae.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", Ae.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "radar graph"
    }), { width: n, height: s } = I.getSVGElementSize(e, {
      useAttrs: !0
    }), a = this.model.getData(), r = this.model.getGroupedData(), o = this.getOptions(), c = O(o, "data", "groupMapsTo"), l = O(o, "radar", "axes", "value"), { angle: h, value: d } = O(o, "radar", "axes"), { xLabelPadding: u, yLabelPadding: p, yTicksNumber: f, minRange: m, xAxisRectHeight: g } = Ae;
    this.uniqueKeys = Array.from(new Set(a.map((z) => z[h]))), this.uniqueGroups = Array.from(new Set(a.map((z) => z[c]))), this.fullDataNormalized = this.normalizeFlatData(a), this.groupedDataNormalized = this.normalizeGroupedData(r);
    const S = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + p), x = (Math.min(n, s) - S) / 2;
    if (x <= 0)
      return;
    const T = hs().domain(this.fullDataNormalized.map((z) => z[h])).range([0, 2 * Math.PI].map((z) => z - Math.PI / 2)), C = fi(this.fullDataNormalized.map((z) => z[d])), _ = Re().domain([
      C >= 0 ? 0 : C,
      Ta(this.fullDataNormalized.map((z) => z[d]))
    ]).range([m, x]).nice(f), V = _.ticks(f), R = (z, B, U) => this.model.getFillColor(z, B, U), A = ad().angle((z) => T(z[h]) + Math.PI / 2).radius((z) => _(z[d])).curve(wl), H = this.uniqueKeys.map((z) => {
      const B = this.getLabelDimensions(z).width, U = Cl(
        T(z),
        x
      );
      return B + U;
    }), M = {
      x: Ta(H) + u,
      y: s / 2
    }, P = I.appendOrSelect(e, "g.y-axes").attr("role", lt.GROUP).selectAll("path").data(V, (z) => z), $ = (z) => this.uniqueKeys.map((B) => ({ [h]: B, [d]: z }));
    P.join(
      (z) => z.append("path").attr("opacity", 0).attr("transform", `translate(${M.x}, ${M.y})`).attr("fill", "none").call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("d", (U) => A($(U)))
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${M.x}, ${M.y})`).attr("d", (U) => A($(U)))
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_axes_exit",
            animate: t
          })
        ).attr("d", (U) => A($(U))).attr("opacity", 0).remove()
      )
    ), I.appendOrSelect(e, "g.x-axes").attr("role", lt.GROUP).selectAll("line").data(this.uniqueKeys, (z) => z).join(
      (z) => z.append("line").attr("opacity", 0).attr("class", (B) => `x-axis-${Fe(B)}`).attr("stroke-dasharray", "0").attr("x1", (B) => bt(T(B), 0, M).x).attr("y1", (B) => bt(T(B), 0, M).y).attr("x2", (B) => bt(T(B), 0, M).x).attr("y2", (B) => bt(T(B), 0, M).y).call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (U) => bt(T(U), _.range()[0], M).x).attr("y1", (U) => bt(T(U), _.range()[0], M).y).attr("x2", (U) => bt(T(U), _.range()[1], M).x).attr("y2", (U) => bt(T(U), _.range()[1], M).y)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (U) => bt(T(U), _.range()[0], M).x).attr("y1", (U) => bt(T(U), _.range()[0], M).y).attr("x2", (U) => bt(T(U), _.range()[1], M).x).attr("y2", (U) => bt(T(U), _.range()[1], M).y)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_axes_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), I.appendOrSelect(e, "g.x-labels").attr("role", lt.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (z) => z.append("text").text((B) => B).attr("opacity", 0).attr(
        "x",
        (B) => bt(T(B), _.range()[1] + u, M).x
      ).attr(
        "y",
        (B) => bt(T(B), _.range()[1] + u, M).y
      ).style("text-anchor", (B) => ka(T(B)).textAnchor).style(
        "dominant-baseline",
        (B) => ka(T(B)).dominantBaseline
      ).call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_labels_update",
            animate: t
          })
        ).attr("opacity", 1).attr(
          "x",
          (U) => bt(T(U), _.range()[1] + u, M).x
        ).attr(
          "y",
          (U) => bt(T(U), _.range()[1] + u, M).y
        ).end().finally(() => {
          const U = O(o, "radar", "alignment"), wt = this.getAlignmentXOffset(U, e, this.getParent());
          e.attr("x", wt);
        })
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), I.appendOrSelect(e, "g.blobs").attr("role", lt.GROUP).selectAll("path").data(this.groupedDataNormalized, (z) => z.name).join(
      (z) => z.append("path").attr(
        "class",
        (B) => this.model.getColorClassName({
          classNameTypes: [nt.FILL, nt.STROKE],
          dataGroupName: B.name,
          originalClassName: "blob"
        })
      ).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-label", (B) => B.name).attr("opacity", 0).attr(
        "transform",
        t ? () => `translate(${M.x}, ${M.y}) scale(${1 + Math.random() * 0.35})` : `translate(${M.x}, ${M.y})`
      ).style("fill", (B) => R(B.name, null, B.data)).style("fill-opacity", Ae.opacity.selected).style("stroke", (B) => R(B.name, null, B.data)).call((B) => {
        const U = B.transition().call(
          (wt) => this.services.transitions.setupTransition({
            transition: wt,
            name: "radar_blobs_enter",
            animate: t
          })
        );
        t && U.delay(() => Math.random() * 30).attr("transform", `translate(${M.x}, ${M.y})`), U.attr("opacity", 1).attr("d", (wt) => A(wt.data));
      }),
      (z) => (z.attr(
        "class",
        (B) => this.model.getColorClassName({
          classNameTypes: [nt.FILL, nt.STROKE],
          dataGroupName: B.name,
          originalClassName: "blob"
        })
      ).style("fill", (B) => R(B.name, null, B.data)).style("stroke", (B) => R(B.name, null, B.data)), z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_blobs_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${M.x}, ${M.y})`).attr("d", (U) => A(U.data))
      ), z),
      (z) => z.call((B) => {
        const U = B.transition().call(
          (wt) => this.services.transitions.setupTransition({
            transition: wt,
            name: "radar_blobs_exit",
            animate: t
          })
        );
        t && U.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${M.x}, ${M.y}) scale(${1 + Math.random() * 0.35})`
        ), U.attr("opacity", 0).remove();
      })
    ), I.appendOrSelect(e, "g.dots").attr("role", lt.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((z) => O(z, d) !== null)).join(
      (z) => z.append("circle").attr("role", lt.GRAPHICS_SYMBOL).attr("aria-label", (B) => B[l]),
      (z) => z,
      (z) => z.remove()
    ).attr(
      "class",
      (z) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: z[c],
        originalClassName: Fe(z[h])
      })
    ).attr("cx", (z) => bt(T(z[h]), _(z[d]), M).x).attr("cy", (z) => bt(T(z[h]), _(z[d]), M).y).attr("r", 0).attr("opacity", 0).style("fill", (z) => R(z[c])), I.appendOrSelect(e, "g.x-axes-rect").attr("role", lt.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (z) => z.append("rect"),
      (z) => z,
      (z) => z.remove()
    ).attr("x", M.x).attr("y", M.y - g / 2).attr("width", _.range()[1]).attr("height", g).style("fill", "red").style("fill-opacity", 0).attr("transform", (z) => `rotate(${kl(T(z))}, ${M.x}, ${M.y})`);
    const { code: ot, number: ct } = O(o, "locale");
    I.appendOrSelect(e, "g.y-labels").attr("role", lt.GROUP).selectAll("text").data(Ls(V)).join(
      (z) => z.append("text").attr("opacity", 0).text((B) => ct(B, ot)).attr(
        "x",
        (B) => bt(-Math.PI / 2, _(B), M).x + p
      ).attr("y", (B) => bt(-Math.PI / 2, _(B), M).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_labels_update",
            animate: t
          })
        ).text((U) => U).attr("opacity", 1).attr(
          "x",
          (U) => bt(-Math.PI / 2, _(U), M).x + p
        ).attr("y", (U) => bt(-Math.PI / 2, _(U), M).y)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(t, e, n) {
    const s = I.getSVGElementSize(e, {
      useBBox: !0
    }), { width: a } = I.getSVGElementSize(n, {
      useAttrs: !0
    });
    let r = 0;
    return t === te.CENTER ? r = Math.floor((a - s.width) / 2) : t === te.RIGHT && (r = a - s.width), r;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const t = this, {
      axes: { angle: e }
    } = O(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(b.Radar.X_AXIS_MOUSEOVER, {
        event: n,
        element: a,
        datum: s
      });
      const r = t.parent.select(`.x-axes .x-axis-${Fe(s)}`), o = t.parent.selectAll(`.dots circle.${Fe(s)}`), c = t.model.getActiveDataGroupNames(), l = t.getOptions(), { groupMapsTo: h } = l.data, d = O(l, "radar", "axes", "value");
      r.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(
        "opacity",
        (p) => c.indexOf(p[h]) !== -1 ? 1 : 0
      ).attr("r", Ae.dotsRadius);
      const u = t.fullDataNormalized.filter(
        (p) => p[e] === s && c.indexOf(p[h]) !== -1
      );
      t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: n,
        hoveredElement: a,
        items: u.filter((p) => typeof p[d] == "number").map((p) => ({
          label: p[h],
          value: p[d],
          color: t.model.getFillColor(p[h], null, p),
          class: t.model.getColorClassName({
            classNameTypes: [nt.TOOLTIP],
            dataGroupName: p[h]
          })
        }))
      });
    }).on("mousemove", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(b.Radar.X_AXIS_MOUSEMOVE, {
        event: n,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      t.services.events.dispatchEvent(b.Radar.X_AXIS_CLICK, {
        event: n,
        element: D(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      const a = D(this), r = t.parent.select(`.x-axes .x-axis-${Fe(s)}`), o = t.parent.selectAll(`.dots circle.${Fe(s)}`);
      r.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(b.Radar.X_AXIS_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE);
    });
  }
}
class Xm extends ea {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.getComponentContainer({
      ariaLabel: "bar graphs",
      withinChartClip: !0
    }), a = this.model.getDisplayData(this.configs.groups), r = this.services.cartesianScales.getOrientation(), o = s.selectAll("path.bar").data(a, (l) => l[n]);
    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: l[n],
        originalClassName: "bar"
      })
    ).style("fill", (l) => {
      const h = this.services.cartesianScales.getDomainIdentifier(l);
      return this.model.getFillColor(l[n], l[h], l);
    }).attr("d", (l) => {
      const h = this.services.cartesianScales.getRangeIdentifier(), d = this.getBarWidth(), u = l[h], p = this.services.cartesianScales.getDomainValue(l) - d / 2, f = p + d;
      let m, g;
      if (Array.isArray(u) && u.length === 2)
        m = this.services.cartesianScales.getRangeValue(u[0]), g = this.services.cartesianScales.getRangeValue(u[1]);
      else {
        const y = this.services.cartesianScales.getRangeScale().domain()[0];
        m = this.services.cartesianScales.getRangeValue(Math.max(0, y)), g = this.services.cartesianScales.getRangeValue(l);
      }
      const v = Math.abs(g - m);
      if (v !== 0 && v < 2 && (u > 0 && r === Xt.VERTICAL || u < 0 && r === Xt.HORIZONTAL ? g = m - 2 : g = m + 2), !this.isOutsideZoomedDomain(p, f))
        return Gt({ x0: p, x1: f, y0: m, y1: g }, r);
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, e = O(this.getOptions(), "tooltip", "alwaysShowRulerTooltip"), n = this.parent.selectAll("path.bar");
    e ? n.style("pointer-events", "none") : n.style("pointer-events", null), n.on("mouseover", function(s, a) {
      const r = D(this);
      r.classed("hovered", !0), t.services.events.dispatchEvent(b.Bar.BAR_MOUSEOVER, {
        event: s,
        element: r,
        datum: a
      }), e || t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: s,
        hoveredElement: r,
        data: [a]
      });
    }).on("mousemove", function(s, a) {
      t.services.events.dispatchEvent(b.Bar.BAR_MOUSEMOVE, {
        event: s,
        element: D(this),
        datum: a
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(b.Bar.BAR_CLICK, {
        event: s,
        element: D(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const r = D(this);
      r.classed("hovered", !1), t.services.events.dispatchEvent(b.Bar.BAR_MOUSEOUT, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Ym extends ap {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = O(this.getOptions(), "data", "loading"), n = !O(this.getOptions(), "grid", "x", "enabled") && !O(this.getOptions(), "grid", "y", "enabled") && !O(this.getOptions(), "axes", "bottom", "visible") && !O(this.getOptions(), "axes", "left", "visible");
    e && !n ? super.renderGridSkeleton(e) : e && n ? this.renderSparklineSkeleton(e) : this.removeSkeleton();
  }
  renderSparklineSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(t) {
    const e = this.backdrop.attr("width"), n = [100], s = I.appendOrSelect(this.backdrop, "g.y.skeleton"), a = s.selectAll("line").data(n);
    a.enter().append("line").merge(a).attr("x1", 0).attr("x2", e).attr("y1", (r) => r).attr("y2", (r) => r), s.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const t = this.parent;
    this.backdrop = I.appendOrSelect(t, "svg.chart-skeleton.DAII").attr(
      "role",
      "presentation"
    ), I.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class Zm extends dt {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-area"
        })
      ).attr("opacity", (a) => O(a, 0, s) !== e.datum().name ? ye.opacity.unselected : ye.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", ye.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "stacked area graphs",
      withinChartClip: !0
    }), n = this, s = this.getOptions(), { groupMapsTo: a } = s.data, r = Object.keys(s.axes).some((f) => s.axes[f].percentage), o = this.model.getStackedData({
      percentage: r,
      groups: this.configs.groups
    }), c = O(o, 0, 0), l = this.services.cartesianScales.getDomainAxisPosition({ datum: c }), h = this.services.cartesianScales.getRangeAxisPosition({ datum: c }), d = this.services.cartesianScales.getScaleByPosition(h), u = e.selectAll("path.area").data(o, (f) => O(f, 0, a));
    this.areaGenerator = Ki().x(
      (f) => this.services.cartesianScales.getValueThroughAxisPosition(
        l,
        f.data.sharedStackKey
      )
    ).y0((f) => d(f[0])).y1((f) => d(f[1])).curve(this.services.curves.getD3Curve()), u.exit().attr("opacity", 0).remove(), u.enter().append("path").attr("opacity", 0).merge(u).data(o, (f) => O(f, 0, a)).attr("class", "area").attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: O(f, 0, a),
        originalClassName: "area"
      })
    ).style("fill", (f) => n.model.getFillColor(O(f, 0, a), null, f)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (f) => O(f, 0, a)).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", ye.opacity.selected).attr("d", this.areaGenerator);
  }
}
class qm extends ea {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({ ariaLabel: "stacked bar graphs", withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: s } = n.data, a = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), r = this.model.getActiveDataGroupNames(), o = e.selectAll("g.bars").data(a, (l) => O(l, 0, s));
    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", lt.GROUP).attr("data-name", "bars");
    const c = e.selectAll("g.bars").selectAll("path.bar").data(
      (l) => l,
      (l) => l.data.sharedStackKey
    );
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: l[s],
        originalClassName: "bar"
      })
    ).style(
      "fill",
      (l) => this.model.getFillColor(l[s], l.data.sharedStackKey, l.data)
    ).attr("d", (l) => {
      const h = l.data.sharedStackKey, d = this.getBarWidth(), u = this.services.cartesianScales.getDomainValue(h) - d / 2, p = u + d, f = this.services.cartesianScales.getRangeValue(l[0]);
      let m = this.services.cartesianScales.getRangeValue(l[1]);
      if (!this.isOutsideZoomedDomain(u, p)) {
        if (Math.abs(m - f) > 0 && Math.abs(m - f) > n.bars.dividerSize) {
          const g = l[0] < 0 && l[1] <= 0;
          g && r.length > 1 ? this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? m += l[1] === 0 ? 2 : 1 : m -= 1 : g || (this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? m += 1 : m -= 1);
        }
        return Gt(
          { x0: u, x1: p, y0: f, y1: m },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l[1] - l[0]), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = O(t, "tooltip", "alwaysShowRulerTooltip"), s = this.parent.selectAll("path.bar");
    n ? s.style("pointer-events", "none") : s.style("pointer-events", null);
    const a = this;
    s.on("mouseover", function(r, o) {
      const c = D(this);
      c.classed("hovered", !0), a.services.events.dispatchEvent(b.Bar.BAR_MOUSEOVER, {
        event: r,
        element: c,
        datum: o
      });
      let h = a.model.getDisplayData(a.configs.groups).find((d) => {
        const u = a.services.cartesianScales.getDomainIdentifier(d), p = a.services.cartesianScales.getRangeIdentifier(d);
        return d[p] === o.data[o[e]] && d[u].toString() === o.data.sharedStackKey && d[e] === o[e];
      });
      if (h === void 0) {
        const d = a.services.cartesianScales.getDomainIdentifier(), u = a.services.cartesianScales.getRangeIdentifier();
        h = {
          [d]: o.data.sharedStackKey,
          [u]: o.data[o[e]],
          [e]: o[e]
        };
      }
      n || a.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: r,
        hoveredElement: c,
        data: [h]
      });
    }).on("mousemove", function(r, o) {
      const c = D(this);
      a.services.events.dispatchEvent(b.Bar.BAR_MOUSEMOVE, {
        event: r,
        element: c,
        datum: o
      }), a.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, o) {
      a.services.events.dispatchEvent(b.Bar.BAR_CLICK, {
        event: r,
        element: D(this),
        datum: o
      });
    }).on("mouseout", function(r, o) {
      const c = D(this);
      c.classed("hovered", !1), a.services.events.dispatchEvent(b.Bar.BAR_MOUSEOUT, {
        event: r,
        element: c,
        datum: o
      }), a.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: c
      });
    });
  }
  getBarWidth() {
    const t = this.getOptions();
    if (O(t, "bars", "width"))
      return t.bars.width;
    const e = this.services.cartesianScales.getMainXScale(), n = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, s = this.model.getStackKeys().length, a = O(t, "bars", "spacingFactor");
    return e.step ? Math.min(t.bars.maxWidth, e.step() / 2) : Math.min(t.bars.maxWidth, n * a / s);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class jm extends Qi {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = at.SVG;
  }
  render(t) {
    if (!O(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ ariaLabel: "scatter points", withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: a } = s.data, r = Object.keys(s.axes).some((p) => s.axes[p].percentage), o = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: r
    }), c = n.selectAll("g.dots").data(o, (p) => O(p, 0, a));
    c.exit().attr("opacity", 0).remove();
    const h = c.enter().append("g").classed("dots", !0).attr("role", lt.GROUP).merge(c).selectAll("circle.dot").data((p) => p);
    h.exit().attr("opacity", 0).remove();
    const u = h.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(h).datum((p) => {
      const f = p[a], m = this.services.cartesianScales.getDomainIdentifier(p), g = this.services.cartesianScales.getRangeIdentifier(p);
      return {
        [a]: f,
        [m]: p.data.sharedStackKey,
        [g]: p[1]
      };
    });
    this.styleCircles(u, t), this.addEventListeners();
  }
  getTooltipData(t, e) {
    const n = this.getOptions(), { groupMapsTo: s } = n.data, a = Object.keys(n.axes).some((c) => n.axes[c].percentage), r = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: a
    }), o = [];
    return r.forEach((c, l) => {
      c.forEach((h, d) => {
        const u = h[s], p = h.data.sharedStackKey;
        let f = h.data[u];
        const m = h[1], g = this.services.cartesianScales.getDomainIdentifier(h), v = this.services.cartesianScales.getRangeIdentifier(h);
        f != null && t === this.services.cartesianScales.getDomainValue(p) && e === this.services.cartesianScales.getRangeValue(m) && (a && (f = this.model.getStackedData({
          groups: this.configs.groups
        })[l][d].data[u]), f !== null && o.push({
          [s]: u,
          [g]: p,
          [v]: f
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((c) => {
      const l = this.services.cartesianScales.getDomainIdentifier(c), h = this.services.cartesianScales.getRangeIdentifier(c);
      return o.find((d) => d[s] == c[s] && d[l] == c[l] && d[h] == c[h]) !== void 0;
    });
  }
}
const Ze = 6;
class Km extends dt {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = at.SVG;
  }
  getLongestLabel(t) {
    let e = "";
    return t.forEach((n) => {
      const s = n.children ? this.getLongestLabel(n.children) : "";
      (s.length > e.length || n.name.length > e.length) && (e = s.length > n.name.length ? s : n.name);
    }), e;
  }
  getMockLabelWidth(t, e) {
    const n = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(e), { width: s } = I.getSVGElementSize(n.node(), {
      useBBox: !0
    });
    return n.remove(), s;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "tree diagram"
    });
    e.html("");
    const { width: n, height: s } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    const a = this.model.getOptions(), r = this.model.getDisplayData(), o = O(a, "tree", "rootTitle") || "Tree", c = this.getMockLabelWidth(e, o), l = this.getLongestLabel(r), h = this.getMockLabelWidth(e, l), d = {
      left: c > 0 ? c + Ze : 30 - Ze
    }, u = Nn({
      name: o,
      children: r
    }), p = 10, f = n / 6, m = (T) => {
      const C = u.descendants().reverse(), _ = u.links();
      let V = u, R = u;
      u.eachBefore((k) => {
        k.x < V.x && (V = k), k.x > R.x && (R = k);
      });
      const A = R.x - V.x, H = e.transition().call(
        (k) => this.services.transitions.setupTransition({
          transition: k,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-d.left, V.x, n, A].join(" ")), N = x.selectAll("g").data(C, (k) => k.id), M = this, L = N.enter().append("g").attr("transform", () => `translate(${T.y0},${T.x0})`).attr(
        "class",
        (k) => k.depth !== 0 && k.children && k.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(k, G) {
        M.services.events.dispatchEvent(b.Tree.NODE_MOUSEOVER, {
          event: k,
          element: D(this),
          datum: G
        });
      }).on("click", function(k, G) {
        G.depth !== 0 && (G.children = G.children ? null : G._children, m(G)), M.services.events.dispatchEvent(b.Tree.NODE_CLICK, {
          event: k,
          element: D(this),
          datum: G
        });
      }).on("mouseout", function(k, G) {
        M.services.events.dispatchEvent(b.Tree.NODE_MOUSEOUT, {
          event: k,
          element: D(this),
          datum: G
        });
      });
      L.append("circle").attr("r", 2.5).attr("class", (k) => k._children ? "parent" : "child").attr("stroke-width", 10), L.append("text").attr("dy", "0.31em").attr("x", (k) => k._children ? -Ze : Ze).attr("text-anchor", (k) => k._children ? "end" : "start").text((k) => k.data.name).clone(!0).attr("class", "text-stroke").lower(), N.merge(L).transition(H).attr("transform", (k) => `translate(${k.y},${k.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), N.exit().transition(H).remove().attr("transform", () => `translate(${T.y},${T.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const P = E.selectAll("path").data(_, (k) => k.target.id), $ = P.enter().append("path").attr("d", () => {
        const k = { x: T.x0, y: T.y0 };
        return y({ source: k, target: k });
      });
      P.merge($).transition(H).attr("d", y), P.exit().transition(H).remove().attr("d", () => {
        const k = { x: T.x, y: T.y };
        return y({ source: k, target: k });
      }), u.eachBefore((k) => {
        k.x0 = k.x, k.y0 = k.y;
      });
    }, g = u.descendants(), v = g[g.length - 1].depth, S = O(a, "tree", "type") === Ol.DENDROGRAM ? eh().size([
      s,
      n - h - v * Ze - c
    ]) : zh().nodeSize([p, f]).size([
      s,
      n - h - v * Ze - c
    ]), y = hd().x((T) => T.y).y((T) => T.x);
    u.x0 = f / 2, u.y0 = 0, u.descendants().forEach((T, C) => {
      T.id = C, T._children = T.children;
    }), S(u), e.attr("viewBox", [-d.left, -0, n, p]).style("user-select", "none");
    const E = e.append("g").attr("class", "links"), x = e.append("g").attr("class", "nodes");
    m(u);
  }
}
var mp = "#000000", vp = "#ffffff", yp = "#fcf4d6", Ep = "#fddc69", xp = "#f1c21b", Sp = "#d2a106", Tp = "#b28600", bp = "#8e6a00", Op = "#684e00", Lp = "#483700", Ap = "#302400", Mp = "#1c1500", wp = {
  10: yp,
  20: Ep,
  30: xp,
  40: Sp,
  50: Tp,
  60: bp,
  70: Op,
  80: Lp,
  90: Ap,
  100: Mp
}, Cp = "#fff2e8", kp = "#ffd9be", _p = "#ffb784", Ip = "#ff832b", Rp = "#eb6200", Dp = "#ba4e00", Np = "#8a3800", Pp = "#5e2900", $p = "#3e1a00", Vp = "#231000", Gp = {
  10: Cp,
  20: kp,
  30: _p,
  40: Ip,
  50: Rp,
  60: Dp,
  70: Np,
  80: Pp,
  90: $p,
  100: Vp
}, Hp = "#fff1f1", Bp = "#ffd7d9", zp = "#ffb3b8", Up = "#ff8389", Fp = "#fa4d56", Wp = "#da1e28", Xp = "#a2191f", Yp = "#750e13", Zp = "#520408", qp = "#2d0709", jp = {
  10: Hp,
  20: Bp,
  30: zp,
  40: Up,
  50: Fp,
  60: Wp,
  70: Xp,
  80: Yp,
  90: Zp,
  100: qp
}, Kp = "#fff0f7", Jp = "#ffd6e8", Qp = "#ffafd2", tf = "#ff7eb6", ef = "#ee5396", nf = "#d02670", sf = "#9f1853", af = "#740937", rf = "#510224", of = "#2a0a18", lf = {
  10: Kp,
  20: Jp,
  30: Qp,
  40: tf,
  50: ef,
  60: nf,
  70: sf,
  80: af,
  90: rf,
  100: of
}, cf = "#f6f2ff", uf = "#e8daff", hf = "#d4bbff", df = "#be95ff", pf = "#a56eff", ff = "#8a3ffc", gf = "#6929c4", mf = "#491d8b", vf = "#31135e", yf = "#1c0f30", Ef = {
  10: cf,
  20: uf,
  30: hf,
  40: df,
  50: pf,
  60: ff,
  70: gf,
  80: mf,
  90: vf,
  100: yf
}, xf = "#edf5ff", Sf = "#d0e2ff", Tf = "#a6c8ff", bf = "#78a9ff", Of = "#4589ff", Lf = "#0f62fe", Af = "#0043ce", Mf = "#002d9c", wf = "#001d6c", Cf = "#001141", kf = {
  10: xf,
  20: Sf,
  30: Tf,
  40: bf,
  50: Of,
  60: Lf,
  70: Af,
  80: Mf,
  90: wf,
  100: Cf
}, _f = "#e5f6ff", If = "#bae6ff", Rf = "#82cfff", Df = "#33b1ff", Nf = "#1192e8", Pf = "#0072c3", $f = "#00539a", Vf = "#003a6d", Gf = "#012749", Hf = "#061727", Bf = {
  10: _f,
  20: If,
  30: Rf,
  40: Df,
  50: Nf,
  60: Pf,
  70: $f,
  80: Vf,
  90: Gf,
  100: Hf
}, zf = "#d9fbfb", Uf = "#9ef0f0", Ff = "#3ddbd9", Wf = "#08bdba", Xf = "#009d9a", Yf = "#007d79", Zf = "#005d5d", qf = "#004144", jf = "#022b30", Kf = "#081a1c", Jf = {
  10: zf,
  20: Uf,
  30: Ff,
  40: Wf,
  50: Xf,
  60: Yf,
  70: Zf,
  80: qf,
  90: jf,
  100: Kf
}, Qf = "#defbe6", tg = "#a7f0ba", eg = "#6fdc8c", ng = "#42be65", sg = "#24a148", ig = "#198038", ag = "#0e6027", rg = "#044317", og = "#022d0d", lg = "#071908", cg = {
  10: Qf,
  20: tg,
  30: eg,
  40: ng,
  50: sg,
  60: ig,
  70: ag,
  80: rg,
  90: og,
  100: lg
}, ug = "#f2f4f8", hg = "#dde1e6", dg = "#c1c7cd", pg = "#a2a9b0", fg = "#878d96", gg = "#697077", mg = "#4d5358", vg = "#343a3f", yg = "#21272a", Eg = "#121619", xg = {
  10: ug,
  20: hg,
  30: dg,
  40: pg,
  50: fg,
  60: gg,
  70: mg,
  80: vg,
  90: yg,
  100: Eg
}, Sg = "#f4f4f4", Tg = "#e0e0e0", bg = "#c6c6c6", Og = "#a8a8a8", Lg = "#8d8d8d", Ag = "#6f6f6f", Mg = "#525252", wg = "#393939", Cg = "#262626", kg = "#161616", _g = {
  10: Sg,
  20: Tg,
  30: bg,
  40: Og,
  50: Lg,
  60: Ag,
  70: Mg,
  80: wg,
  90: Cg,
  100: kg
}, Ig = "#f7f3f2", Rg = "#e5e0df", Dg = "#cac5c4", Ng = "#ada8a8", Pg = "#8f8b8b", $g = "#726e6e", Vg = "#565151", Gg = "#3c3838", Hg = "#272525", Bg = "#171414", zg = {
  10: Ig,
  20: Rg,
  30: Dg,
  40: Ng,
  50: Pg,
  60: $g,
  70: Vg,
  80: Gg,
  90: Hg,
  100: Bg
}, $r = {
  black: {
    100: mp
  },
  blue: kf,
  coolGray: xg,
  cyan: Bf,
  gray: _g,
  green: cg,
  magenta: lf,
  orange: Gp,
  purple: Ef,
  red: jp,
  teal: Jf,
  warmGray: zg,
  white: {
    0: vp
  },
  yellow: wp
};
const Ug = (i) => {
  if (!i)
    return null;
  for (const t of Object.keys($r)) {
    const e = $r[t];
    for (const n of Object.keys(e))
      if (e[+n] === i)
        return n;
  }
  return null;
}, Vr = function(i) {
  const t = D(this.parentNode).select("rect.leaf"), e = i.backgroundColor ?? getComputedStyle(t.node(), null).getPropertyValue("fill"), n = Zr(e);
  let s;
  if (n && (s = Ug(n ? n.hex() : null)), s == null) {
    const a = Sl(n).l;
    s = Math.abs(a * 100 - 100);
  }
  return s > 50 ? "white" : "black";
};
let Fg = 0;
class Jm extends dt {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (n) => n.parent.data.name === e.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "treemap"
    });
    this.model.getData();
    const n = this.model.getDisplayData(), s = this.model.getOptions(), a = O(window, "location"), { width: r, height: o } = I.getSVGElementSize(e, {
      useAttrs: !0
    }), c = Nn({
      name: s.title || "Treemap",
      children: n
    }).sum((m) => m.value).sort((m, g) => g.value - m.value), l = Yh().size([r, o]).paddingInner(1).paddingOuter(0).round(!0)(
      c
    ), h = e.selectAll("g[data-name='leaf']").data(l.leaves(), (m) => m.data.name);
    h.exit().attr("opacity", 0).remove();
    const u = h.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => Fg++).merge(h);
    u.attr("data-name", "leaf").transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "treemap-group-update",
        animate: t
      })
    ).attr("transform", (m) => `translate(${m.x0},${m.y0})`);
    const p = u.selectAll("rect.leaf").data((m) => [m]);
    p.exit().attr("width", 0).attr("height", 0).remove(), p.enter().append("rect").classed("leaf", !0).merge(p).attr("width", 0).attr("height", 0).attr("id", function() {
      const m = D(this.parentNode).attr("data-uid");
      return `${s.style.prefix}-leaf-${m}`;
    }).attr("class", (m) => {
      for (; m.depth > 1; ) m = m.parent;
      return this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: m.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "treemap-leaf-update-enter",
        animate: t
      })
    ).attr("width", (m) => m.x1 - m.x0).attr("height", (m) => m.y1 - m.y0).style("fill", (m) => {
      for (; m.depth > 1; ) m = m.parent;
      return this.model.getFillColor(m.data.name, null, m.data);
    }), u.selectAll("clipPath").data(
      (m) => m.data.showLabel !== !0 ? [] : [1],
      (m) => m
    ).join(
      (m) => m.append("clipPath").attr("id", function() {
        const g = D(this.parentNode).attr("data-uid");
        return `${s.style.prefix}-clip-${g}`;
      }).append("use").attr("xlink:href", function() {
        const g = D(this.parentNode.parentNode).attr("data-uid"), v = `${s.style.prefix}-leaf-${g}`;
        return new URL(`#${v}`, a) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (m) => null,
      (m) => m.remove()
    ), u.selectAll("text").data(
      (m) => {
        if (m.data.showLabel !== !0)
          return [];
        let g = m;
        for (; g.depth > 1; ) g = g.parent;
        return [
          {
            text: m.data.name,
            backgroundColor: this.model.getFillColor(g.data.name)
          }
        ];
      },
      (m) => m
    ).join(
      (m) => {
        const g = m.append("text").text((v) => v.text).style("fill", Vr).attr("x", 7).attr("y", 18);
        return a && g.attr("clip-path", function() {
          const v = D(this.parentNode).attr("data-uid"), S = `${s.style.prefix}-clip-${v}`;
          return `url(${new URL(`#${S}`, a) + ""})`;
        }), g;
      },
      (m) => m.text((g) => g.text).style("fill", Vr),
      (m) => m.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(e, n) {
      const s = D(this);
      let a = getComputedStyle(this, null).getPropertyValue("fill"), r = n;
      for (; r.depth > 1; ) r = r.parent;
      s.transition("graph_element_mouseover_fill_update").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (o) => {
        const c = t.model.getFillColor(o.parent.data.name, null, o.data);
        return c && (a = c), Zr(a).darker(0.7).toString();
      }), t.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: e,
        hoveredElement: s,
        items: [
          {
            color: a,
            label: r.data.name,
            bold: !0
          },
          {
            label: n.data.name,
            value: n.data.value
          }
        ]
      }), t.services.events.dispatchEvent(b.Treemap.LEAF_MOUSEOVER, {
        event: e,
        element: s,
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(b.Treemap.LEAF_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(b.Treemap.LEAF_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      s.classed("hovered", !1);
      let a = n;
      for (; a.depth > 1; ) a = a.parent;
      s.transition().call(
        (r) => t.services.transitions.setupTransition({
          transition: r,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (r) => t.model.getFillColor(r.parent.data.name, null, r.data)), t.services.events.dispatchEvent(b.Treemap.LEAF_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
}
function Wg(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function Xg(i) {
  if (Object.prototype.hasOwnProperty.call(i, "__esModule")) return i;
  var t = i.default;
  if (typeof t == "function") {
    var e = function n() {
      var s = !1;
      try {
        s = this instanceof n;
      } catch {
      }
      return s ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(i).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(i, n);
    Object.defineProperty(e, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return i[n];
      }
    });
  }), e;
}
var Yg = { value: function() {
} };
function Qo() {
  for (var i = 0, t = arguments.length, e = {}, n; i < t; ++i) {
    if (!(n = arguments[i] + "") || n in e || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    e[n] = [];
  }
  return new us(e);
}
function us(i) {
  this._ = i;
}
function Zg(i, t) {
  return i.trim().split(/^|\s+/).map(function(e) {
    var n = "", s = e.indexOf(".");
    if (s >= 0 && (n = e.slice(s + 1), e = e.slice(0, s)), e && !t.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    return { type: e, name: n };
  });
}
us.prototype = Qo.prototype = {
  constructor: us,
  on: function(i, t) {
    var e = this._, n = Zg(i + "", e), s, a = -1, r = n.length;
    if (arguments.length < 2) {
      for (; ++a < r; ) if ((s = (i = n[a]).type) && (s = qg(e[s], i.name))) return s;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++a < r; )
      if (s = (i = n[a]).type) e[s] = Gr(e[s], i.name, t);
      else if (t == null) for (s in e) e[s] = Gr(e[s], i.name, null);
    return this;
  },
  copy: function() {
    var i = {}, t = this._;
    for (var e in t) i[e] = t[e].slice();
    return new us(i);
  },
  call: function(i, t) {
    if ((s = arguments.length - 2) > 0) for (var e = new Array(s), n = 0, s, a; n < s; ++n) e[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    for (a = this._[i], n = 0, s = a.length; n < s; ++n) a[n].value.apply(t, e);
  },
  apply: function(i, t, e) {
    if (!this._.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    for (var n = this._[i], s = 0, a = n.length; s < a; ++s) n[s].value.apply(t, e);
  }
};
function qg(i, t) {
  for (var e = 0, n = i.length, s; e < n; ++e)
    if ((s = i[e]).name === t)
      return s.value;
}
function Gr(i, t, e) {
  for (var n = 0, s = i.length; n < s; ++n)
    if (i[n].name === t) {
      i[n] = Yg, i = i.slice(0, n).concat(i.slice(n + 1));
      break;
    }
  return e != null && i.push({ name: t, value: e }), i;
}
const jg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispatch: Qo
}, Symbol.toStringTag, { value: "Module" })), Kg = /* @__PURE__ */ Xg(jg);
var hi, Hr;
function Jg() {
  if (Hr) return hi;
  Hr = 1;
  const i = Kg.dispatch, t = Math.PI / 180, e = {
    archimedean: m,
    rectangular: g
  }, n = 64, s = 2048;
  hi = function() {
    var E = [256, 256], x = a, T = r, C = c, _ = o, V = o, R = l, A = h, H = m, N = [], M = 1 / 0, L = i("word", "end"), P = null, $ = Math.random, k = {}, G = S;
    k.canvas = function(F) {
      return arguments.length ? (G = y(F), k) : G;
    }, k.start = function() {
      var F = q(G()), Z = v((E[0] >> 5) * E[1]), rt = null, j = N.length, Y = -1, K = [], ot = N.map(function(st, it) {
        return st.text = x.call(this, st, it), st.font = T.call(this, st, it), st.style = _.call(this, st, it), st.weight = V.call(this, st, it), st.rotate = R.call(this, st, it), st.size = ~~C.call(this, st, it), st.padding = A.call(this, st, it), st;
      }).sort(function(st, it) {
        return it.size - st.size;
      });
      return P && clearInterval(P), P = setInterval(ct, 0), ct(), k;
      function ct() {
        for (var st = Date.now(); Date.now() - st < M && ++Y < j && P; ) {
          var it = ot[Y];
          it.x = E[0] * ($() + 0.5) >> 1, it.y = E[1] * ($() + 0.5) >> 1, d(F, it, ot, Y), it.hasText && X(Z, it, rt) && (K.push(it), L.call("word", k, it), rt ? p(rt, it) : rt = [{ x: it.x + it.x0, y: it.y + it.y0 }, { x: it.x + it.x1, y: it.y + it.y1 }], it.x -= E[0] >> 1, it.y -= E[1] >> 1);
        }
        Y >= j && (k.stop(), L.call("end", k, K, rt));
      }
    }, k.stop = function() {
      P && (clearInterval(P), P = null);
      for (const F of N)
        delete F.sprite;
      return k;
    };
    function q(F) {
      const Z = F.getContext("2d", { willReadFrequently: !0 });
      F.width = F.height = 1;
      const rt = Math.sqrt(Z.getImageData(0, 0, 1, 1).data.length >> 2);
      return F.width = (n << 5) / rt, F.height = s / rt, Z.fillStyle = Z.strokeStyle = "red", { context: Z, ratio: rt };
    }
    function X(F, Z, rt) {
      E[0], E[1];
      for (var j = Z.x, Y = Z.y, K = Math.sqrt(E[0] * E[0] + E[1] * E[1]), ot = H(E), ct = $() < 0.5 ? 1 : -1, st = -ct, it, z, B; (it = ot(st += ct)) && (z = ~~it[0], B = ~~it[1], !(Math.min(Math.abs(z), Math.abs(B)) >= K)); )
        if (Z.x = j + z, Z.y = Y + B, !(Z.x + Z.x0 < 0 || Z.y + Z.y0 < 0 || Z.x + Z.x1 > E[0] || Z.y + Z.y1 > E[1]) && (!rt || f(Z, rt)) && !u(Z, F, E[0])) {
          for (var U = Z.sprite, wt = Z.width >> 5, Te = E[0] >> 5, et = Z.x - (wt << 4), yt = et & 127, Zt = 32 - yt, Wt = Z.y1 - Z.y0, ln = (Z.y + Z.y0) * Te + (et >> 5), cn, Le = 0; Le < Wt; Le++) {
            cn = 0;
            for (var ne = 0; ne <= wt; ne++)
              F[ln + ne] |= cn << Zt | (ne < wt ? (cn = U[Le * wt + ne]) >>> yt : 0);
            ln += Te;
          }
          return !0;
        }
      return !1;
    }
    return k.timeInterval = function(F) {
      return arguments.length ? (M = F ?? 1 / 0, k) : M;
    }, k.words = function(F) {
      return arguments.length ? (N = F, k) : N;
    }, k.size = function(F) {
      return arguments.length ? (E = [+F[0], +F[1]], k) : E;
    }, k.font = function(F) {
      return arguments.length ? (T = y(F), k) : T;
    }, k.fontStyle = function(F) {
      return arguments.length ? (_ = y(F), k) : _;
    }, k.fontWeight = function(F) {
      return arguments.length ? (V = y(F), k) : V;
    }, k.rotate = function(F) {
      return arguments.length ? (R = y(F), k) : R;
    }, k.text = function(F) {
      return arguments.length ? (x = y(F), k) : x;
    }, k.spiral = function(F) {
      return arguments.length ? (H = e[F] || F, k) : H;
    }, k.fontSize = function(F) {
      return arguments.length ? (C = y(F), k) : C;
    }, k.padding = function(F) {
      return arguments.length ? (A = y(F), k) : A;
    }, k.random = function(F) {
      return arguments.length ? ($ = F, k) : $;
    }, k.on = function() {
      var F = L.on.apply(L, arguments);
      return F === L ? k : F;
    }, k;
  };
  function a(E) {
    return E.text;
  }
  function r() {
    return "serif";
  }
  function o() {
    return "normal";
  }
  function c(E) {
    return Math.sqrt(E.value);
  }
  function l() {
    return (~~(random() * 6) - 3) * 30;
  }
  function h() {
    return 1;
  }
  function d(E, x, T, C) {
    if (!x.sprite) {
      var _ = E.context, V = E.ratio;
      _.clearRect(0, 0, (n << 5) / V, s / V);
      var R = 0, A = 0, H = 0, N = T.length;
      for (--C; ++C < N; ) {
        x = T[C], _.save(), _.font = x.style + " " + x.weight + " " + ~~((x.size + 1) / V) + "px " + x.font;
        const it = _.measureText(x.text), z = -Math.floor(it.width / 2);
        let B = (it.width + 1) * V, U = x.size << 1;
        if (x.rotate) {
          var M = Math.sin(x.rotate * t), L = Math.cos(x.rotate * t), P = B * L, $ = B * M, k = U * L, G = U * M;
          B = Math.max(Math.abs(P + G), Math.abs(P - G)) + 31 >> 5 << 5, U = ~~Math.max(Math.abs($ + k), Math.abs($ - k));
        } else
          B = B + 31 >> 5 << 5;
        if (U > H && (H = U), R + B >= n << 5 && (R = 0, A += H, H = 0), A + U >= s) break;
        _.translate((R + (B >> 1)) / V, (A + (U >> 1)) / V), x.rotate && _.rotate(x.rotate * t), _.fillText(x.text, z, 0), x.padding && (_.lineWidth = 2 * x.padding, _.strokeText(x.text, z, 0)), _.restore(), x.width = B, x.height = U, x.xoff = R, x.yoff = A, x.x1 = B >> 1, x.y1 = U >> 1, x.x0 = -x.x1, x.y0 = -x.y1, x.hasText = !0, R += B;
      }
      for (var q = _.getImageData(0, 0, (n << 5) / V, s / V).data, X = []; --C >= 0; )
        if (x = T[C], !!x.hasText) {
          for (var F = x.width, Z = F >> 5, rt = x.y1 - x.y0, j = 0; j < rt * Z; j++) X[j] = 0;
          if (R = x.xoff, R == null) return;
          A = x.yoff;
          for (var Y = 0, K = -1, ot = 0; ot < rt; ot++) {
            for (var j = 0; j < F; j++) {
              var ct = Z * ot + (j >> 5), st = q[(A + ot) * (n << 5) + (R + j) << 2] ? 1 << 31 - j % 32 : 0;
              X[ct] |= st, Y |= st;
            }
            Y ? K = ot : (x.y0++, rt--, ot--, A++);
          }
          x.y1 = x.y0 + K, x.sprite = X.slice(0, (x.y1 - x.y0) * Z);
        }
    }
  }
  function u(E, x, T) {
    T >>= 5;
    for (var C = E.sprite, _ = E.width >> 5, V = E.x - (_ << 4), R = V & 127, A = 32 - R, H = E.y1 - E.y0, N = (E.y + E.y0) * T + (V >> 5), M, L = 0; L < H; L++) {
      M = 0;
      for (var P = 0; P <= _; P++)
        if ((M << A | (P < _ ? (M = C[L * _ + P]) >>> R : 0)) & x[N + P]) return !0;
      N += T;
    }
    return !1;
  }
  function p(E, x) {
    var T = E[0], C = E[1];
    x.x + x.x0 < T.x && (T.x = x.x + x.x0), x.y + x.y0 < T.y && (T.y = x.y + x.y0), x.x + x.x1 > C.x && (C.x = x.x + x.x1), x.y + x.y1 > C.y && (C.y = x.y + x.y1);
  }
  function f(E, x) {
    return E.x + E.x1 > x[0].x && E.x + E.x0 < x[1].x && E.y + E.y1 > x[0].y && E.y + E.y0 < x[1].y;
  }
  function m(E) {
    var x = E[0] / E[1];
    return function(T) {
      return [x * (T *= 0.1) * Math.cos(T), T * Math.sin(T)];
    };
  }
  function g(E) {
    var x = 4, T = x * E[0] / E[1], C = 0, _ = 0;
    return function(V) {
      var R = V < 0 ? -1 : 1;
      switch (Math.sqrt(1 + 4 * R * V) - R & 3) {
        case 0:
          C += T;
          break;
        case 1:
          _ += x;
          break;
        case 2:
          C -= T;
          break;
        default:
          _ -= x;
          break;
      }
      return [C, _];
    };
  }
  function v(E) {
    for (var x = [], T = -1; ++T < E; ) x[T] = 0;
    return x;
  }
  function S() {
    return document.createElement("canvas");
  }
  function y(E) {
    return typeof E == "function" ? E : function() {
      return E;
    };
  }
  return hi;
}
var Qg = Jg();
const tm = /* @__PURE__ */ Wg(Qg);
class Qm extends dt {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(b.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(b.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer({
      ariaLabel: "word cloud"
    }).attr("width", "100%").attr("height", "100%"), s = this.model.getDisplayData(), a = this.getFontSizeScale(s), r = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: c } = r.wordCloud, { groupMapsTo: l } = r.data, { width: h, height: d } = I.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (h === 0 || d === 0)
      return;
    const u = tm().size([h, d]).words(
      s.map(function(f) {
        const m = f[o];
        if (typeof f[o] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [l]: f[l],
          text: f[c],
          size: m,
          value: m
        };
      })
    ).padding(5).rotate(0).fontSize((f) => a(f.size)).on("end", p);
    u.start();
    function p(f) {
      const m = I.appendOrSelect(n, "g.words");
      m.attr("transform", `translate(${u.size()[0] / 2}, ${u.size()[1] / 2})`);
      const g = m.selectAll("text").data(f, (S) => `${S[l]}-${S.text}`);
      g.exit().attr("opacity", 0).remove(), g.enter().append("text").attr("opacity", 0).merge(g).style("font-size", (S) => `${S.size}px`).text(function(S) {
        return S.text;
      }).attr(
        "class",
        (S) => e.model.getColorClassName({
          classNameTypes: [nt.FILL],
          dataGroupName: S[l],
          originalClassName: `word ${S.size > 32 ? "light" : ""}`
        })
      ).style("fill", (S) => e.model.getFillColor(S[l], S.text, S)).attr("text-anchor", "middle").transition().call(
        (S) => e.services.transitions.setupTransition({
          transition: S,
          name: "wordcloud-text-update-enter",
          animate: t
        })
      ).attr("transform", (S) => `translate(${S.x}, ${S.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(t) {
    const e = this.getOptions(), { fontSizeMapsTo: n } = e.wordCloud, s = t.map((c) => c[n]).filter((c) => c), a = I.getHTMLElementSize(this.services.domUtils.getMainContainer()), r = s.length > 0, o = r ? Ls(s) : [1, 1];
    return Re().domain(o).range(r ? e.wordCloud.fontSizeRange(a, t) : [4, 4]);
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this, s = gi((a) => {
      const r = n.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (o) => n.services.transitions.setupTransition({
          transition: o,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      a === null ? r.attr("opacity", 1) : r.attr("opacity", function() {
        return a === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(a, r) {
      const o = this;
      s(o), n.services.events.dispatchEvent(b.WordCloud.WORD_MOUSEOVER, {
        event: a,
        element: D(this),
        datum: r
      }), n.services.events.dispatchEvent(b.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        items: [
          {
            label: t.tooltip.wordLabel,
            value: r.text
          },
          {
            label: t.tooltip.valueLabel,
            value: r.value
          },
          {
            label: Et(t, "locale.translations.group") || Et(t, "tooltip.groupLabel") || "Group",
            value: r[e],
            class: n.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP],
              dataGroupName: r[e]
            })
          }
        ]
      });
    }).on("mousemove", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(b.WordCloud.WORD_MOUSEMOVE, {
        element: o,
        datum: r
      }), n.services.events.dispatchEvent(b.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      n.services.events.dispatchEvent(b.WordCloud.WORD_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      s(null), n.services.events.dispatchEvent(b.WordCloud.WORD_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), n.services.events.dispatchEvent(b.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class em extends dt {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = at.SVG;
  }
  render() {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: e, height: n } = I.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (e < 1 || n < 1)
      return;
    const s = this.getProjection(), a = O(this.getOptions(), "geoData"), r = this.model.getCombinedData(), o = {}, c = {};
    Object.keys(r).forEach((v) => {
      typeof r[v].value == "number" ? o[v] = r[v] : c[v] = r[v];
    });
    const l = dp(a, Object.values(c)), h = cp(a, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(o)
    }), d = s.fitSize([e, n], h), u = Mu().projection(d);
    I.appendOrSelect(t, "g.geo").selectAll("path").data(h.features).join("path").attr("d", u);
    const f = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), m = I.appendOrSelect(t, "defs");
    I.appendOrSelect(m, "pattern").attr("id", f).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      Pn()([
        [0, 0],
        [0, 10]
      ])
    );
    const g = I.appendOrSelect(t, "g.missing-data");
    I.appendOrSelect(g, "path").datum(l).attr("d", u).style("fill", `url(#${f})`);
  }
  /**
   * Retrieves the D3 geographic projection based on the options provided.
   *
   * This method selects a geographic projection from the available D3 projections
   * based on the `projection` property in the `thematic` options. If the projection
   * is not supported or is missing, an error is thrown.
   *
   * @returns {d3.GeoProjection} - The D3 geographic projection corresponding to the selected option.
   * @throws {Error} If the projection is not supported or is missing.
   */
  getProjection() {
    let t = null;
    switch (O(this.getOptions(), "thematic", "projection")) {
      // Azimuthal Projections
      case we.geoEqualEarth:
        t = Xu();
        break;
      // Conic Projections
      case we.geoAlbers:
        t = Gu();
        break;
      case we.geoConicEqualArea:
        t = Po();
        break;
      case we.geoConicEquidistant:
        t = Fu();
        break;
      // Cyndrical projections
      case we.geoEquirectangular:
        t = zu();
        break;
      case we.geoMercator:
        t = Hu();
        break;
      case we.geoNaturalEarth1:
        t = Yu();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return t;
  }
}
class tv extends em {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    super.render();
    const e = this.model.getCombinedData(), n = this.getComponentContainer({ ariaLabel: "map", withinChartClip: !0 }), s = O(this.getOptions(), "color"), a = O(s, "gradient", "colors");
    n.select("g.geo").selectAll("path").classed("border", !0).attr("class", (o) => this.model.getColorClassName({
      value: e[o.properties.NAME].value,
      originalClassName: "border"
    })).attr("style", (o) => a ? `fill: ${this.model.getColorClassName({
      value: e[o.properties.NAME].value
    })}` : null), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const t = this, e = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(Fn.CHOROPLETH_MOUSEOVER, {
        event: n,
        element: a,
        datum: e[s.properties.NAME]
      }), t.services.events.dispatchEvent(Us.SHOW, {
        event: n,
        hoveredElement: a,
        items: [
          {
            label: s.properties.NAME,
            value: e[s.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(n, s) {
      t.services.events.dispatchEvent(Fn.CHOROPLETH_MOUSEMOVE, {
        event: n,
        element: D(this),
        datum: e[s.properties.NAME]
      }), t.services.events.dispatchEvent(Us.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      t.services.events.dispatchEvent(Fn.CHOROPLETH_CLICK, {
        event: n,
        element: D(this),
        datum: e[s.properties.NAME]
      });
    }).on("mouseout", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(Fn.CHOROPLETH_MOUSEOUT, {
        event: n,
        element: a,
        datum: e[s.properties.NAME]
      }), t.services.events.dispatchEvent(Us.HIDE, {
        event: n,
        hoveredElement: a
      });
    });
  }
}
export {
  km as $,
  fm as A,
  xm as B,
  um as C,
  Vm as D,
  Bm as E,
  Om as F,
  mm as G,
  pm as H,
  zm as I,
  Ym as J,
  Um as K,
  Nd as L,
  cm as M,
  Pm as N,
  Fm as O,
  gp as P,
  Wm as Q,
  Ko as R,
  lm as S,
  Dd as T,
  Km as U,
  Jm as V,
  Qm as W,
  Jo as X,
  ip as Y,
  hm as Z,
  Cm as _,
  Tr as a,
  wm as a0,
  Mm as a1,
  Am as a2,
  _m as a3,
  Im as a4,
  Rm as a5,
  Dm as a6,
  em as a7,
  ea as a8,
  dt as a9,
  br as b,
  xc as c,
  $d as d,
  Pd as e,
  Ar as f,
  dm as g,
  gm as h,
  Em as i,
  ym as j,
  vm as k,
  Qi as l,
  ap as m,
  Sm as n,
  Tm as o,
  bm as p,
  Nm as q,
  tv as r,
  $m as s,
  qm as t,
  Lm as u,
  Hm as v,
  Xm as w,
  Zm as x,
  jm as y,
  Gm as z
};
//# sourceMappingURL=choropleth-CKAPopp2.mjs.map
