import { a3 as Lt, aD as Nt, aE as Ct, aF as It, aG as ut, aH as Zt, aI as Ft, aJ as zt, a0 as Vt, aK as Ht, aL as Yt, aM as Xt, aN as Gt, _ as $t, W as Ut, ay as j, aO as Kt, aP as jt, n as q, g as c, F as W, aQ as v, aR as M, aS as E, aT as qt, aU as ft, aV as pt, h as J, as as Wt, ap as Jt, ad as mt, aj as Qt, H as ti } from "./color-scale-utils-BzjNNGXE.mjs";
import { z as ii, A, e as Q, S as O, D as ni, s as ei, v as si, x as oi, y as ai, u as ri } from "./angle-utils-jnw9HSFu.mjs";
import { $ as w, e as _, i as C, S as p } from "./axis-scales-CPuwbFQf.mjs";
function dt(i) {
  var t = i == null ? 0 : i.length;
  return t ? Lt(i, 1) : [];
}
function hi(i) {
  return Nt(Ct(i, void 0, dt), i + "");
}
function ci(i, t, n) {
  var e = -1, s = i.length;
  t < 0 && (t = -t > s ? 0 : s + t), n = n > s ? s : n, n < 0 && (n += s), s = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var o = Array(s); ++e < s; )
    o[e] = i[e + t];
  return o;
}
function li(i, t) {
  return t.length < 2 ? i : It(i, ci(t, 0, -1));
}
function _i(i, t) {
  return t = ut(t, i), i = li(i, t), i == null || delete i[Zt(Ft(t))];
}
function ui(i) {
  return zt(i) ? void 0 : i;
}
var fi = 1, pi = 2, mi = 4, di = hi(function(i, t) {
  var n = {};
  if (i == null)
    return n;
  var e = !1;
  t = Vt(t, function(o) {
    return o = ut(o, i), e || (e = o.length > 1), o;
  }), Ht(i, Yt(i), n), e && (n = Xt(n, fi | pi | mi, ui));
  for (var s = t.length; s--; )
    _i(n, t[s]);
  return n;
});
function tt(i) {
  return Math.log(i);
}
function it(i) {
  return Math.exp(i);
}
function xi(i) {
  return -Math.log(-i);
}
function gi(i) {
  return -Math.exp(-i);
}
function yi(i) {
  return isFinite(i) ? +("1e" + i) : i < 0 ? 0 : i;
}
function vi(i) {
  return i === 10 ? yi : i === Math.E ? Math.exp : (t) => Math.pow(i, t);
}
function Ti(i) {
  return i === Math.E ? Math.log : i === 10 && Math.log10 || i === 2 && Math.log2 || (i = Math.log(i), (t) => Math.log(t) / i);
}
function nt(i) {
  return (t, n) => -i(-t, n);
}
function Di(i) {
  const t = i(tt, it), n = t.domain;
  let e = 10, s, o;
  function a() {
    return s = Ti(e), o = vi(e), n()[0] < 0 ? (s = nt(s), o = nt(o), i(xi, gi)) : i(tt, it), t;
  }
  return t.base = function(r) {
    return arguments.length ? (e = +r, a()) : e;
  }, t.domain = function(r) {
    return arguments.length ? (n(r), a()) : n();
  }, t.ticks = (r) => {
    const h = n();
    let l = h[0], f = h[h.length - 1];
    const y = f < l;
    y && ([l, f] = [f, l]);
    let d = s(l), T = s(f), g, m;
    const D = r == null ? 10 : +r;
    let u = [];
    if (!(e % 1) && T - d < D) {
      if (d = Math.floor(d), T = Math.ceil(T), l > 0) {
        for (; d <= T; ++d)
          for (g = 1; g < e; ++g)
            if (m = d < 0 ? g / o(-d) : g * o(d), !(m < l)) {
              if (m > f) break;
              u.push(m);
            }
      } else for (; d <= T; ++d)
        for (g = e - 1; g >= 1; --g)
          if (m = d > 0 ? g / o(-d) : g * o(d), !(m < l)) {
            if (m > f) break;
            u.push(m);
          }
      u.length * 2 < D && (u = j(l, f, D));
    } else
      u = j(d, T, Math.min(T - d, D)).map(o);
    return y ? u.reverse() : u;
  }, t.tickFormat = (r, h) => {
    if (r == null && (r = 10), h == null && (h = e === 10 ? "s" : ","), typeof h != "function" && (!(e % 1) && (h = Kt(h)).precision == null && (h.trim = !0), h = jt(h)), r === 1 / 0) return h;
    const l = Math.max(1, e * r / t.ticks().length);
    return (f) => {
      let y = f / o(Math.round(s(f)));
      return y * e < e - 0.5 && (y *= e), y <= l ? h(f) : "";
    };
  }, t.nice = () => n(ii(n(), {
    floor: (r) => o(Math.floor(s(r))),
    ceil: (r) => o(Math.ceil(s(r)))
  })), t;
}
function xt() {
  const i = Di(Gt()).domain([1, 10]);
  return i.copy = () => $t(i, xt()).base(i.base()), Ut.apply(i, arguments), i;
}
function k(i, t, n) {
  i._context.bezierCurveTo(
    (2 * i._x0 + i._x1) / 3,
    (2 * i._y0 + i._y1) / 3,
    (i._x0 + 2 * i._x1) / 3,
    (i._y0 + 2 * i._y1) / 3,
    (i._x0 + 4 * i._x1 + t) / 6,
    (i._y0 + 4 * i._y1 + n) / 6
  );
}
function L(i) {
  this._context = i;
}
L.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        k(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        k(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t;
  }
};
function Oi(i) {
  return new L(i);
}
function gt(i) {
  this._context = i;
}
gt.prototype = {
  areaStart: A,
  areaEnd: A,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = i, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = i, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = i, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + i) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        k(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t;
  }
};
function Ai(i) {
  return new gt(i);
}
function yt(i) {
  this._context = i;
}
yt.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + i) / 6, e = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, e) : this._context.moveTo(n, e);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        k(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t;
  }
};
function Mi(i) {
  return new yt(i);
}
function vt(i, t) {
  this._basis = new L(i), this._beta = t;
}
vt.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var i = this._x, t = this._y, n = i.length - 1;
    if (n > 0)
      for (var e = i[0], s = t[0], o = i[n] - e, a = t[n] - s, r = -1, h; ++r <= n; )
        h = r / n, this._basis.point(
          this._beta * i[r] + (1 - this._beta) * (e + h * o),
          this._beta * t[r] + (1 - this._beta) * (s + h * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(i, t) {
    this._x.push(+i), this._y.push(+t);
  }
};
const bi = function i(t) {
  function n(e) {
    return t === 1 ? new L(e) : new vt(e, t);
  }
  return n.beta = function(e) {
    return i(+e);
  }, n;
}(0.85);
function R(i, t, n) {
  i._context.bezierCurveTo(
    i._x1 + i._k * (i._x2 - i._x0),
    i._y1 + i._k * (i._y2 - i._y0),
    i._x2 + i._k * (i._x1 - t),
    i._y2 + i._k * (i._y1 - n),
    i._x2,
    i._y2
  );
}
function z(i, t) {
  this._context = i, this._k = (1 - t) / 6;
}
z.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        R(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2, this._x1 = i, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        R(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Si = function i(t) {
  function n(e) {
    return new z(e, t);
  }
  return n.tension = function(e) {
    return i(+e);
  }, n;
}(0);
function V(i, t) {
  this._context = i, this._k = (1 - t) / 6;
}
V.prototype = {
  areaStart: A,
  areaEnd: A,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = i, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = i, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = i, this._y5 = t;
        break;
      default:
        R(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Pi = function i(t) {
  function n(e) {
    return new V(e, t);
  }
  return n.tension = function(e) {
    return i(+e);
  }, n;
}(0);
function H(i, t) {
  this._context = i, this._k = (1 - t) / 6;
}
H.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        R(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Ei = function i(t) {
  function n(e) {
    return new H(e, t);
  }
  return n.tension = function(e) {
    return i(+e);
  }, n;
}(0);
function Y(i, t, n) {
  var e = i._x1, s = i._y1, o = i._x2, a = i._y2;
  if (i._l01_a > Q) {
    var r = 2 * i._l01_2a + 3 * i._l01_a * i._l12_a + i._l12_2a, h = 3 * i._l01_a * (i._l01_a + i._l12_a);
    e = (e * r - i._x0 * i._l12_2a + i._x2 * i._l01_2a) / h, s = (s * r - i._y0 * i._l12_2a + i._y2 * i._l01_2a) / h;
  }
  if (i._l23_a > Q) {
    var l = 2 * i._l23_2a + 3 * i._l23_a * i._l12_a + i._l12_2a, f = 3 * i._l23_a * (i._l23_a + i._l12_a);
    o = (o * l + i._x1 * i._l23_2a - t * i._l12_2a) / f, a = (a * l + i._y1 * i._l23_2a - n * i._l12_2a) / f;
  }
  i._context.bezierCurveTo(e, s, o, a, i._x2, i._y2);
}
function Tt(i, t) {
  this._context = i, this._alpha = t;
}
Tt.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    if (i = +i, t = +t, this._point) {
      var n = this._x2 - i, e = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + e * e, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        Y(this, i, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const wi = function i(t) {
  function n(e) {
    return t ? new Tt(e, t) : new z(e, 0);
  }
  return n.alpha = function(e) {
    return i(+e);
  }, n;
}(0.5);
function Dt(i, t) {
  this._context = i, this._alpha = t;
}
Dt.prototype = {
  areaStart: A,
  areaEnd: A,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(i, t) {
    if (i = +i, t = +t, this._point) {
      var n = this._x2 - i, e = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + e * e, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = i, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = i, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = i, this._y5 = t;
        break;
      default:
        Y(this, i, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const ki = function i(t) {
  function n(e) {
    return t ? new Dt(e, t) : new V(e, 0);
  }
  return n.alpha = function(e) {
    return i(+e);
  }, n;
}(0.5);
function Ot(i, t) {
  this._context = i, this._alpha = t;
}
Ot.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    if (i = +i, t = +t, this._point) {
      var n = this._x2 - i, e = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + e * e, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Y(this, i, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Ri = function i(t) {
  function n(e) {
    return t ? new Ot(e, t) : new H(e, 0);
  }
  return n.alpha = function(e) {
    return i(+e);
  }, n;
}(0.5);
function et(i) {
  return i < 0 ? -1 : 1;
}
function st(i, t, n) {
  var e = i._x1 - i._x0, s = t - i._x1, o = (i._y1 - i._y0) / (e || s < 0 && -0), a = (n - i._y1) / (s || e < 0 && -0), r = (o * s + a * e) / (e + s);
  return (et(o) + et(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(r)) || 0;
}
function ot(i, t) {
  var n = i._x1 - i._x0;
  return n ? (3 * (i._y1 - i._y0) / n - t) / 2 : t;
}
function I(i, t, n) {
  var e = i._x0, s = i._y0, o = i._x1, a = i._y1, r = (o - e) / 3;
  i._context.bezierCurveTo(e + r, s + r * t, o - r, a - r * n, o, a);
}
function B(i) {
  this._context = i;
}
B.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        I(this, this._t0, ot(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    var n = NaN;
    if (i = +i, t = +t, !(i === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, I(this, ot(this, n = st(this, i, t)), n);
          break;
        default:
          I(this, this._t0, n = st(this, i, t));
          break;
      }
      this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function At(i) {
  this._context = new Mt(i);
}
(At.prototype = Object.create(B.prototype)).point = function(i, t) {
  B.prototype.point.call(this, t, i);
};
function Mt(i) {
  this._context = i;
}
Mt.prototype = {
  moveTo: function(i, t) {
    this._context.moveTo(t, i);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(i, t) {
    this._context.lineTo(t, i);
  },
  bezierCurveTo: function(i, t, n, e, s, o) {
    this._context.bezierCurveTo(t, i, e, n, o, s);
  }
};
function Bi(i) {
  return new B(i);
}
function Li(i) {
  return new At(i);
}
function bt(i) {
  this._context = i;
}
bt.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var i = this._x, t = this._y, n = i.length;
    if (n)
      if (this._line ? this._context.lineTo(i[0], t[0]) : this._context.moveTo(i[0], t[0]), n === 2)
        this._context.lineTo(i[1], t[1]);
      else
        for (var e = at(i), s = at(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(e[0][o], s[0][o], e[1][o], s[1][o], i[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(i, t) {
    this._x.push(+i), this._y.push(+t);
  }
};
function at(i) {
  var t, n = i.length - 1, e, s = new Array(n), o = new Array(n), a = new Array(n);
  for (s[0] = 0, o[0] = 2, a[0] = i[0] + 2 * i[1], t = 1; t < n - 1; ++t) s[t] = 1, o[t] = 4, a[t] = 4 * i[t] + 2 * i[t + 1];
  for (s[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * i[n - 1] + i[n], t = 1; t < n; ++t) e = s[t] / o[t - 1], o[t] -= e, a[t] -= e * a[t - 1];
  for (s[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t) s[t] = (a[t] - s[t + 1]) / o[t];
  for (o[n - 1] = (i[n] + s[n - 1]) / 2, t = 0; t < n - 1; ++t) o[t] = 2 * i[t + 1] - s[t + 1];
  return [s, o];
}
function Ni(i) {
  return new bt(i);
}
function N(i, t) {
  this._context = i, this._t = t;
}
N.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(i, t);
        else {
          var n = this._x * (1 - this._t) + i * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = i, this._y = t;
  }
};
function Ci(i) {
  return new N(i, 0.5);
}
function Ii(i) {
  return new N(i, 0);
}
function Zi(i) {
  return new N(i, 1);
}
class sn extends O {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(t, n, e) {
    let s, o, a;
    const r = e || q;
    t && (s = t.x, o = t.y, a = 2);
    const { width: h, height: l } = ni.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    n.transition().duration(r.duration).ease(r.ease).attr(
      "transform",
      `translate(${h / 2}, ${l / 2}) scale(${a}) translate(${-s},${-o})`
    ), this.services.events.dispatchEvent(w.CanvasZoom.CANVAS_ZOOM_IN, {
      element: ei(t)
    });
  }
  zoomOut(t, n) {
    const e = n || q;
    t.transition().duration(e.duration).ease(e.ease).attr("transform", ""), this.services.events.dispatchEvent(w.CanvasZoom.CANVAS_ZOOM_OUT);
  }
}
class on extends O {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(t, n) {
    this.documentFragment.addEventListener(t, n);
  }
  removeEventListener(t, n) {
    this.documentFragment.removeEventListener(t, n);
  }
  dispatchEvent(t, n) {
    let e;
    n ? e = new CustomEvent(t, {
      detail: n
    }) : (e = document.createEvent("Event"), e.initEvent(t, !1, !0)), this.documentFragment.dispatchEvent(e);
  }
}
class an extends O {
  constructor(t, n) {
    super(t, n);
  }
  downloadCSV(t, n) {
    const e = document.createElement("a"), s = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([t], {
          type: s
        }),
        n
      );
    else if (URL && "download" in e) {
      const o = URL.createObjectURL(
        new Blob([t], {
          type: s
        })
      );
      e.href = o, e.setAttribute("download", n), document.body.appendChild(e), e.click(), document.body.removeChild(e), URL.revokeObjectURL(o);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(t)}`;
  }
  downloadImage(t, n) {
    const e = document.createElement("a");
    e.download = n, e.href = t, document.body.appendChild(e), e.click(), document.body.removeChild(e);
  }
}
class rn extends O {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    this.services.events?.addEventListener(w.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: t, name: n, animate: e }) {
    return this.pendingTransitions[t._id] = t, t.on("end interrupt cancel", () => {
      delete this.pendingTransitions[t._id];
    }), this.model.getOptions().animations === !1 || e === !1 ? t.duration(0) : t.duration(
      c(W, n, "duration") || W.default.duration
    );
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
function S(i, t) {
  const n = +v(i) - +v(t);
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function Fi(i, t, n) {
  const [e, s] = M(
    n?.in,
    i,
    t
  );
  return e.getFullYear() - s.getFullYear();
}
function zi(i, t, n) {
  const [e, s] = M(
    n?.in,
    i,
    t
  ), o = S(e, s), a = Math.abs(Fi(e, s));
  e.setFullYear(1584), s.setFullYear(1584);
  const r = S(e, s) === -o, h = o * (a - +r);
  return h === 0 ? 0 : h;
}
function X(i, t, n) {
  const e = v(i, n?.in);
  if (isNaN(t)) return E(i, NaN);
  if (!t)
    return e;
  const s = e.getDate(), o = E(i, e.getTime());
  o.setMonth(e.getMonth() + t + 1, 0);
  const a = o.getDate();
  return s >= a ? o : (e.setFullYear(
    o.getFullYear(),
    o.getMonth(),
    s
  ), e);
}
function St(i, t, n) {
  return X(i, t * 12, n);
}
function Vi(i, t, n) {
  return St(i, -t, n);
}
function Hi(i, t, n) {
  const [e, s] = M(
    n?.in,
    i,
    t
  ), o = e.getFullYear() - s.getFullYear(), a = e.getMonth() - s.getMonth();
  return o * 12 + a;
}
function Yi(i, t) {
  const n = v(i, t?.in);
  return n.setHours(23, 59, 59, 999), n;
}
function Xi(i, t) {
  const n = v(i, t?.in), e = n.getMonth();
  return n.setFullYear(n.getFullYear(), e + 1, 0), n.setHours(23, 59, 59, 999), n;
}
function Gi(i, t) {
  const n = v(i, t?.in);
  return +Yi(n, t) == +Xi(n, t);
}
function $i(i, t, n) {
  const [e, s, o] = M(
    n?.in,
    i,
    i,
    t
  ), a = S(s, o), r = Math.abs(
    Hi(s, o)
  );
  if (r < 1) return 0;
  s.getMonth() === 1 && s.getDate() > 27 && s.setDate(30), s.setMonth(s.getMonth() - a * r);
  let h = S(s, o) === -a;
  Gi(e) && r === 1 && S(e, o) === 1 && (h = !1);
  const l = a * (r - +h);
  return l === 0 ? 0 : l;
}
function Ui(i, t, n) {
  return X(i, -t, n);
}
function Ki(i, t, n) {
  const [e, s] = M(
    n?.in,
    i,
    t
  ), o = rt(e, s), a = Math.abs(
    qt(e, s)
  );
  e.setDate(e.getDate() - o * a);
  const r = +(rt(e, s) === -o), h = o * (a - r);
  return h === 0 ? 0 : h;
}
function rt(i, t) {
  const n = i.getFullYear() - t.getFullYear() || i.getMonth() - t.getMonth() || i.getDate() - t.getDate() || i.getHours() - t.getHours() || i.getMinutes() - t.getMinutes() || i.getSeconds() - t.getSeconds() || i.getMilliseconds() - t.getMilliseconds();
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function Pt(i, t, n) {
  const e = v(i, n?.in);
  return isNaN(t) ? E(i, NaN) : (t && e.setDate(e.getDate() + t), e);
}
function ji(i, t, n) {
  return Pt(i, -t, n);
}
function G(i) {
  return (t) => {
    const e = (i ? Math[i] : Math.trunc)(t);
    return e === 0 ? 0 : e;
  };
}
function qi(i, t, n) {
  const [e, s] = M(
    n?.in,
    i,
    t
  ), o = (+e - +s) / ft;
  return G(n?.roundingMethod)(o);
}
function Et(i, t, n) {
  return E(i, +v(i) + t);
}
function wt(i, t, n) {
  return Et(i, t * ft);
}
function Wi(i, t, n) {
  return wt(i, -t);
}
function kt(i, t) {
  return +v(i) - +v(t);
}
function ht(i, t, n) {
  const e = kt(i, t) / pt;
  return G(n?.roundingMethod)(e);
}
function Z(i, t, n) {
  const e = v(i, n?.in);
  return e.setTime(e.getTime() + t * pt), e;
}
function ct(i, t, n) {
  return Z(i, -t, n);
}
function lt(i, t, n) {
  const e = kt(i, t) / 1e3;
  return G(n?.roundingMethod)(e);
}
function F(i, t, n) {
  return Et(i, t * 1e3);
}
function _t(i, t, n) {
  return F(i, -t);
}
class hn extends O {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: t = null } = {}) {
    if (this.dualAxes && t) {
      const n = this.model.getOptions(), { groupMapsTo: e } = n.data, s = c(n, "axes", this.secondaryDomainAxisPosition), o = t[e];
      if (s?.correspondingDatasets && s.correspondingDatasets.includes(o))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: t = null, groups: n = null } = {}) {
    if (this.dualAxes) {
      const e = this.model.getOptions(), { groupMapsTo: s } = e.data, o = c(e, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (t !== null ? a = t[s] : n && n.length > 0 && (a = n[0]), o?.correspondingDatasets && o.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(t) {
    return c(this.model.getOptions(), "axes", t);
  }
  getDomainAxisOptions() {
    const t = this.getDomainAxisPosition();
    return this.getAxisOptions(t);
  }
  getRangeAxisOptions() {
    const t = this.getRangeAxisPosition();
    return this.getAxisOptions(t);
  }
  getScaleLabel(t) {
    const e = this.getAxisOptions(t).title;
    return e || (t === _.BOTTOM || t === _.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(_).map(
      (n) => _[n]
    ).forEach((n) => {
      this.scales[n] = this.createScale(n);
    });
  }
  findDomainAndRangeAxes() {
    const t = this.findVerticalAxesPositions(), n = this.findHorizontalAxesPositions(), e = this.findDomainAndRangeAxesPositions(
      t,
      n
    );
    this.domainAxisPosition = e.primaryDomainAxisPosition, this.rangeAxisPosition = e.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = e.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = e.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === _.LEFT || this.rangeAxisPosition === _.RIGHT) && (this.domainAxisPosition === _.BOTTOM || this.domainAxisPosition === _.TOP) ? this.orientation = C.VERTICAL : this.orientation = C.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    const t = this.model.getOptions(), n = c(t, "axes");
    (n[_.LEFT]?.correspondingDatasets && n[_.RIGHT] || n[_.RIGHT]?.correspondingDatasets && n[_.LEFT] || n[_.TOP]?.correspondingDatasets && n[_.BOTTOM] || n[_.BOTTOM]?.correspondingDatasets && n[_.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(t) {
    const n = c(this.model.getOptions(), "axes", t, "domain");
    if (n && !Array.isArray(n))
      throw new Error(`Domain in ${t} axis is not a valid array`);
    if (Array.isArray(n) && (this.scaleTypes[t] === p.LINEAR || this.scaleTypes[t] === p.TIME) && n.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[t]}`
      );
    return n;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(t) {
    return this.scales[t];
  }
  getScaleTypeByPosition(t) {
    return this.scaleTypes[t];
  }
  getDomainAxisScaleType() {
    const t = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getRangeAxisScaleType() {
    const t = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const t = [_.BOTTOM, _.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const t = [_.LEFT, _.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(t, n, e, s) {
    const o = this.model.getOptions(), r = c(o, "axes")[e], { mapsTo: h } = r, l = c(s, h) !== null ? s[h] : s;
    let f;
    switch (n) {
      case p.LABELS:
        f = t(l) + t.step() / 2;
        break;
      case p.TIME:
        f = t(new Date(l));
        break;
      default:
        f = t(l);
    }
    return f;
  }
  getBoundedScaledValues(t) {
    const { bounds: n } = this.model.getOptions(), e = this.getRangeAxisPosition({ datum: t }), s = this.scales[e], o = this.model.getOptions(), r = c(o, "axes")[e], { mapsTo: h } = r, l = t[h] !== void 0 ? t[h] : t;
    return [
      s(
        c(t, n.upperBoundMapsTo) !== null ? t[n.upperBoundMapsTo] : l
      ),
      s(
        c(t, n.lowerBoundMapsTo) !== null ? t[n.lowerBoundMapsTo] : l
      )
    ];
  }
  getValueThroughAxisPosition(t, n) {
    const e = this.scaleTypes[t], s = this.scales[t];
    return this.getValueFromScale(s, e, t, n);
  }
  getDomainValue(t) {
    const n = this.getDomainAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getRangeValue(t) {
    const n = this.getRangeAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(t) {
    const n = this.model.getOptions();
    return c(n, "axes", this.getDomainAxisPosition({ datum: t }), "mapsTo");
  }
  getRangeIdentifier(t) {
    const n = this.model.getOptions();
    return c(n, "axes", this.getRangeAxisPosition({ datum: t }), "mapsTo");
  }
  extendsDomain(t, n) {
    const e = this.model.getOptions(), s = c(e, "axes", t);
    if (s.scaleType === p.TIME) {
      const o = c(e, "timeScale", "addSpaceOnEdges");
      return Ji(n, o);
    } else
      return Qi(n, J.paddingRatio, s.scaleType);
  }
  findVerticalAxesPositions() {
    const t = this.model.getOptions(), n = c(t, "axes"), e = this.isDualAxes();
    return c(n, _.LEFT) === null && c(n, _.RIGHT) !== null || c(n, _.RIGHT, "main") === !0 || e && c(n, _.LEFT, "correspondingDatasets") ? {
      primary: _.RIGHT,
      secondary: _.LEFT
    } : { primary: _.LEFT, secondary: _.RIGHT };
  }
  findHorizontalAxesPositions() {
    const t = this.model.getOptions(), n = c(t, "axes"), e = this.isDualAxes();
    return c(n, _.BOTTOM) === null && c(n, _.TOP) !== null || c(n, _.TOP, "main") === !0 || e && c(n, _.BOTTOM, "correspondingDatasets") ? {
      primary: _.TOP,
      secondary: _.BOTTOM
    } : { primary: _.BOTTOM, secondary: _.TOP };
  }
  findDomainAndRangeAxesPositions(t, n) {
    const e = this.model.getOptions(), s = c(e, "axes", t.primary), o = c(e, "axes", n.primary), a = s.scaleType || p.LINEAR, r = o.scaleType || p.LINEAR, h = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return h.primaryDomainAxisPosition = n.primary, h.primaryRangeAxisPosition = t.primary, h.secondaryDomainAxisPosition = n.secondary, h.secondaryRangeAxisPosition = t.secondary, (!(r === p.LABELS || r === p.TIME) && a === p.LABELS || a === p.TIME) && (h.primaryDomainAxisPosition = t.primary, h.primaryRangeAxisPosition = n.primary, h.secondaryDomainAxisPosition = t.secondary, h.secondaryRangeAxisPosition = n.secondary), h;
  }
  getScaleDomain(t) {
    const n = this.model.getOptions(), e = c(n, "axes", t), s = c(n, "bounds"), { includeZero: o } = e, a = c(e, "scaleType") || p.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (e.binned) {
      const { bins: u } = this.model.getBinConfigurations();
      return [0, Wt(u, (x) => x.length)];
    } else if (e.limitDomainToBins) {
      const { bins: u } = this.model.getBinConfigurations(), x = this.model.getStackKeys({ bins: u });
      return [x[0].split(":")[0], x[x.length - 1].split(":")[1]];
    }
    const r = this.model.getDisplayData(), { extendLinearDomainBy: h, mapsTo: l, percentage: f, thresholds: y } = e, { reference: d, compareTo: T } = J.ratio;
    if (e.domain)
      return a === p.LABELS ? e.domain : (a === p.TIME && (e.domain = e.domain.map(
        (u) => u.getTime === void 0 ? new Date(u) : u
      )), this.extendsDomain(t, e.domain));
    if (f)
      return [0, 100];
    if (e && a === p.LABELS)
      return Jt(r.map((u) => u[l]));
    let g, m;
    const D = this.model.getDataGroupNames();
    if (a === p.LABELS_RATIO)
      return r.map((u) => `${u[d]}/${u[T]}`);
    if (a === p.TIME)
      m = r.map((u) => +new Date(u[l]));
    else if (s && n.axes)
      m = [], r.forEach((u) => {
        m.push(u[l]), u[s.upperBoundMapsTo] && m.push(u[s.upperBoundMapsTo]), u[s.lowerBoundMapsTo] && m.push(u[s.lowerBoundMapsTo]);
      });
    else if (e.stacked === !0 && D && t === this.getRangeAxisPosition()) {
      const { groupMapsTo: u } = n.data, x = this.model.getDataValuesGroupedByKeys({
        groups: D
      }), Rt = r.filter(
        (b) => !D.includes(b[u])
      ), $ = [];
      x.forEach((b) => {
        const { ...Bt } = b;
        let U = 0, K = 0;
        Object.values(di(Bt, "sharedStackKey")).forEach((P) => {
          isNaN(P) || (P < 0 ? K += P : U += P);
        }), $.push([K, U]);
      }), m = [
        ...dt($),
        ...Rt.map((b) => b[l])
      ];
    } else
      m = [], r.forEach((u) => {
        const x = u[l];
        Array.isArray(x) && x.length === 2 ? (m.push(x[0]), m.push(x[1])) : (h && m.push(Math.max(u[l], u[h])), m.push(x));
      });
    return a !== p.TIME && a !== p.LOG && o && m.push(0), y && y.length > 0 && y.forEach((u) => {
      const x = c(u, "value");
      x !== null && m.push(x);
    }), g = mt(m), g = this.extendsDomain(t, g), g;
  }
  createScale(t) {
    const n = this.model.getOptions(), e = c(n, "axes", t);
    if (!e)
      return null;
    const s = c(e, "scaleType") || p.LINEAR;
    this.scaleTypes[t] = s;
    let o;
    return s === p.TIME ? o = si() : s === p.LOG ? o = xt().base(e.base || 10) : s === p.LABELS || s === p.LABELS_RATIO ? o = oi() : o = Qt(), o.domain(this.getScaleDomain(t)), o;
  }
  getDomainLowerBound(t) {
    let n, e = 0;
    return this.getOrientation() === C.VERTICAL ? n = this.getMainYScale().domain() : n = this.getMainXScale().domain(), c(this.model.getOptions(), "axes", t, "includeZero") === !1 && n[0] > 0 && n[1] > 0 && (e = n[0]), e;
  }
  getHighestDomainThreshold() {
    const t = c(this.model.getOptions(), "axes"), n = this.getDomainAxisPosition(), { thresholds: e } = t[n];
    if (!Array.isArray(e) || Array.isArray(e) && !e.length)
      return null;
    const s = this.getDomainScale(), o = e.sort((r, h) => h.value - r.value)[0];
    return this.getScaleTypeByPosition(n) === p.TIME && (typeof o.value == "string" || o.value.getTime === void 0) && (o.value = new Date(o.value)), {
      threshold: o,
      scaleValue: s(o.value)
    };
  }
  getHighestRangeThreshold() {
    const t = c(this.model.getOptions(), "axes"), n = this.getRangeAxisPosition(), { thresholds: e } = t[n];
    if (!Array.isArray(e) || Array.isArray(e) && !e.length)
      return null;
    const s = this.getRangeScale(), o = e.sort((a, r) => r.value - a.value)[0];
    return {
      threshold: o,
      scaleValue: s(o.value)
    };
  }
}
function Ji(i, t) {
  const n = new Date(i[0]), e = new Date(i[1]);
  return zi(e, n) > 1 ? [Vi(n, t), St(e, t)] : $i(e, n) > 1 ? [Ui(n, t), X(e, t)] : Ki(e, n) > 1 ? [ji(n, t), Pt(e, t)] : qi(e, n) > 1 ? [Wi(n, t), wt(e, t)] : ht(e, n) > 30 ? [
    ct(n, t * 30),
    Z(e, t * 30)
  ] : ht(e, n) > 1 ? [ct(n, t), Z(e, t)] : lt(e, n) > 15 ? [
    _t(n, t * 15),
    F(e, t * 15)
  ] : lt(e, n) > 1 ? [_t(n, t), F(e, t)] : [n, e];
}
function Qi([i, t], n, e) {
  const o = (t - i) * n, a = t <= 0 && t + o > 0 ? 0 : t + o;
  let r = i >= 0 && i - o < 0 ? 0 : i - o;
  if (e === p.LOG && r <= 0) {
    if (i <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    r = i;
  }
  return [r, a];
}
class cn extends O {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: ri,
      curveLinearClosed: ai,
      curveBasis: Oi,
      curveBasisClosed: Ai,
      curveBasisOpen: Mi,
      curveBundle: bi,
      curveCardinal: Si,
      curveCardinalClosed: Pi,
      curveCardinalOpen: Ei,
      curveCatmullRom: wi,
      curveCatmullRomClosed: ki,
      curveCatmullRomOpen: Ri,
      curveMonotoneX: Bi,
      curveMonotoneY: Li,
      curveNatural: Ni,
      curveStep: Ci,
      curveStepAfter: Zi,
      curveStepBefore: Ii
    };
  }
  getD3Curve() {
    let t = "curveLinear";
    const n = this.model.getOptions().curve;
    if (n && (typeof n == "string" ? t = n : t = n.name), this.curveTypes[t]) {
      let e = this.curveTypes[t];
      return n && Object.keys(n).forEach((s) => {
        e[s] && (e = e[s](n[s]));
      }), e;
    }
    return console.warn(`The curve type '${t}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}
class ln extends O {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !c(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const t = this.services.cartesianScales.getMainXAxisPosition(), n = c(
      this.model.getOptions(),
      "axes",
      t,
      "scaleType"
    );
    return t === _.BOTTOM && n === p.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const t = this.model.getZoomBarData();
    return t && t.length > 1 ? t : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(t) {
    if (!this.services.zoom) throw new Error("Services zoom not defined");
    const n = t || this.services.zoom.getZoomBarData(), { cartesianScales: e } = this.services;
    if (!e) throw new Error("Services cartesianScales undefined");
    const s = e.getMainXAxisPosition(), o = e.getDomainIdentifier(), a = c(this.model.getOptions(), "axes", s, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!s) throw new Error("Not defined: mainXAxisPosition");
    return e.extendsDomain(
      s,
      mt(n, (r) => r[o])
    );
  }
  handleDomainChange(t, n = { dispatchEvent: !0, type: "manual" }) {
    this.model.set({ zoomDomain: t }, { animate: !1 }), n.dispatchEvent && this.services.events?.dispatchEvent(w.ZoomDomain.CHANGE, {
      newDomain: t,
      type: n.type
    });
  }
  getZoomRatio() {
    return c(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(t, n) {
    const e = this.model.get("zoomDomain"), s = Object.assign(
      { stacked: !1 },
      // default configs
      n
    ), o = c(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && o && e) {
      const a = s.stacked ? "sharedStackKey" : this.services.cartesianScales?.getDomainIdentifier(), r = t.filter(
        (h) => new Date(h[a]) >= e[0] && new Date(h[a]) <= e[1]
      );
      if (r.length > 0)
        return r;
    }
    return t;
  }
  zoomIn(t = this.getZoomRatio()) {
    const n = this.model.get("zoomDomain"), e = ti.handleWidth, s = this.services.cartesianScales?.getMainXScale().copy();
    s.domain(this.getDefaultZoomBarDomain());
    const o = s(n[0]), a = s(n[1]);
    if (a - o < e + 1)
      return;
    const r = s.range(), h = a - o, l = Math.min((r[1] - r[0]) / 2 * (t / 2), h / 2);
    let f = o + l, y = a - l;
    f >= y && (f = o + h / 2 - e / 2, y = a - h / 2 + e / 2);
    const d = [s.invert(f), s.invert(y)];
    (n[0].valueOf() !== d[0].valueOf() || n[1].valueOf() !== d[1].valueOf()) && this.handleDomainChange(d, { dispatchEvent: !0, type: "in" });
  }
  zoomOut(t = this.getZoomRatio()) {
    const n = this.model.get("zoomDomain");
    if (!this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const e = this.services.cartesianScales.getMainXScale().copy();
    e.domain(this.getDefaultZoomBarDomain());
    const s = e(n[0]), o = e(n[1]), a = e.range(), r = (a[1] - a[0]) / 2 * (t / 2), h = Math.max(s - r, a[0]), l = Math.min(o + r, a[1]), f = [e.invert(h), e.invert(l)];
    (n[0].valueOf() !== f[0].valueOf() || n[1].valueOf() !== f[1].valueOf()) && this.handleDomainChange(f, { dispatchEvent: !0, type: "out" });
  }
  resetZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    (t[0].valueOf() !== n[0].valueOf() || t[1].valueOf() !== n[1].valueOf()) && this.handleDomainChange(n, { dispatchEvent: !0, type: "reset" });
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    if (!t || !n)
      return !1;
    const e = t[1].valueOf() - t[0].valueOf(), s = n[1].valueOf() - n[0].valueOf(), o = c(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return e / s < o;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    return !!(t && n && t[0].valueOf() === n[0].valueOf() && t[1].valueOf() === n[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(t) {
    return c(this.model.getOptions(), "zoomBar", t, "loading");
  }
  isZoomBarLocked(t) {
    return c(this.model.getOptions(), "zoomBar", t, "locked");
  }
}
export {
  sn as C,
  on as E,
  an as F,
  rn as T,
  ln as Z,
  cn as a,
  ci as b,
  hn as c,
  dt as f
};
//# sourceMappingURL=index-CQFVDkrk.mjs.map
